<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"haoqinx.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="星海横流 岁月成碑">
<meta property="og:type" content="website">
<meta property="og:title" content="面向自由编程">
<meta property="og:url" content="http://haoqinx.github.io/page/10/index.html">
<meta property="og:site_name" content="面向自由编程">
<meta property="og:description" content="星海横流 岁月成碑">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="hqin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://haoqinx.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>面向自由编程</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">面向自由编程</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9AGDT%EF%BC%8CLDT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9AGDT%EF%BC%8CLDT/" class="post-title-link" itemprop="url">Linux内核系列：GDT/LDT</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-29T00:00:00+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:59:32" itemprop="dateModified" datetime="2022-09-25T01:59:32+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h3><p>现代的内存寻址方式一般采用保护模式。    </p>
<p>Q:什么是保护模式？   </p>
<p>A:保护模式是相对于实模式来说的，以前的内存寻址是直接由cpu段寄存器+偏移量去实存里面找物理地址，例如在8086的时候，也就是16位cpu的时候，CPU配备了4个16位段寄存器（CS代码段寄存器、DS数据段寄存器、SS堆栈段寄存器和ES附加寄存器），这种方式非常粗暴并且很容易出错，一旦用户修改段寄存的值，就可以随意访问所有内存，到了80296芯片，大家意识到直接访问实地址的危害，intel将寻址方式改为保护模式，保护模式下段寄存器不在指向一个真实地址，而是变成指向一个数据结构的指针，这个数据结构就是<font color = orange>Segment Descripter Table</font>，又根据这个段描述符表里存的是全局共同的，还是进程私有的，分成了全局段描述符表（GDT）和局部段描述符表（LDT）。  </p>
<p>需要了解的：</p>
<ol>
<li>GDT里面具体存的是什么？  <ul>
<li>段描述符，8字节，包括系统级段描述符和LDT段描述符</li>
</ul>
</li>
<li>我们访问内存的具体步骤是什么？<ul>
<li>从GDTR中拿到GDT在内存中的基地址，得到段描述符表；</li>
<li>从段选择子中的前13位得到我们要访问的段的描述符在段描述符表中的索引（需要考虑TI和RPL）；</li>
<li>从段描述符表中得到要访问的段的描述符，得到其基地址；</li>
<li>基地址加上偏移地址就是我们要访问的内存地址（当然这里是虚拟地址，接下来是分页机制的功能将虚地址转换为物理地址，不做讨论。）</li>
</ul>
</li>
</ol>
<p>具体参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenwb89/p/operating_system_003.html">这篇文章</a>，<a target="_blank" rel="noopener" href="http://www.techbulo.com/708.html">这篇文章</a></p>
<h3 id="LDT"><a href="#LDT" class="headerlink" title="LDT"></a>LDT</h3><p>LDT和GDT差不多，区别有：</p>
<ol>
<li>LDT是局部段描述符表，GDT是全局段描述符表</li>
<li>LDT可以有多个，GDT只能有一个</li>
<li>LDT本身是个段，需要在GDT中保存其自身描述符</li>
<li>GDT用来描述系统的分段，LDT用来描述某个任务的分段情况，由于每个进程都有自己的一套程序段、数据段、堆栈段，有了局部描述符表则可以将每个进程的程序段、数据段、堆栈段封装在一起，只要改变LDTR就可以实现对不同进程的段进行访问。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Ammap%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Ammap%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/" class="post-title-link" itemprop="url">c++内存管理系列：mmap原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-29T00:00:00+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:59:36" itemprop="dateModified" datetime="2022-09-25T01:59:36+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>内存映射，简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间&lt;—-&gt;用户空间两者之间需要大量数据传输等操作的话效率是非常高的。</p>
<h3 id="传统的读写文件"><a href="#传统的读写文件" class="headerlink" title="传统的读写文件"></a>传统的读写文件</h3><p>一般来说，修改一个文件的内容需要如下3个步骤：</p>
<ul>
<li>把文件内容读入到内存中。</li>
<li>修改内存中的内容。</li>
<li>把内存的数据写入到文件中。</li>
</ul>
<p><img src="/images/mmap-1.png"><br>从图中可以看出，页缓存(page cache) 是读写文件时的中间层，内核使用<font color=orange>页缓存</font>与文件的数据块关联起来。所以应用程序读写文件时，实际操作的是页缓存。</p>
<h3 id="mmap读写文件"><a href="#mmap读写文件" class="headerlink" title="mmap读写文件"></a>mmap读写文件</h3><p>mmap并不分配空间, 只是将文件映射到调用进程的地址空间里（但是会占掉你的 virutal memory）, 然后你就可以用memcpy等操作写文件, 而不用write()了.写完后，内存中的内容并不会立即更新到文件中，而是有一段时间的延迟，你可以调用msync()来显式同步一下, 这样你所写的内容就能立即保存到文件里了.这点应该和驱动相关。 不过通过mmap来写文件这种方式没办法增加文件的长度, 因为要映射的长度在调用mmap()的时候就决定了.如果想取消内存映射，可以调用munmap()来取消内存映射。</p>
<p>函数调用的格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">//返回:若成功则为被映射区的起始地址，若出错则为MAP_FAILED</span></span><br></pre></td></tr></table></figure>
<p>其中addr可以指定描述符fd应该被映射到的进程内空间的起始地址。它通常被指定为一个空指针，这样告诉内核自己去选择起始地址。无论哪种情况下，该函数的返回值都是描述符fd所映射到内存的起始地址。</p>
<p>len是映射到调用进程地址空间中的字节数，它从被映射文件开头起第offset个字节处开始算。offset通常设置为0。</p>
<p>内存映射区的保护由prot参数指定，该参数的常见值是代表读写访问的PROT_READ|PROT_WRITE</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prot          说明</span><br><span class="line">PROT_READ    数据可读</span><br><span class="line">PROT_WRITE   数据可写</span><br><span class="line">PROT_EXEC    数据可执行</span><br><span class="line">PROT_NONE    数据不可访问</span><br></pre></td></tr></table></figure>

<p>从传统读写文件的过程中，我们可以发现有个地方可以优化：如果可以直接在用户空间读写 页缓存，那么就可以免去将 页缓存 的数据复制到用户空间缓冲区的过程。<br>那么，有没有这样的技术能实现上面所说的方式呢？答案是肯定的，就是 mmap。<br>使用 mmap 系统调用可以将用户空间的虚拟内存地址与文件进行映射（绑定），对映射后的虚拟内存地址进行读写操作就如同对文件进行读写操作一样。原理如图所示：</p>
<p><img src="/images/mmap-2.png"></p>
<p>前面我们介绍过，读写文件都需要经过 页缓存，所以 mmap 映射的正是文件的 页缓存，而非磁盘中的文件本身。由于 mmap 映射的是文件的 页缓存，所以就涉及到同步的问题，即 页缓存 会在什么时候把数据同步到磁盘。<br>Linux 内核并不会主动把 mmap 映射的 页缓存 同步到磁盘，而是需要用户主动触发。同步 mmap 映射的内存到磁盘有 4 个时机：</p>
<ul>
<li>调用 msync 函数主动进行数据同步（主动）。</li>
<li>调用 munmap 函数对文件进行解除映射关系时（主动）。</li>
<li>进程退出时（被动）。</li>
<li>系统关机时（被动）。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p>
<ul>
<li><p>进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</p>
<ul>
<li><p>进程在用户空间调用库函数mmap;</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址;</p>
</li>
<li><p>为此虚拟区分配一个vmareastruct结构，接着对这个结构的各个域进行了初始化;</p>
</li>
<li><p>将新建的虚拟区结构（vmareastruct）插入进程的虚拟地址区域链表或树中</p>
</li>
</ul>
</li>
<li><p>调用内核空间的系统调用函数 mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</p>
<ul>
<li>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</li>
<li>通过该文件的文件结构体，链接到 file_operations 模块，调用内核函数mmap ：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br></pre></td></tr></table></figure>
  不同于用户空间库函数。</li>
<li>内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</li>
<li>通过remappfnrange函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。</li>
</ul>
</li>
<li><p>进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝</p>
<ul>
<li>进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</li>
<li>缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</li>
<li>调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</li>
<li>之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</li>
</ul>
</li>
<li><p>注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Aptmalloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Aptmalloc/" class="post-title-link" itemprop="url">Linux内核系列：malloc底层原理(ptmalloc)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-29T00:00:00+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:59:39" itemprop="dateModified" datetime="2022-09-25T01:59:39+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="linux进程地址空间"><a href="#linux进程地址空间" class="headerlink" title="linux进程地址空间"></a>linux进程地址空间</h3><p><img src="/images/malloc-1.png"></p>
<p>如上图所示在一个32位系统中，可寻址的空间大小是4G，linux系统下0-3G是用户模式，3-4G是内核模式。而在用户模式下又分为代码段、数据段、.bss段、堆、栈。其中代码段主要存放进程的可执行二进制代码，字符串字面值和只读变量。数据段存放已经初始化且初始值非0的全局变量和局部静态变量。bss段则存放未初始化或初始值为0的全局变量和局部静态变量。而堆段则是存放由用户动态分配内存存储的变量。栈段则主要存储局部变量、函数参数、返回地址等。</p>
<p>bss段、数据段和代码段是可执行程序编译时的分段，运行时还需要栈和堆。将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和bss段的加载，并在内存中为这些段分配空间。栈也由操作系统分配和管理而堆则是由程序员自己管理。</p>
<h3 id="malloc内存单元"><a href="#malloc内存单元" class="headerlink" title="malloc内存单元"></a>malloc内存单元</h3><p>chunk结构体<br>        <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<!--more-->

<ul>
<li><p>源码注释写到：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Chunks of memory are maintained using a `boundary tag&#x27; method as</span></span><br><span class="line"><span class="comment">described in e.g., Knuth or Standish.  (See the paper by Paul</span></span><br><span class="line"><span class="comment">Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span></span><br><span class="line"><span class="comment">survey of such techniques.)  Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">in the front of each chunk and at the end.  This makes</span></span><br><span class="line"><span class="comment">consolidating fragmented chunks into bigger chunks very fast.  The</span></span><br><span class="line"><span class="comment">size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">in use.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             Size of previous chunk, if allocated            | |</span></span><br><span class="line"><span class="comment">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             Size of chunk, in bytes                       |M|P|</span></span><br><span class="line"><span class="comment">    mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             User data starts here...                          .</span></span><br><span class="line"><span class="comment">        .                                                               .</span></span><br><span class="line"><span class="comment">        .             (malloc_usable_size() bytes)                      .</span></span><br><span class="line"><span class="comment">        .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             Size of chunk                                     |</span></span><br><span class="line"><span class="comment">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>大概意思就是使用了boundary tag技术，也就是free block上下两端加cookie，还记得vc6和STL的allocator章节的图，就像下面这样。</p>
<p>  <img src="/images/cookie.png"></p>
</li>
<li><p>注释中继续描述了chunk的组织方式——双向链表.</p>
<pre><code>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             Size of previous chunk                            |</span></span><br><span class="line"><span class="comment">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `head:&#x27; |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="comment">    mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="comment">        .                                                               .</span></span><br><span class="line"><span class="comment">        .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `foot:&#x27; |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="comment">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        */</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>我们看一下结构体中的变量。</p>
<ul>
<li>prev_size：如果前一个chunk是空闲的，该域表示前一个chunk的大小，如果前一个chunk不空闲，该域无意义。注意：这里的前一个指的是存储物理相邻地址较低的那一个chunk。</li>
<li>size：该 chunk 的大小，大小必须是 2 SIZE_SZ 的整数倍。如果申请的内存大小不是 2 SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示：<ul>
<li>A: NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程（分配区&#x2F;arena），1表示不属于，0表示属于。</li>
<li>M: IS_MAPPED，他表示当前chunk是从哪个内存区域获得的虚拟内存。M为1表示该chunk是从mmap映射区域分配的，否则是从heap区域分配的。</li>
<li>P: PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的P位都会被设置为1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲chunk之间的合并。</li>
</ul>
</li>
<li>fd，bk： chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
</ul>
</li>
<li>fd_nextsize， bk_nextsize：也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul>
<li>fd_nextsize指向下一个比当前chunk size小的第一个空闲chunk，不包含 bin 的头指针。</li>
<li>bk_nextszie指向上一个比当前chunk size大的第一个空闲chunk，不包含 bin 的头指针。</li>
<li>large bins中的空闲chunk是按照大小排序的。这样做可以避免在寻找合适chunk 时挨个遍历。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/malloc-4.png"></p>
<p>上图展示了chunk分配前后的变化，利用了嵌入式指针技术，这个技术在VC6和STL allocator中应用也很多。</p>
<h3 id="linux内存分配"><a href="#linux内存分配" class="headerlink" title="linux内存分配"></a>linux内存分配</h3><p>linux下可以使用系统调用</p>
<ul>
<li><p>mmap：内核将硬盘文件的内容直接映射到内存，任何应用程序都可通过 Linux 的 mmap() 系统调用请求这种映射。</p>
<ul>
<li>内存映射是一种方便高效的文件 I&#x2F;O 方式， 因而被用于装载动态共享库。</li>
<li>用户也可创建匿名内存映射，该映射没有对应的文件，可用于存放程序数据。<ul>
<li>在 Linux 中，若通过 malloc() 请求一大块内存，C 运行库将创建一个匿名内存映射，而不使用堆内存。“大块”意味着比阈值MMAP_THRESHOLD还大，缺省为 128KB，可通过 mallopt() 调整。</li>
</ul>
</li>
<li>mmap 映射区向下扩展，堆向上扩展，两者相对扩展，直到耗尽虚拟地址空间中的剩余区域。</li>
</ul>
</li>
<li><p>sbrk() 或brk()：start_brk和brk分别是堆的起始和终止地址，我们使用malloc动态分配的内存就在这之间。我们可以使用系统调用sbrk() 或brk()增加brk的值，达到增大堆空间的效果，但是系统调用代价太大，涉及到用户态和内核态的相互转换。所以，实际中系统分配较大的堆空间，进程通过malloc()库函数在堆上进行空间动态分配，堆如果不够用malloc可以进行系统调用，增大brk的值。</p>
<ul>
<li>两个系统调用的源码为：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">brk</span><span class="params">(<span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>;</span><br></pre></td></tr></table></figure>
  brk函数将break指针直接设置为某个地址，而sbrk将break指针从当前位置移动increment所指定的增量。brk在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break指针移动之前所指向的地址，否则返回(void *)-1。<br>  <font color=orange>如果将increment设置为0，则可以获得当前break的地址。另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有一小块可用内存地址）。</font></li>
</ul>
</li>
</ul>
<h3 id="malloc实现"><a href="#malloc实现" class="headerlink" title="malloc实现"></a>malloc实现</h3><p>linux下malloc源码分析具体可见《glibc内存管理ptmalloc源代码分析》一书.下面对其思想进行概括，主要掌握其思想，细节实现不在此讨论。</p>
<p>由于brk&#x2F;sbrk&#x2F;mmap属于系统调用，如果每次申请内存，都调用这三个函数中的一个，那么每次都要产生系统调用开销（即cpu从用户态切换到内核态的上下文切换，这里要保存用户态数据，等会还要切换回用户态），这是非常影响性能的；其次，这样申请的内存容易产生碎片，因为堆是从低地址到高地址，如果低地址的内存没有被释放，高地址的内存就不能被回收。鉴于此，malloc采用的是内存池的实现方式，malloc内存池实现方式更类似于STL分配器和memcached的内存池，先申请一大块内存，然后将内存分成不同大小的内存块，然后用户申请内存时，直接从内存池中选择一块相近的内存块即可。<br><img src="/images/malloc-3.png"></p>
<p>源码注释对bin的大小描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what&#x27;s left</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>内存池保存在bins这个长128的数组中，每个元素都是一双向个链表。</p>
<ul>
<li>bins[0]目前没有使用</li>
<li>bins[1]的链表称为unsorted_list，用于维护free释放的chunk。</li>
<li>bins[2,63)的区间称为small_bins，用于维护＜512字节的内存块，其中每个元素对应的链表中的chunk大小相同，均为<font color=orange>index*8</font>。</li>
<li>bins[64,127)称为large_bins，用于维护&gt;512字节的内存块，每个元素对应的链表中的chunk大小不同，index越大，链表中chunk的内存大小相差越大，例如: 下标为64的chunk大小介于[512, 512+64)，下标为95的chunk大小介于[2k+1,2k+512)。同一条链表上的chunk，按照从小到大的顺序排列。<br>malloc将内存分成了大小不同的chunk，然后通过bins来组织起来。</li>
<li>malloc将相似大小的chunk（图中可以看出同一链表上的chunk大小差不多）用双向链表链接起来，这样一个链表被称为一个bin。malloc一共维护了128个bin，并使用一个数组来存储这些bin。</li>
</ul>
<p>数组中第一个为<font color=orange>unsorted bin</font>，数组编号前2到前64的bin为<font color=orange>small bin</font>，同一个small bin中的chunk具有相同的大小，两个相邻的small bin中的chunk大小相差8bytes。small bins后面的bin被称作<font color=orange>large bin</font>。large bins中的每一个bin分别包含了一个给定范围内的chunk，其中的chunk按大小序排列。large bin的每个bin相差64字节。</p>
<p>malloc除了有unsorted bin，small bin，large bin三个bin之外，还有一个<font color=orange>fast bin</font>。一般的情况是，程序在运行时会经常需要申请和释放一些较小的内存空间。当分配器合并了相邻的几个小的 chunk 之后，也许马上就会有另一个小块内存的请求，这样分配器又需要从大的空闲内存中切分出一块，这样无疑是比较低效的，故而，malloc 中在分配过程中引入了 fast bins，不大于 max_fast(默认值为 64B)的 chunk 被释放后，首先会被放到 fast bins中，fast bins 中的 chunk 并不改变它的使用标志 P。这样也就无法将它们合并，当需要给用户分配的 chunk 小于或等于 max_fast 时，malloc 首先会在 fast bins 中查找相应的空闲块，然后才会去查找 bins 中的空闲 chunk。在某个特定的时候，malloc 会遍历 fast bins 中的 chunk，将相邻的空闲 chunk 进行合并，并将合并后的 chunk 加入 unsorted bin 中，然后再将 unsorted bin 里的 chunk 加入 bins 中。</p>
<p>unsorted bin 的队列使用 bins 数组的第一个，如果被用户释放的 chunk 大于 max_fast，或者 fast bins 中的空闲 chunk 合并后，这些 chunk 首先会被放到 unsorted bin 队列中，在进行 malloc 操作的时候，如果在 fast bins 中没有找到合适的 chunk，则malloc 会先在 unsorted bin 中查找合适的空闲 chunk，然后才查找 bins。如果 unsorted bin 不能满足分配要求。 malloc便会将 unsorted bin 中的 chunk 加入 bins 中。然后再从 bins 中继续进行查找和分配过程。从这个过程可以看出来，unsorted bin 可以看做是 bins 的一个缓冲区，增加它只是为了加快分配的速度。（其实感觉在这里还利用了局部性原理，常用的内存块大小差不多，从unsorted bin这里取就行了，这个和TLB之类的都是异曲同工之妙啊！）</p>
<p>除了上述四种bins之外，malloc还有三种内存区。</p>
<ul>
<li>当fast bin和bins都不能满足内存需求时，malloc会设法在top chunk中分配一块内存给用户；top chunk为在mmap区域分配一块较大的空闲内存模拟sub-heap。（比较大的时候） &gt;top chunk是堆顶的chunk，堆顶指针brk位于top chunk的顶部。移动brk指针，即可扩充top chunk的大小。当top chunk大小超过128k(可配置)时，会触发malloc_trim操作，调用sbrk(-size)将内存归还操作系统。</li>
<li>当chunk足够大，fast bin和bins都不能满足要求，甚至top chunk都不能满足时，malloc会从mmap来直接使用内存映射来将页映射到进程空间，这样的chunk释放时，直接解除映射，归还给操作系统。（极限大的时候）</li>
<li>Last remainder是另外一种特殊的chunk，就像top chunk和mmaped chunk一样，不会在任何bins中找到这种chunk。当需要分配一个small chunk,但在small bins中找不到合适的chunk，如果last remainder chunk的大小大于所需要的small chunk大小，last remainder chunk被分裂成两个chunk，其中一个chunk返回给用户，另一个chunk变成新的last remainder chunk。（这个应该是fast bins中也找不到合适的时候，用于极限小的）<br>我们再来看这个分配前后的图：<br><img src="/images/malloc-4.png"></li>
</ul>
<p>由之前的分析可知malloc利用chunk结构来管理内存块，malloc就是由不同大小的chunk链表组成的。malloc会给用户分配的空间的前后加上一些控制信息，用这样的方法来记录分配的信息，以便完成分配和释放工作。chunk指针指向chunk开始的地方,图中的mem指针才是真正返回给用户的内存指针。</p>
<ul>
<li>chunk 的第二个域的最低一位为P，它表示前一个块是否在使用中，P 为 0 则表示前一个 chunk 为空闲，这时chunk的第一个域 prev_size 才有效，prev_size 表示前一个 chunk 的 size，程序可以使用这个值来找到前一个 chunk 的开始地址。当 P 为 1 时，表示前一个 chunk 正在使用中，prev_size程序也就不可以得到前一个 chunk 的大小。不能对前一个 chunk 进行任何操作。malloc分配的第一个块总是将 P 设为 1，以防止程序引用到不存在的区域。</li>
<li>Chunk 的第二个域的倒数第二个位为M，他表示当前 chunk 是从哪个内存区域获得的虚拟内存。M 为 1 表示该 chunk 是从 mmap 映射区域分配的，否则是从 heap 区域分配的。</li>
<li>Chunk 的第二个域倒数第三个位为 A，表示该 chunk 属于主分配区或者非主分配区，如果属于非主分配区，将该位置为 1，否则置为 0。<br>当chunk空闲时，其M状态是不存在的，只有AP状态，原本是用户数据区的地方存储了四个指针，指针fd指向后一个空闲的chunk,而bk指向前一个空闲的chunk，malloc通过这两个指针将大小相近的chunk连成一个双向链表。在large bin中的空闲chunk，还有两个指针，fd_nextsize和bk_nextsize，用于加快在large bin中查找最近匹配的空闲chunk。不同的chunk链表又是通过bins或者fastbins来组织的。</li>
</ul>
<h3 id="malloc步骤"><a href="#malloc步骤" class="headerlink" title="malloc步骤"></a>malloc步骤</h3><p>malloc 内存分配流程</p>
<ol>
<li>如果分配内存&lt;512字节，则通过内存大小定位到smallbins对应的index上(floor(size&#x2F;8)).<ul>
<li>如果smallbins[index]为空，进入步骤3.</li>
<li>如果smallbins[index]非空，直接返回第一个chunk.</li>
</ul>
</li>
<li>如果分配内存&gt;512字节，则定位到largebins对应的index上.<ul>
<li>如果largebins[index]为空，进入步骤3.</li>
<li>如果largebins[index]非空，扫描链表，找到第一个大小最合适的chunk，如size&#x3D;12.5K，则使用chunk B，剩下的0.5k放入unsorted_list中</li>
</ul>
</li>
<li>遍历unsorted_list，查找合适size的chunk，如果找到则返回；否则，将这些chunk都归类放到smallbins和largebins里面.</li>
<li>index++从更大的链表中查找，直到找到合适大小的chunk为止，找到后将chunk拆分，并将剩余的加入到unsorted_list中.</li>
<li>如果还没有找到，那么使用top chunk.</li>
<li>内存&lt;128k，使用brk；内存&gt;128k，使用mmap获取新内存.</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。</li>
<li>虚拟内存并不是每次malloc后都增长，是与上一节说的堆顶没发生变化有关，因为可重用堆顶内剩余的空间，这样的malloc是很轻量快速的。</li>
<li>如果虚拟内存发生变化，基本与分配内存量相当，因为虚拟内存是计算虚拟地址空间总大小。</li>
<li>物理内存的增量很少，是因为malloc分配的内存并不就马上分配实际存储空间，只有第一次使用，如第一次memset后才会分配。</li>
<li>由于每个物理内存页面大小是4k，不管memset其中的1k还是5k、7k，实际占用物理内存总是4k的倍数。所以物理内存的增量总是4k的倍数。</li>
</ul>
<p><font color=red>因此，不是malloc后就马上占用实际内存，而是第一次使用时发现虚存对应的物理页面未分配，产生缺页中断，才真正分配物理页面，同时更新进程页面的映射关系。这也是Linux虚拟内存管理的核心概念之一。</font></p>
<h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><p>free释放内存时，有两种情况：</p>
<ol>
<li>chunk和top chunk相邻，则和top chunk合并</li>
<li>chunk和top chunk不相邻，则直接插入到unsorted_list中<br><img src="/images/malloc-5.png"></li>
</ol>
<p>如上图示: top chunk是堆顶的chunk，堆顶指针brk位于top chunk的顶部。移动brk指针，即可扩充top chunk的大小。<font color=red>当top chunk大小超过128k(可配置)时，会触发malloc_trim操作，调用sbrk(-size)将内存归还操作系统。</font></p>
<p>以上图chunk分布图为例，按照glibc的内存分配策略，我们考虑下如下场景(假设brk其实地址是512k)：</p>
<p>malloc 40k内存，即chunkA，brk &#x3D; 512k + 40k &#x3D; 552k malloc 50k内存，即chunkB，brk &#x3D; 552k + 50k &#x3D; 602k malloc 60k内存，即chunkC，brk &#x3D; 602k + 60k &#x3D; 662k free chunkA。</p>
<p>此时，由于brk &#x3D; 662k，而释放的内存是位于[512k, 552k]之间，无法通过移动brk指针，将区域内内存交还操作系统，因此，在[512k, 552k]的区域内便形成了一个内存空洞即内存碎片。 按照glibc的策略，free后的chunkA区域由于不和top chunk相邻，因此，无法和top chunk 合并，应该挂在unsorted_list链表上。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>后分配的内存先释放,因为 ptmalloc 收缩内存是从 top chunk 开始,如果与 top chunk 相邻的 chunk 不能释放, top chunk 以下的 chunk 都无法释放。</li>
<li>多线程锁开销大， 需要避免多线程频繁分配释放。</li>
<li>内存从thread的areana中分配， 内存不能从一个arena移动到另一个arena， 就是说如果多线程使用内存不均衡，容易导致内存的浪费。 比如说线程1使用了300M内存，完成任务后glibc没有释放给操作系统，线程2开始创建了一个新的arena， 但是线程1的300M却不能用了。</li>
<li>每个chunk至少8字节的开销很大</li>
<li>不定期分配长生命周期的内存容易造成内存碎片，不利于回收。 64位系统最好分配32M以上内存，这是使用mmap的阈值。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Ased%E5%92%8Cawk%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Ased%E5%92%8Cawk%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux内核系列：awk、sed命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-29T00:00:00+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:59:49" itemprop="dateModified" datetime="2022-09-25T01:59:49+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><ol>
<li>命令行格式 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [-F  field-separator]  &#x27;commands&#x27;  input-file(s)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>默认以空格或tab分割域，-F后可以跟一个自定义域分隔符。</li>
<li>commands表示awk命令，如print。</li>
<li>input-file表示输入的文件。</li>
</ul>
<ol start="2">
<li>shell脚本方式</li>
</ol>
<p>可以将所有awk命令插入一个文件，设置执行权限，然后将awk作为命令解释器（#!&#x2F;bin&#x2F;awk）执行。</p>
<ol start="3">
<li>将所有的awk命令插入一个单独文件，然后调用：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -f awk-script-file input-file(s)</span><br></pre></td></tr></table></figure>
其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。</li>
</ol>
<p>详细可以参考<a target="_blank" rel="noopener" href="https://zhang.ge/1939.html">这篇文章</a> 和<a target="_blank" rel="noopener" href="https://www.gnu.org/software/gawk/manual/gawk.html">官方文档</a></p>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><ol>
<li>运行原理</li>
</ol>
<ul>
<li>当用sed命令对文本进行处理的时候，sed先读取对象的文本文件的第一行到模式空间中。</li>
<li>当有内容进入“模式空间”时，sed的编辑命令对模式空间中的内容进行编辑操作（修改，替换，删除，追加，显示等等）</li>
<li>模式空间中的内容编辑处理完成之后，sed把此内容通过标准输出（默认为显示器）打印出来，并删除模式空间中的内容。</li>
<li>第一行处理结束。从新读取第二行的内容进行处理，直到最后一行。</li>
</ul>
<ol start="2">
<li>使用</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/9104.html">参考这篇文章应该就够了</a></p>
<h3 id="两者区别和联系"><a href="#两者区别和联系" class="headerlink" title="两者区别和联系"></a>两者区别和联系</h3><ul>
<li><p>sed的核心是正则，主要处理“行问题”。</p>
</li>
<li><p>awk的核心是格式化，主要处理“列问题”。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Aptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Aptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Linux内核系列：ptmalloc源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-29T00:00:00+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:59:44" itemprop="dateModified" datetime="2022-09-25T01:59:44+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><ol>
<li>Main_arena</li>
</ol>
<p>在最开始实现的版本中只有一个main arena，每次分配内存都必须对主分配区加锁，分配完成后释放锁。 在多线程环境下由于锁的竞争效率低。<br>新版本增加了非主分配区。根据系统对分配区的争用情况非主分配区会增加，但不减少。</p>
<ul>
<li>主分配区访问heap和mmap区域（主分配区可以使用sbrk和mmap想操作系统申请虚拟内存），非主分配区只能访问mmap区域。</li>
<li>主分配区每次mmap向操作系统刚申请HEAP_MAX_SIZE（32位1MB,64位64MB）大小的虚拟内存。</li>
<li>当某一线程需要调用malloc()分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜索循环链表试图获得一个没有加锁的分配区。如果所有的分配区都已经加锁，那么malloc()会开辟一个新的分配区，把该分配区加入到全局分配区循环链表并加锁，然后使用该分配区进行分配内存操作。</li>
</ul>
<ol start="2">
<li>chunk<br>ptmalloc 在给用户分配的空间的前后加上了一些控制信息，用这样的方法来记录分配的信息，以便完成分配和释放工作。一个使用中的chunk（使用中，就是指还没有被free掉）在内存中的样子如图所示：<br><img src="/images/ptmalloc-1.png"></li>
</ol>
<ul>
<li>mem：返回给用户的内存指针</li>
<li>chunk控制位：P，它表示前一个块是否在使用中，M，他表示当前chunk是从哪个内存区域获得的虚拟内存（mmao&#x2F;brk）A，表示该chunk属于主分配区或者非主分配区。<br>下面展示了一个空闲chunk在内存中的状态<br><img src="/images/ptmalloc-2.png"></li>
</ul>
<ol start="3">
<li>bins</li>
</ol>
<p>ptmalloc将相似大小的chunk用双向链表链接起来，这样的一个链表被称为一个bin.ptmalloc一共维护了128个bin,并使用一个数组来存储这些bin.<br><img src="/images/ptmalloc-3.png"></p>
<ul>
<li><p>unsorted bins:bins数组的第一个</p>
</li>
<li><p>small bins:2<del>64的bin（chunk大小范围为16</del>512）</p>
</li>
<li><p>large bins:large bins中的每一个bin分别包含了一个给定范围内的chunk，其中的chunk按大小序排列。相同大小的chunk同样按照最近使用顺序排列。</p>
</li>
<li><p>fast bins:主要用来处理申请释放一些小的内存空间。后入先出。</p>
</li>
</ul>
<p>ptmalloc中在分配过程中引入了fast bins，不大于max_fast （默认值为64B）的chunk被释放后，首先会被放到fast bins 中，<font color = orange>fast bins中的chunk并不改变它的使用标志P。</font>这样也就无法将它们合并。当需要给用户分配的chunk小于或等于max_fast时，ptmalloc首先会在fast bins中查找相应的空闲块，然后才会去查找bins中的空闲chunk.</p>
<ul>
<li>Unsorted bin:bins的缓冲区</li>
</ul>
<p>如果被用户释放的chunk大于max_fast，或者fast bins中的空闲chunk合并后，这些chunk首先会被放到unsorted bin队列中,，在进行malloc操作的时候，如果在fast bins中没有找到合适的chunk，则ptmalloc会先在unsorted bin中查找合适的空闲chunk，然后才查找bins。</p>
<ol start="4">
<li>三种特殊的chunk</li>
</ol>
<ul>
<li>top chunk:fast bin和bin失效后的补救措施</li>
</ul>
<p><font color = orange>非主分配区</font>预先从mmap区域分配交大的空间内存模拟sub-heap。<br>Q1：什么时候分配？<br>A：第一次使用malloc时，主分配区在堆顶分配，子分配区mmap后在分配。</p>
<ul>
<li>mmaped chunk:top chunk不能分配的补救措施</li>
</ul>
<p>如果top chunk都不能分配，直接mmap一段内存到共享映射区。</p>
<ul>
<li>last reminder<br>当需要分配一个small chunk,但在small bins中找不到合适的chunk，如果last remainder chunk的大小大于所需要的small chunk大小，last remainder chunk被分裂成两个chunk，其中一个chunk返回给用户，另一个chunk变成新的last remainder chunk。<br><font color = orange>last remainder chunk主要通过提高内存分配的局部性来提高连续malloc（产生大量 small chunk）的效率。</font></li>
</ul>
<h3 id="brk和mmap注意事项"><a href="#brk和mmap注意事项" class="headerlink" title="brk和mmap注意事项"></a>brk和mmap注意事项</h3><ol>
<li>在使malloc之前，brk的值等于start_brk，也就是说heap大小为0.</li>
<li>ptmalloc在开始时，若请求的空间小于 mmap分配阈值（mmap threshold，默认值为128KB）时，主分配区会调用sbrk()增加一块大小为 (128 KB + chunk_size) align 4KB的空间作为heap。非主分配区会调用mmap映射一块大小为HEAP_MAX_SIZE（32位系统上默认为1MB，64位系统上默认为64MB）的空间作为sub-heap.</li>
<li>当用户请求内存分配时，首先会在这个区域内找一块合适的chunk给用户。当用户释放了heap 中的chunk时，ptmalloc又会使用fast bins和bins来组织空闲chunk。以备用户的下一次分配。</li>
<li>若需要分配的chunk大小小于mmap分配阈值，而heap空间又不够，则此时主分配区会通过sbrk()调用来增加heap大小，非主分配区会调用mmap映射一块新的sub-heap，也就是增加top chunk的大小，每次heap增加的值都会对齐到4KB。</li>
<li>当用户的请求超过mmap分配阈值，并且主分配区使用sbrk()分配失败的时候，或是非主分配区在top chunk中不能分配到需要的内存时，ptmalloc会尝试使用mmap()直接映射一块内存到进程内存空间。使用mmap()直接映射的chunk在释放时直接解除映射，而不再属于进程的内存空间.</li>
</ol>
<h3 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h3><ul>
<li>小于等于64字节：用pool算法分配。</li>
<li>64到512字节之间：在最佳匹配算法分配和pool算法分配中取一种合适的。</li>
<li>大于等于512字节：用最佳匹配算法分配。</li>
<li>大于等于mmap分配阈值（默认值128KB）：根据设置的mmap的分配策略进行分配，如果没有开启mmap分配阈值的动态调整机制，大于等于128KB就直接调用mmap()分配。否则，大于等于mmap分配阈值时才直接调用mmap()分配。</li>
</ul>
<h3 id="分配具体流程"><a href="#分配具体流程" class="headerlink" title="分配具体流程"></a>分配具体流程</h3><ol>
<li>获取分配区的锁，为了防止多个线程同时访问同一个分配区，在进行分配之前需要取得分配区域的锁。线程先查看线程私有实例中是否已经存在一个分配区，如果存在尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，否则，该线程搜索分配区循环链表试图获得一个空闲（没有加锁）的分配区。如果所有的分配区都已经加锁，那么ptmalloc会开辟一个新的分配区，把该分配区加入到全局分配区循环链表和线程的私有实例中并加锁，然后使用该分配区进行分配操作。开辟出来的新分配区一定为非主分配区，因为主分配区是从父进程那里继承来的。开辟非主分配区时会调用mmap()创建一个sub-heap，并设置好top chunk。</li>
<li>将用户的请求大小转换为实际需要分配的chunk空间大小。</li>
<li>判断所需分配chunk的大小是否满足chunk_size &lt;&#x3D; max_fast (max_fast 默认为 64B)，如果是的话，则转下一步，否则跳到第5步。</li>
<li>首先尝试在fast bins中取一个所需大小的chunk分配给用户。如果可以找到，则分配结束。否则转到下一步。</li>
<li>判断所需大小是否处在small bins中，即判断chunk_size &lt; 512B是否成立。如果chunk大小处在small bins中，则转下一步，否则转到第6步。</li>
<li>根据所需分配的chunk的大小，找到具体所在的某个small bin，从该bin的尾部摘取一个恰好满足大小的chunk。若成功，则分配结束，否则，转到下一步。</li>
<li>到了这一步，说明需要分配的是一块大的内存，或者small bins中找不到合适的 chunk。于是，ptmalloc首先会遍历fast bins中的chunk，将相邻的chunk进行合并，并链接到unsorted bin中，然后遍历unsorted bin中的chunk，如果unsorted bin只有一个chunk，并且这个chunk在上次分配时被使用过，并且所需分配的chunk大小属于small bins，并且chunk的大小大于等于需要分配的大小，这种情况下就直接将该chunk进行切割，分配结束，否则将根据chunk的空间大小将其放入small bins或是large bins中，遍历完成后，转入下一步。</li>
<li>到了这一步，说明需要分配的是一块大的内存，或者small bins和unsorted bin中都找不到合适的 chunk，并且fast bins和unsorted bin中所有的chunk都清除干净了。从large bins中按照“smallest-first，best-fit”原则，找一个合适的 chunk，从中划分一块所需大小的chunk，并将剩下的部分链接回到bins中。若操作成功，则分配结束，否则转到下一步。</li>
<li>如果搜索fast bins和bins都没有找到合适的chunk，那么就需要操作top chunk来进行分配了。判断top chunk大小是否满足所需chunk的大小，如果是，则从top chunk中分出一块来。否则转到下一步。</li>
<li>到了这一步，说明top chunk也不能满足分配要求，所以，于是就有了两个选择: 如果是主分配区，调用sbrk()，增加top chunk大小；如果是非主分配区，调用mmap来分配一个新的sub-heap，增加top chunk大小；或者使用mmap()来直接分配。在这里，需要依靠chunk的大小来决定到底使用哪种方法。判断所需分配的chunk大小是否大于等于 mmap分配阈值，如果是的话，则转下一步，调用mmap分配，否则跳到第12步，增加top chunk 的大小。</li>
<li>使用mmap系统调用为程序的内存空间映射一块chunk_size align 4kB大小的空间。 然后将内存指针返回给用户。</li>
<li>判断是否为第一次调用malloc，若是主分配区，则需要进行一次初始化工作，分配一块大小为(chunk_size + 128KB) align 4KB大小的空间作为初始的heap。若已经初始化过了，主分配区则调用sbrk()增加heap空间，分主分配区则在top chunk中切割出一个chunk，使之满足分配需求，并将内存指针返回给用户。</li>
</ol>
<p>参考文献：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/namelij/article/details/121175864">csdn ptmalloc</a><br>《glic内存管理ptmalloc源码分析》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Ashell%E5%91%BD%E4%BB%A4%E5%92%8C%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Ashell%E5%91%BD%E4%BB%A4%E5%92%8C%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Linux内核系列：shell命令和脚本执行原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-29T00:00:00+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:59:53" itemprop="dateModified" datetime="2022-09-25T01:59:53+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a>shell命令</h3><p>shell不属于内核，而是以内核之外的用户态方式运行。因此它就相当于操作系统的一层外壳，为用户提供使用操作系统的接口。<br>shell命令分为内置命令和外部命令，如下图，cd是外部命令，cat等都是外部命令。</p>
<p><img src="/images/shell-1.png"><br>当我们在命令行输入一个命令之后，会发生什么？</p>
<ul>
<li>检查用户输入的命令是否是一个内部命令，如果不是检查是不是一个应用程序；</li>
<li>shell在搜索路径或者环境变量中找应用程序；</li>
<li>如果不是一个外部命令并且没有查找到可执行文件，显示错误信息；- 如果成功找到，内部命令或者应用程序会被分解为系统调用传给内核，内核完成工作。</li>
</ul>
<p><font color = green>像cd，pwd这些内置命令是属于Shell的一部分，当Shell一运行起来就随Shell加载入内存，因此，当我们在命令行上输入这些命令就可以像调用函数一样直接使用，效率非常高。而如ls，cat这些外部命令却不是如此，当我们在命令行输入cat，当前的Shell会fork一个子进程，然后调用exec载入这个命令的可执行文件，比如bin&#x2F;cat，(<font color = orange>注意execve系统调用：它会把新程序加载到当前进程的内存空间内，当前的进程会被丢弃，它的堆、栈和所有的段数据都会被新进程相应的部分代替，然后会从新程序的初始化代码和 main 函数开始运行。同时，进程的 ID 将保持不变。</font>)因此效率上稍微低了点,最后shell用wait命令等待新进程结束</font></p>
<h3 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h3><p>shell脚本原理和shell命令相同，对于外部都是使用子进程执行。<br>这里突发奇想shell脚本能多线程吗？查了资料是可以的：</p>
<ul>
<li>使用&amp;后台运行<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line"></span><br><span class="line">all_num=10</span><br><span class="line"></span><br><span class="line">a=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> `<span class="built_in">seq</span> 1 <span class="variable">$&#123;all_num&#125;</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">sleep</span> 1</span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$&#123;num&#125;</span></span><br><span class="line">&#125; &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">b=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;startTime:\t<span class="variable">$a</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;endTime:\t<span class="variable">$b</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>控制同步：</p>
<ul>
<li>使用&amp;后台运行，使用wait同步<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line"></span><br><span class="line">all_num=10</span><br><span class="line"></span><br><span class="line">a=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> `<span class="built_in">seq</span> 1 <span class="variable">$&#123;all_num&#125;</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">sleep</span> 1</span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$&#123;num&#125;</span></span><br><span class="line">&#125; &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line"></span><br><span class="line">b=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;startTime:\t<span class="variable">$a</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;endTime:\t<span class="variable">$b</span>&quot;</span></span><br></pre></td></tr></table></figure>
控制并发数：</li>
<li>使用xargs -P</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line"></span><br><span class="line">all_num=10</span><br><span class="line">thread_num=5</span><br><span class="line"></span><br><span class="line">a=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="built_in">seq</span> 1 <span class="variable">$&#123;all_num&#125;</span> | xargs -n 1 -I &#123;&#125; -P <span class="variable">$&#123;thread_num&#125;</span> sh -c <span class="string">&quot;sleep 1;echo &#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">b=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;startTime:\t<span class="variable">$a</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;endTime:\t<span class="variable">$b</span>&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用GNU parallel</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line"></span><br><span class="line">all_num=10</span><br><span class="line">thread_num=6</span><br><span class="line"></span><br><span class="line">a=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parallel -j 5 <span class="string">&quot;sleep 1;echo &#123;&#125;&quot;</span> ::: `<span class="built_in">seq</span> 1 10`</span><br><span class="line"></span><br><span class="line">b=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;startTime:\t<span class="variable">$a</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;endTime:\t<span class="variable">$b</span>&quot;</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%A4%A7%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%A4%A7%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Linux内核系列：内存管理大总结-ptmalloc/tcmalloc/jemalloc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-29T00:00:00+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:59:13" itemprop="dateModified" datetime="2022-09-25T01:59:13+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="ptmalloc"><a href="#ptmalloc" class="headerlink" title="ptmalloc"></a>ptmalloc</h3><p>GNU Libc 的内存分配器(allocator)—ptmalloc，起源于Doug Lea的malloc。由Wolfram Gloger改进得到可以支持多线程。</p>
<p>在Doug Lea实现的内存分配器中只有一个主分配区（main arena），每次分配内存都必须对主分配区加锁，分配完成后释放锁，在SMP多线程环境下，对主分配区的锁的争用很激烈，严重影响了malloc的分配效率。ptmalloc增加了动态分配区（dynamic arena），主分配区与动态分配区用环形链表进行管理。每一个分配区利用互斥锁（mutex）使线程对于该分配区的访问互斥。每个进程只有一个主分配区，但可能存在多个动态分配区，ptmalloc根据系统对分配区的争用情况动态增加动态分配区的数量，分配区的数量一旦增加，就不会再减少了。主分配区在二进制启动时调用sbrk从heap区域分配内存，Heap是由用户内存块组成的连续的内存域。而动态分配区每次使用mmap()向操作系统“批发”HEAP_MAX_SIZE大小的虚拟内存，如果内存耗尽，则会申请新的内存链到动态分配区heap data的“strcut malloc_state”。如果用户请求的大小超过HEAP_MAX_SIZE，动态分配区则会直接调用mmap()分配内存，并且当free的时候调用munmap()，该类型的内存块不会链接到任何heap data。用户向请求分配内存时，内存分配器将缓存的内存切割成小块“零售”出去。从用户空间分配内存，减少系统调用，是提高内存分配速度的好方法，毕竟前者要高效的多。</p>
<p>系统向看ptmalloc内存管理<br>在「glibc malloc」中主要有 3 种数据结构：</p>
<ul>
<li><p>malloc_state(Arena header)：一个 thread arena 可以维护多个堆，这些堆共享同一个arena header。Arena header 描述的信息包括：bins、top chunk、last remainder chunk 等；</p>
</li>
<li><p>heap_info(Heap Header)：每个堆都有自己的堆 Header（注：也即头部元数据）。当这个堆的空间耗尽时，新的堆（而非连续内存区域）就会被 mmap 当前堆的 aerna 里；</p>
</li>
<li><p>malloc_chunk(Chunk header)：根据用户请求，每个堆被分为若干 chunk。每个 chunk 都有自己的 chunk header。内存管理使用malloc_chunk，把heap当作link list从一个内存块游走到下一个块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">	<span class="type">mutex_t</span> mutex;</span><br><span class="line">	<span class="type">int</span> flags;</span><br><span class="line">	mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">	<span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">	mchunkptr top;</span><br><span class="line">	<span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">	mchunkptr last_remainder;</span><br><span class="line">	<span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">	mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="comment">/* Memory allocated from the system in this arena. */</span></span><br><span class="line">	INTERNAL_SIZE_T system_mem;</span><br><span class="line">	INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> &#123;</span></span><br><span class="line">	mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">	<span class="type">size_t</span> size; <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">	<span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">	PROT_READ|PROT_WRITE. */</span></span><br><span class="line">	<span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">	that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">	MALLOC_ALIGNMENT. */</span></span><br><span class="line">	<span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">	INTERNAL_SIZE_T prev_size; <span class="comment">/* Size of previous chunk (if free). */</span></span><br><span class="line">	INTERNAL_SIZE_T size; <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">	<span class="comment">/* Only used for large blocks: pointer to next larger size. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/memsum-1.png"></p>
</li>
<li><p>线程中内存管理<br>对于空闲的chunk，ptmalloc采用分箱式内存管理方式，每一个内存分配区中维护着[bins]的列表数据结构，用于保存free chunks。根据空闲chunk的大小和处于的状态将其放在四个不同的bin中，这四个空闲chunk的容器包括fast bins，unsorted bin， small bins和large bins。</p>
</li>
</ul>
<ol>
<li>Fast bins 可以看着是small bins的一小部分cache，主要是用于提高小内存的分配效率，虽然这可能会加剧内存碎片化，但也大大加速了内存释放的速度！</li>
<li>Unsorted bin 可以重新使用最近 free 掉的 chunk，从而消除了寻找合适 bin 的时间开销，进而加速了内存分配及释放的效率。</li>
<li>Small bins 相邻的 free chunk 将被合并，这减缓了内存碎片化，但是减慢了 free 的速度；</li>
<li>Large bin 中所有 chunk 大小不一定相同，各 chunk 大小递减保存。最大的 chunk 保存顶端，而最小的 chunk 保存在尾端；查找较慢，且释放时两个相邻的空闲 chunk 会被合并。</li>
</ol>
<p>一个 arena 中最顶部的 chunk 被称为「top chunk」。它不属于任何 bin 。当所有 bin 中都没有合适空闲内存时，就会使用 top chunk 来响应用户请求。当 top chunk 的大小比用户请求的大小小的时候，top chunk 就通过 sbrk（main arena）或 mmap（ thread arena）系统调用扩容。</p>
<p>「last remainder chunk」即最后一次 small request 中因分割而得到的剩余部分，它有利于改进引用局部性，也即后续对 small chunk 的 malloc 请求可能最终被分配得彼此靠近。当用户请求 small chunk 而无法从 small bin 和 unsorted bin 得到服务时，分配器就会通过扫描 binmaps 找到最小非空 bin。正如前文所提及的，如果这样的 bin 找到了，其中最合适的 chunk 就会分割为两部分：返回给用户的 User chunk 、添加到 unsorted bin 中的 Remainder chunk。这一 Remainder chunk 就将成为 last remainder chunk。当用户的后续请求 small chunk，并且 last remainder chunk 是 unsorted bin 中唯一的 chunk，该 last remainder chunk 就将分割成两部分：返回给用户的 User chunk、添加到 unsorted bin 中的 Remainder chunk（也是 last remainder chunk）。因此后续的请求的 chunk 最终将被分配得彼此靠近。</p>
<p><font color=orange>存在的问题：  </p>
<ul>
<li>如果后分配的内存先释放，无法及时归还系统。因为 ptmalloc 收缩内存是从 top chunk 开始,如果与 top chunk 相邻的 chunk 不能释放, top chunk 以下的 chunk 都无法释放。</li>
<li>内存不能在线程间移动，多线程使用内存不均衡将导致内存浪费</li>
<li>每个chunk至少8字节的开销很大</li>
<li>不定期分配长生命周期的内存容易造成内存碎片，不利于回收。</li>
<li>加锁耗时，无论当前分区有无耗时，在内存分配和释放时，会首先加锁。</font></li>
</ul>
<h3 id="tcmalloc"><a href="#tcmalloc" class="headerlink" title="tcmalloc"></a>tcmalloc</h3><p>tcmalloc是Google开发的内存分配器，在Golang、Chrome中都有使用该分配器进行内存分配。有效的优化了ptmalloc中存在的问题。当然为此也付出了一些代价，按下不表，先看tcmalloc的具体实现。</p>
<p>系统向看tcmalloc内存管理<br>tcmalloc把8kb的连续内存称为一个页(Page)，可以用下面两个常量来描述：<br>const size_t kPageShift &#x3D; 13;<br>const size_t kPageSize &#x3D; 1 &lt;&lt; kPageShift;<br>对于一个指针p，p&gt;&gt;kPageShift即是p的页地址。同样的对于一个页地址x，管理的实际内存区间是[x &lt;&lt;kPageShift, (x+1)&lt;&lt;kPageShift)。一个或多个连续的页组成一个Span.对于一个Span，管理的实际内存区间是[start&lt;&lt;kPageShift, (start+length)&lt;&lt;kPageShift)。tcmalloc中所有页级别的操作，都是对Span的操作。PageHeap是一个全局的用来管理Span的类。PageHeap把小于的空闲Span保存在双向循环链表上，而大的span则保存在SET中。保证了所有的内存的申请速度，减少了内存查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Information kept for a span (a contiguous run of pages).</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Span</span> &#123;</span></span><br><span class="line">  PageID        start;          <span class="comment">// Starting page number</span></span><br><span class="line">  Length        length;         <span class="comment">// Number of pages in span</span></span><br><span class="line">  Span*         next;           <span class="comment">// Used when in link list</span></span><br><span class="line">  Span*         prev;           <span class="comment">// Used when in link list</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>* objects;              <span class="comment">// Linked list of free objects</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Span may contain iterator pointing back at SpanSet entry of</span></span><br><span class="line">    <span class="comment">// this span into set of large spans. It is used to quickly delete</span></span><br><span class="line">    <span class="comment">// spans from those sets. span_iter_space is space for such</span></span><br><span class="line">    <span class="comment">// iterator which lifetime is controlled explicitly.</span></span><br><span class="line">    <span class="type">char</span> span_iter_space[<span class="keyword">sizeof</span>(SpanSet::iterator)];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  refcount : <span class="number">16</span>;  <span class="comment">// Number of non-free objects</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  sizeclass : <span class="number">8</span>;  <span class="comment">// Size-class for small objects (or 0)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  location : <span class="number">2</span>;   <span class="comment">// Is the span on a freelist, and if so, which?</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  sample : <span class="number">1</span>;     <span class="comment">// Sampled object?</span></span><br><span class="line">  <span class="type">bool</span>          has_span_iter : <span class="number">1</span>; <span class="comment">// If span_iter_space has valid</span></span><br><span class="line">                                   <span class="comment">// iterator. Only for debug builds.</span></span><br><span class="line">  <span class="comment">// What freelist the span is on: IN_USE if on none, or normal or returned</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We segregate spans of a given size into two circular linked</span></span><br><span class="line"><span class="comment">// lists: one for normal spans, and one for spans whose memory</span></span><br><span class="line"><span class="comment">// has been returned to the system.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SpanList</span> &#123;</span></span><br><span class="line">Span        normal;</span><br><span class="line">Span        returned;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array mapping from span length to a doubly linked list of free spans</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> index &#x27;i&#x27; stores spans of length &#x27;i + 1&#x27;.</span></span><br><span class="line">SpanList free_[kMaxPages];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets of spans with length &gt; kMaxPages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Rather than using a linked list, we use sets here for efficient</span></span><br><span class="line"><span class="comment">// best-fit search.</span></span><br><span class="line">SpanSet large_normal_;</span><br><span class="line">SpanSet large_returned_;</span><br></pre></td></tr></table></figure>
<p><img src="/images/memsum-2.png"></p>
<p><font color=orange>优点：</p>
<ul>
<li>小内存可以在ThreadCache中不加锁分配(加锁的代价大约100ns)</li>
<li>大内存可以直接按照大小分配不需要再像ptmalloc一样进行查找(ptmalloc需要在large bins链表中查找空闲chunk)</li>
<li>大内存加锁使用更高效的自旋锁</li>
<li>减少了内存碎片</li>
</ul>
<p>缺点：<br>使用自旋锁虽然减少了加锁效率，但是如果使用大内存较多的情况下，内存在Central Cache或者Page Heap加锁分配。而tcmalloc对大小内存的分配过于保守，在一些内存需求较大的服务（如推荐系统），小内存上限过低，当请求量上来，锁冲突严重，CPU使用率将指数暴增。<br></font></p>
<h3 id="jemalloc"><a href="#jemalloc" class="headerlink" title="jemalloc"></a>jemalloc</h3><p>jemalloc是facebook推出的，目前在firefox、facebook服务器、android 5.0 等服务中大量使用。 jemalloc最大的优势还是其强大的多核&#x2F;多线程分配能力. 以现代计算机硬件架构来说, 最大的瓶颈已经不再是内存容量或cpu速度, 而是多核&#x2F;多线程下的lock contention(锁竞争). 因为无论CPU核心数量如何多, 通常情况下内存只有一份. 可以说, 如果内存足够大, CPU的核心数量越多, 程序线程数越多, jemalloc的分配速度越快。</p>
<p>对于一个多线程+多CPU核心的运行环境, 传统分配器中大量开销被浪费在lock contention和false sharing上, 随着线程数量和核心数量增多, 这种分配压力将越来越大.针对多线程, 一种解决方法是将一把global lock分散成很多与线程相关的lock. 而针对多核心, 则要尽量把不同线程下分配的内存隔离开, 避免不同线程使用同一个cache-line的情况.按照上面的思路, 一个较好的实现方式就是引入arena.将内存划分成若干数量的arenas, 线程最终会与某一个arena绑定.由于两个arena在地址空间上几乎不存在任何联系, 就可以在无锁的状态下完成分配. 同样由于空间不连续, 落到同一个cache-line中的几率也很小, 保证了各自独立。由于arena的数量有限, 因此不能保证所有线程都能独占arena, 分享同一个arena的所有线程, 由该arena内部的lock保持同步.</p>
<p>chunk是仅次于arena的次级内存结构，arena都有专属的chunks, 每个chunk的头部都记录了chunk的分配信息。chunk是具体进行内存分配的区域，目前的默认大小是4M。chunk以page（默认为4K)为单位进行管理，每个chunk的前几个page（默认是6个）用于存储chunk的元数据，后面跟着一个或多个page的runs。后面的runs可以是未分配区域， 多个小对象组合在一起组成run, 其元数据放在run的头部。 大对象构成的run, 其元数据放在chunk的头部。在使用某一个chunk的时候，会把它分割成很多个run，并记录到bin中。不同size的class对应着不同的bin，在bin里，都会有一个红黑树来维护空闲的run，并且在run里，使用了bitmap来记录了分配状态。此外，每个arena里面维护一组按地址排列的可获得的run的红黑树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_s</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 当前arena管理的dirty chunks */</span></span><br><span class="line">    <span class="type">arena_chunk_tree_t</span>  chunks_dirty;</span><br><span class="line">    <span class="comment">/* arena缓存的最近释放的chunk, 每个arena一个spare chunk */</span></span><br><span class="line">    <span class="type">arena_chunk_t</span>       *spare;</span><br><span class="line">    <span class="comment">/* 当前arena中正在使用的page数. */</span></span><br><span class="line">    <span class="type">size_t</span>          nactive;</span><br><span class="line">    <span class="comment">/*当前arana中未使用的dirty page数*/</span></span><br><span class="line">    <span class="type">size_t</span>          ndirty;</span><br><span class="line">    <span class="comment">/* 需要清理的page的大概数目 */</span></span><br><span class="line">    <span class="type">size_t</span>          npurgatory;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 当前arena可获得的runs构成的红黑树， */</span></span><br><span class="line">    <span class="comment">/* 红黑树按大小/地址顺序进行排列。 分配run时采用first-best-fit策略*/</span></span><br><span class="line">    <span class="type">arena_avail_tree_t</span>  runs_avail;</span><br><span class="line">    <span class="comment">/* bins储存不同大小size的内存区域 */</span></span><br><span class="line">    <span class="type">arena_bin_t</span>     bins[NBINS];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Arena chunk header. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_chunk_s</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 管理当前chunk的Arena */</span></span><br><span class="line">    <span class="type">arena_t</span>         *arena;</span><br><span class="line">    <span class="comment">/* 链接到所属arena的dirty chunks树的节点*/</span></span><br><span class="line">    rb_node(<span class="type">arena_chunk_t</span>)  dirty_link;</span><br><span class="line">    <span class="comment">/* 脏页数 */</span></span><br><span class="line">    <span class="type">size_t</span>          ndirty;</span><br><span class="line">    <span class="comment">/* 空闲run数 Number of available runs. */</span></span><br><span class="line">    <span class="type">size_t</span>          nruns_avail;</span><br><span class="line">    <span class="comment">/* 相邻的run数，清理的时候可以合并的run */</span></span><br><span class="line">    <span class="type">size_t</span>          nruns_adjac;</span><br><span class="line">    <span class="comment">/* 用来跟踪chunk使用状况的关于page的map, 它的下标对应于run在chunk中的位置，通过加map_bias不跟踪chunk 头部的信息</span></span><br><span class="line"><span class="comment">     * 通过加map_bias不跟踪chunk 头部的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">arena_chunk_map_t</span>   <span class="built_in">map</span>[<span class="number">1</span>]; <span class="comment">/* Dynamically sized. */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_run_s</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 所属的bin */</span></span><br><span class="line">    <span class="type">arena_bin_t</span> *bin;</span><br><span class="line">    <span class="comment">/*下一块可分配区域的索引 */</span></span><br><span class="line">    <span class="type">uint32_t</span>    nextind;</span><br><span class="line">    <span class="comment">/* 当前run中空闲块数目. */</span></span><br><span class="line">    <span class="type">unsigned</span>    nfree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/memsum-3.png"></p>
<p>jemalloc 按照内存分配请求的尺寸，分了 small object (例如 1 – 57344B)、 large object (例如 57345 – 4MB )、 huge object (例如 4MB以上)。jemalloc同样有一层线程缓存的内存名字叫tcache，当分配的内存大小小于tcache_maxclass时，jemalloc会首先在tcache的small object以及large object中查找分配，tcache不中则从arena中申请run，并将剩余的区域缓存到tcache。若arena找不到合适大小的内存块， 则向系统申请内存。当申请大小大于tcache_maxclass且大小小于huge大小的内存块时，则直接从arena开始分配。而huge object的内存不归arena管理， 直接采用mmap从system memory中申请，并由一棵与arena独立的红黑树进行管理。</p>
<p><font color=orange>优点：</p>
<ul>
<li>采用多个 arena 来避免线程同步</li>
<li>细粒度的锁，比如每一个 bin 以及每一个 extents 都有自己的锁</li>
<li>Memory Order 的使用，比如 rtree 的读写访问有不同的原子语义（relaxed, acquire, release）</li>
<li>结构体以及内存分配时保证对齐，以获得更好的 cache locality</li>
<li>cache_bin 分配内存时会通过栈变量来判断是否成功以避免 cache miss</li>
<li>dirty extent 的 delay coalesce 来获得更好的 cache locality；extent 的 lazy purge 来保证更平滑的 gc 机制</li>
<li>紧凑的结构体内存布局来减少占用空间，比如 extent.e_bits</li>
<li>rtree 引入 rtree_ctx 的两级 cache 机制，提升 extent 信息获取速度的同时减少 cache miss</li>
<li>tcache gc 时对缓存容量的动态调整</li>
</ul>
<p>缺点：</p>
<ul>
<li>某个线程在这个 arena 使用了很多内存，之后这个 arena 并没有其他线程使用，导致这个 arena 的内存无法被 gc，占用过多</li>
<li>两个位于不同 arena 的线程频繁进行内存申请，导致两个 arena 的内存出现大量交叉，但是连续的内存由于在不同 arena 而无法进行合并.</li>
</ul>
</font>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">Linux内核系列：文件系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-29T00:00:00+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:59:19" itemprop="dateModified" datetime="2022-09-25T01:59:19+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>感觉<a target="_blank" rel="noopener" href="https://blog.csdn.net/yuexiaxiaoxi27172319/article/details/45241923">这篇文章</a>已经讲的十分透彻清晰。另外需要掌握细节的话参考《Linux内核设计与实现（第三版）》第十三章：虚拟文件系统。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">Linux内核系列：软链接硬链接符号链接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-29T00:00:00+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:59:16" itemprop="dateModified" datetime="2022-09-25T01:59:16+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li>软连接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s file slink </span><br></pre></td></tr></table></figure></li>
<li>硬链接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln file hlink</span><br></pre></td></tr></table></figure></li>
</ul>
<p>观察inode编号：<br><img src="/images/hardsoft-1.png"><br><img src="/images/hardsoft-2.png"><br>硬链接和源文件有想用文件索引，软连接有单独文件索引</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li>删除硬链接源文件不影响，删除源文件硬链接存在，并且内容不变。</li>
<li>删除软连接源文件不影响，删除源文件软连接会找不到源文件。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>硬链接：指向文件的指针，增加文件的引用计数。应用场景之一是文件备份。</p>
<ul>
<li>硬链接不会建立自己的 inode 索引和 block（数据块），而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；</li>
</ul>
</li>
<li><p>软连接：相当于快捷方式。<br>  -软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号<br>  软链接可以链接目录文件、可以跨分区链接；硬链接是不可以的</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E9%A1%B5%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E9%A1%B5%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">Linux内核系列：页缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-29T00:00:00+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:59:23" itemprop="dateModified" datetime="2022-09-25T01:59:23+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="什么是页缓存"><a href="#什么是页缓存" class="headerlink" title="什么是页缓存"></a>什么是页缓存</h3><p>我们知道文件一般存放在硬盘（机械硬盘或固态硬盘）中，CPU 并不能直接访问硬盘中的数据，而是需要先将硬盘中的数据读入到内存中，然后才能被 CPU 访问。</p>
<p>由于读写硬盘的速度比读写内存要慢很多（DDR4 内存读写速度是机械硬盘500倍，是固态硬盘的200倍），所以为了避免每次读写文件时，都需要对硬盘进行读写操作，Linux 内核使用 页缓存（Page Cache） 机制来对文件中的数据进行缓存。</p>
<p>为了提升对文件的读写效率，Linux 内核会以页大小（4KB）为单位，将文件划分为多数据块。当用户对文件中的某个数据块进行读写操作时，内核首先会申请一个内存页（称为 页缓存）与文件中的数据块进行绑定。如下图所示：<br><img src="/images/pagecache.png"></p>
<p>如上图所示，当用户对文件进行读写时，实际上是对文件的 页缓存 进行读写。所以对文件进行读写操作时，会分以下两种情况进行处理：</p>
<p>当从文件中读取数据时，如果要读取的数据所在的页缓存已经存在，那么就直接把页缓存的数据拷贝给用户即可。否则，内核首先会申请一个空闲的内存页（页缓存），然后从文件中读取数据到页缓存，并且把页缓存的数据拷贝给用户。<br>当向文件中写入数据时，如果要写入的数据所在的页缓存已经存在，那么直接把新数据写入到页缓存即可。否则，内核首先会申请一个空闲的内存页（页缓存），然后从文件中读取数据到页缓存，并且把新数据写入到页缓存中。对于被修改的页缓存，内核会定时把这些页缓存刷新到文件中。</p>
<h3 id="页缓存实现"><a href="#页缓存实现" class="headerlink" title="页缓存实现"></a>页缓存实现</h3><p>在 Linux 内核中，使用 file 对象来描述一个被打开的文件，其中有个名为 f_mapping 的字段，定义如下；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">f_mapping</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码可以看出，f_mapping 字段的类型为 address_space 结构，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>           *<span class="title">host</span>;</span>      <span class="comment">/* owner: inode, block_device */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">page_tree</span>;</span>  <span class="comment">/* radix tree of all pages */</span></span><br><span class="line">    <span class="type">rwlock_t</span>               tree_lock;  <span class="comment">/* and rwlock protecting it */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>address_space 结构其中的一个作用就是用于存储文件的 页缓存，下面介绍一下各个字段的作用：</p>
<p>host：指向当前 address_space 对象所属的文件 inode 对象（每个文件都使用一个 inode 对象表示）。<br>page_tree：用于存储当前文件的 页缓存。<br>tree_lock：用于防止并发访问 page_tree 导致的资源竞争问题。<br>从 address_space 对象的定义可以看出，文件的 页缓存 使用了 radix树 来存储。</p>
<ul>
<li>radix树：又名基数树，它使用键值（key-value）对的形式来保存数据，并且可以通过键快速查找到其对应的值。内核以文件读写操作中的数据 偏移量 作为键，以数据偏移量所在的 页缓存 作为值，存储在 address_space 结构的 page_tree 字段中。(<font color=orange>其实简单点讲，radix树可以理解为压缩过的trie树，也就是把只有一个子孩子的节点合并到它的父节点中.</font>)<br>下图展示了上述各个结构之间的关系：<br><img src="/images/pagecache-2.png"></li>
</ul>
<p>左上角是一个file结构体，里面的mapping对应一个address_space,映射到一个radix树，radix存储的是文件偏移量对应的页缓存。如上图共有64个分叉，高度为2。Linux(2.6.7) 内核中的分叉为 64(2^6)，树高为 6(32位系统)或者 11(64位系统)，用来快速定位 32 位或者 64 位偏移，radix tree 中的每一个叶子节点指向文件内相应偏移所对应的Cache项。radix树为稀疏树提供了有效的存储，代替固定尺寸数组提供了键值到指针的快速查找。</p>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>现在我们来分析一下读取文件数据的过程，用户可以通过调用 read 系统调用来读取文件中的数据，其调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read()</span><br><span class="line">└→ sys_read()</span><br><span class="line">   └→ vfs_read()</span><br><span class="line">      └→ do_sync_read()</span><br><span class="line">         └→ generic_file_aio_read()</span><br><span class="line">            └→ do_generic_file_read()</span><br><span class="line">               └→ do_generic_mapping_read()</span><br></pre></td></tr></table></figure>
<p>从上面的调用链可以看出，read 系统调用最终会调用 do_generic_mapping_read 函数来读取文件中的数据，其实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">do_generic_mapping_read</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> file_ra_state *_ra,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">                        <span class="type">loff_t</span> *ppos,</span></span><br><span class="line"><span class="params">                        <span class="type">read_descriptor_t</span> *desc,</span></span><br><span class="line"><span class="params">                        <span class="type">read_actor_t</span> actor)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">cached_page</span>;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    cached_page = <span class="literal">NULL</span>;</span><br><span class="line">    index = *ppos &gt;&gt; PAGE_CACHE_SHIFT;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">find_page:</span><br><span class="line">        <span class="comment">// 1. 查找文件偏移量所在的页缓存是否存在</span></span><br><span class="line">        page = find_get_page(mapping, index);</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 2. 如果页缓存不存在, 那么跳到 no_cached_page 进行处理</span></span><br><span class="line">            <span class="keyword">goto</span> no_cached_page; </span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">page_ok:</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 3. 如果页缓存存在, 那么把页缓存的数据拷贝到用户应用程序的内存中</span></span><br><span class="line">        ret = actor(desc, page, offset, nr);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (ret == nr &amp;&amp; desc-&gt;count)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">readpage:</span><br><span class="line">        <span class="comment">// 4. 从文件读取数据到页缓存中</span></span><br><span class="line">        error = mapping-&gt;a_ops-&gt;readpage(filp, page);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">goto</span> page_ok;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">no_cached_page:</span><br><span class="line">        <span class="keyword">if</span> (!cached_page) &#123;</span><br><span class="line">            <span class="comment">// 5. 申请一个内存页作为页缓存</span></span><br><span class="line">            cached_page = page_cache_alloc_cold(mapping);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 把新申请的页缓存添加到文件页缓存中</span></span><br><span class="line">        error = add_to_page_cache_lru(cached_page, mapping, index, GFP_KERNEL);</span><br><span class="line">        ...</span><br><span class="line">        page = cached_page;</span><br><span class="line">        cached_page = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> readpage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do_generic_mapping_read 函数的实现比较复杂，经过精简后，上面代码只留下最重要的逻辑，可以归纳为以下几个步骤：</p>
<ul>
<li>通过调用 find_get_page 函数查找要读取的文件偏移量所对应的页缓存是否存在，如果存在就把页缓存中的数据拷贝到应用程序的内存中。</li>
<li>否则调用 page_cache_alloc_cold 函数申请一个空闲的内存页作为新的页缓存，并且通过调用 add_to_page_cache_lru 函数把新申请的页缓存添加到文件页缓存和 LRU 队列中（后面会介绍）。</li>
<li>通过调用 readpage 接口从文件中读取数据到页缓存中，并且把页缓存的数据拷贝到应用程序的内存中。<br>从上面代码可以看出，当页缓存不存在时会申请一块空闲的内存页作为页缓存，并且通过调用 add_to_page_cache_lru 函数把其添加到文件的页缓存和 LRU 队列中。</li>
</ul>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hqin"
      src="/images/001.jpg">
  <p class="site-author-name" itemprop="name">hqin</p>
  <div class="site-description" itemprop="description">星海横流 岁月成碑</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">137</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hqin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

  


</body>
</html>
