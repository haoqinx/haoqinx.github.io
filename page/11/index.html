<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"haoqinx.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="星海横流 岁月成碑">
<meta property="og:type" content="website">
<meta property="og:title" content="面向自由编程">
<meta property="og:url" content="http://haoqinx.github.io/page/11/index.html">
<meta property="og:site_name" content="面向自由编程">
<meta property="og:description" content="星海横流 岁月成碑">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="hqin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://haoqinx.github.io/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>面向自由编程</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="面向自由编程" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">面向自由编程</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/29/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%9Ajemalloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%9Ajemalloc/" class="post-title-link" itemprop="url">c++内存管理系列：jemalloc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-29T00:00:00+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:55:43" itemprop="dateModified" datetime="2022-09-25T01:55:43+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>jemalloc 是由 Jason Evans 在 FreeBSD 项目中引入的新一代内存分配器。它是一个通用的 malloc 实现，侧重于减少内存碎片和提升高并发场景下内存的分配效率，其目标是能够替代 malloc。jemalloc 应用十分广泛，在 Firefox、Redis、Rust、Netty 等出名的产品或者编程语言中都有大量使用。具体细节可以参考 Jason Evans 发表的论文 《A Scalable Concurrent malloc Implementation for FreeBSD》。</p>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>了解了vc6内存管理、ptmalloc、tcmalloc之后，jemalloc理解起来就轻松了不上，因为jemalloc有些地方借鉴了tcmalloc，先pull出整体架构图：<br><img src="/images/jemalloc-1.png"></p>
<p>图中涉及 jemalloc 的几个核心概念，例如 arena、bin、chunk、run、region、tcache 等，我们下面逐一进行介绍。</p>
<ul>
<li><font color=red>arena</font> 是 jemalloc 最重要的部分，内存由一定数量的 arenas 负责管理。每个用户线程都会被绑定到一个 arena 上，线程采用 round-robin 轮询的方式选择可用的 arena 进行内存分配，为了减少线程之间的锁竞争，默认每个 CPU 会分配 4 个 arena。</li>
<li><font color=red>bin</font> 用于管理不同档位的内存单元，每个 bin 管理的内存大小是按分类依次递增。因为 jemalloc 中小内存的分配是基于 Slab 算法完成的，所以会产生不同类别的内存块。</li>
<li><font color=red>chunk</font> 是负责管理用户内存块的数据结构，chunk 以 Page 为单位管理内存，默认大小是 4M，即 1024 个连续 Page。每个 chunk 可被用于多次小内存的申请，但是在大内存分配的场景下只能分配一次。</li>
<li><font color=red>run</font> 实际上是 chunk 中的一块内存区域，每个 bin 管理相同类型的 run，最终通过操作 run 完成内存分配。run 结构具体的大小由不同的 bin 决定，例如 8 字节的 bin 对应的 run 只有一个 Page，可以从中选取 8 字节的块进行分配。</li>
<li><font color=red>region</font> 是每个 run 中的对应的若干个小内存块，每个 run 会将划分为若干个等长的 region，每次内存分配也是按照 region 进行分发。</li>
<li><font color=red>tcache</font> 是每个线程私有的缓存，用于 small 和 large 场景下的内存分配，每个 tcahe 会对应一个 arena，tcache 本身也会有一个 bin 数组，称为tbin。与 arena 中 bin 不同的是，它不会有 run 的概念。tcache 每次从 arena 申请一批内存，在分配内存时首先在 tcache 查找，从而避免锁竞争，如果分配失败才会通过 run 执行内存分配。</li>
</ul>
<p>jemalloc 的几个核心的概念介绍完了，我们再重新梳理下它们之间的关系：</p>
<ul>
<li>内存是由一定数量的 arenas 负责管理，线程均匀分布在 arenas 当中；</li>
<li>每个 arena 都包含一个 bin 数组，每个 bin 管理不同档位的内存块；</li>
<li>每个 arena 被划分为若干个 chunks，每个 chunk 又包含若干个 runs，每个 run 由连续的 Page 组成，run 才是实际分配内存的操作对象；</li>
<li>每个 run 会被划分为一定数量的 regions，在小内存的分配场景，region 相当于用户内存；</li>
<li>每个 tcache 对应 一个 arena，tcache 中包含多种类型的 bin。</li>
</ul>
<p>首先讲下 Samll 场景，如果请求分配内存的大小小于 arena 中的最小的 bin，那么优先从线程中对应的 tcache 中进行分配。首先确定查找对应的 tbin 中是否存在缓存的内存块，如果存在则分配成功，否则找到 tbin 对应的 arena，从 arena 中对应的 bin 中分配 region 保存在 tbin 的 avail 数组中，最终从 availl 数组中选取一个地址进行内存分配，当内存释放时也会将被回收的内存块进行缓存。</p>
<p>Large 场景的内存分配与 Samll 类似，如果请求分配内存的大小大于 arena 中的最小的 bin，但是不大于 tcache 中能够缓存的最大块，依然会通过 tcache 进行分配，但是不同的是此时会分配 chunk 以及所对应的 run，从 chunk 中找到相应的内存空间进行分配。内存释放时也跟 samll 场景类似，会把释放的内存块缓存在 tacache 的 tbin 中。此外还有一种情况，当请求分配内存的大小大于tcache 中能够缓存的最大块，但是不大于 chunk 的大小，那么将不会采用 tcache 机制，直接在 chunk 中进行内存分配。</p>
<p>Huge 场景，如果请求分配内存的大小大于 chunk 的大小，那么直接通过 mmap 进行分配，调用 munmap 进行回收。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/29/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%9Anew&&delete/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%9Anew&&delete/" class="post-title-link" itemprop="url">c++内存管理系列：new/operator new/placement new</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-29T00:00:00+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:55:47" itemprop="dateModified" datetime="2022-09-25T01:55:47+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h3 id="内存分配的层面"><a href="#内存分配的层面" class="headerlink" title="内存分配的层面"></a>内存分配的层面</h3><ul>
<li><p>c++ 内存分配相相关函数如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">分配</th>
<th align="center">释放</th>
<th align="center">类属</th>
<th align="center">可否重载</th>
</tr>
</thead>
<tbody><tr>
<td align="center">malloc()</td>
<td align="center">free()</td>
<td align="center">C函数</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">new</td>
<td align="center">delete</td>
<td align="center">C++表达式</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">::operator new()</td>
<td align="center">::operator delete()</td>
<td align="center">C++函数</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">allocator<T>::allocate()</td>
<td align="center">allocator<T>::deallocate()</td>
<td align="center">C++标准库</td>
<td align="center">可自由设计并搭配任何容器</td>
</tr>
</tbody></table>
</li>
</ul>
<p><img src="/images/008.png"></p>
<center>内存分配层次</center>

<ul>
<li><p>那么我们应该如何使用这几个呢？下面给一段测试程序：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">complex&lt;<span class="type">int</span>&gt;* p2 = <span class="keyword">new</span> complex&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">512</span>);</span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GNU下的allocator</span></span><br><span class="line">allocator&lt;<span class="type">int</span>&gt; alloc;</span><br><span class="line"><span class="type">int</span>* p4 = alloc.<span class="built_in">allocate</span>(<span class="number">512</span>);</span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p4, <span class="number">512</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="operator-new-x2F-operator-delete"><a href="#operator-new-x2F-operator-delete" class="headerlink" title="operator new&#x2F;operator delete"></a>operator new&#x2F;operator delete</h3><ul>
<li>new背后做的事<br>对于下面这行代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">complex* p = <span class="keyword">new</span> <span class="built_in">complex</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>编译器会帮我们转化成下面三个动作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">complex* p;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="type">void</span>* mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(complex)); <span class="comment">//申请内存</span></span><br><span class="line">    p = <span class="built_in">static_cast</span>&lt;complex*&gt;(mem); <span class="comment">// 类型转换</span></span><br><span class="line">    p -&gt; complex::<span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(std::bad_alloc)&#123;</span><br><span class="line">    <span class="comment">//若构造函数失败，回收资源</span></span><br><span class="line">    <span class="comment">//若内存不够，重复获取直到有足够资源或者直接抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而operator new的声明为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span> <span class="params">(std::bad_alloc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>源码是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__cdecl 是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。 被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *__CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> <span class="title">throw</span> <span class="params">(std::bad_alloc)</span> </span>&#123;       </span><br><span class="line">	<span class="comment">// try to allocate size bytes</span></span><br><span class="line">	<span class="type">void</span> *p;</span><br><span class="line">	<span class="keyword">while</span> ((p = <span class="built_in">malloc</span>(size)) == <span class="number">0</span>)      <span class="comment">//申请空间</span></span><br><span class="line">		<span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>) &#123;      <span class="comment">//若申请失败则调用处理函数       </span></span><br><span class="line">			<span class="comment">// report no memory</span></span><br><span class="line">			<span class="type">static</span> <span class="type">const</span> std::bad_alloc nomem;</span><br><span class="line">            _RAISE(nomem);               <span class="comment">//#define _RAISE(x) ::std:: _Throw(x) 抛出nomem的异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在effective c++也提到过，第一步如果用户自定义全局operator new，那么此函数可以接管默认operator new，但是用户尽量仿照默认版本的套路，要么不断请求新的空间，要么抛出异常，要么结束程序。</p>
<p>对应的内存释放程序则十分简单了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *memoryToBeDeallocated)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意以下几点：<br> （1）对于不是类类型（class、struct 或 union）的对象，将调用全局 delete 运算符。<br> （2）于类类型的对象，如果重载operator delete()，则在释放对象时默认调用重载版本，可以使用作用域运算符(::)置于delete之前，显示调用全局operator delete().<br> （3）delete运算符在释放对象之前会调用对象析构函数。</p>
<p> 验证汇编代码<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x):<span class="built_in">x</span>(x)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::ctor&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::dtor&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    A* p = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">delete</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 反汇编后：<br> <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> (gdb) disas main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   <span class="number">0x0000000000401550</span> &lt;+<span class="number">0</span>&gt;:     <span class="keyword">push</span>   <span class="built_in">rbp</span></span><br><span class="line">   <span class="number">0x0000000000401551</span> &lt;+<span class="number">1</span>&gt;:     <span class="keyword">push</span>   <span class="built_in">rsi</span></span><br><span class="line">   <span class="number">0x0000000000401552</span> &lt;+<span class="number">2</span>&gt;:     <span class="keyword">push</span>   <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401553</span> &lt;+<span class="number">3</span>&gt;:     <span class="keyword">mov</span>    <span class="built_in">rbp</span>,<span class="built_in">rsp</span></span><br><span class="line">   <span class="number">0x0000000000401556</span> &lt;+<span class="number">6</span>&gt;:     <span class="keyword">sub</span>    <span class="built_in">rsp</span>,<span class="number">0x30</span></span><br><span class="line">   <span class="number">0x000000000040155a</span> &lt;+<span class="number">10</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x401720</span> &lt;__main&gt;</span><br><span class="line">   <span class="number">0x000000000040155f</span> &lt;+<span class="number">15</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="number">0x4</span> <span class="comment">; new start</span></span><br><span class="line">   <span class="number">0x0000000000401564</span> &lt;+<span class="number">20</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x401648</span> &lt;_Znwy&gt;</span><br><span class="line">   <span class="number">0x0000000000401569</span> &lt;+<span class="number">25</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rbx</span>,<span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x000000000040156c</span> &lt;+<span class="number">28</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0xa</span></span><br><span class="line">   <span class="number">0x0000000000401571</span> &lt;+<span class="number">33</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401574</span> &lt;+<span class="number">36</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x402d20</span> &lt;A::A(<span class="keyword">int</span>)&gt;<span class="comment">;构造函数</span></span><br><span class="line">   <span class="number">0x0000000000401579</span> &lt;+<span class="number">41</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x8</span>],<span class="built_in">rbx</span> </span><br><span class="line">   <span class="number">0x000000000040157d</span> &lt;+<span class="number">45</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rbx</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x8</span>] <span class="comment">;new end</span></span><br><span class="line">   <span class="number">0x0000000000401581</span> &lt;+<span class="number">49</span>&gt;:    <span class="keyword">test</span>   <span class="built_in">rbx</span>,<span class="built_in">rbx</span> <span class="comment">; delete start</span></span><br><span class="line">   <span class="number">0x0000000000401584</span> &lt;+<span class="number">52</span>&gt;:    <span class="keyword">je</span>     <span class="number">0x40159b</span> &lt;main()+<span class="number">75</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401586</span> &lt;+<span class="number">54</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401589</span> &lt;+<span class="number">57</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x402d60</span> &lt;A::~A()&gt; <span class="comment">; 析构函数</span></span><br><span class="line">   <span class="number">0x000000000040158e</span> &lt;+<span class="number">62</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0x4</span></span><br><span class="line">   <span class="number">0x0000000000401593</span> &lt;+<span class="number">67</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401596</span> &lt;+<span class="number">70</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x401650</span> &lt;_ZdlPvy&gt;</span><br><span class="line">=&gt; <span class="number">0x000000000040159b</span> &lt;+<span class="number">75</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x0</span> <span class="comment">;delete end</span></span><br><span class="line">   <span class="number">0x00000000004015a0</span> &lt;+<span class="number">80</span>&gt;:    <span class="keyword">jmp</span>    <span class="number">0x4015bd</span> &lt;main()+<span class="number">109</span>&gt;</span><br><span class="line">   <span class="number">0x00000000004015a2</span> &lt;+<span class="number">82</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rsi</span>,<span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x00000000004015a5</span> &lt;+<span class="number">85</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0x4</span></span><br><span class="line">   <span class="number">0x00000000004015aa</span> &lt;+<span class="number">90</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x00000000004015ad</span> &lt;+<span class="number">93</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x401650</span> &lt;_ZdlPvy&gt;</span><br><span class="line">   <span class="number">0x00000000004015b2</span> &lt;+<span class="number">98</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">rsi</span></span><br><span class="line">   <span class="number">0x00000000004015b5</span> &lt;+<span class="number">101</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x00000000004015b8</span> &lt;+<span class="number">104</span>&gt;:   <span class="keyword">call</span>   <span class="number">0x402af0</span> &lt;_Unwind_Resume&gt;</span><br><span class="line">   <span class="number">0x00000000004015bd</span> &lt;+<span class="number">109</span>&gt;:   <span class="keyword">add</span>    <span class="built_in">rsp</span>,<span class="number">0x30</span></span><br><span class="line">   <span class="number">0x00000000004015c1</span> &lt;+<span class="number">113</span>&gt;:   <span class="keyword">pop</span>    <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x00000000004015c2</span> &lt;+<span class="number">114</span>&gt;:   <span class="keyword">pop</span>    <span class="built_in">rsi</span></span><br><span class="line">   <span class="number">0x00000000004015c3</span> &lt;+<span class="number">115</span>&gt;:   <span class="keyword">pop</span>    <span class="built_in">rbp</span></span><br><span class="line">   <span class="number">0x00000000004015c4</span> &lt;+<span class="number">116</span>&gt;:   <span class="keyword">ret</span>    </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) info line <span class="number">18</span></span><br><span class="line">Line <span class="number">18</span> of <span class="string">&quot;main.cpp&quot;</span> starts <span class="meta">at</span> address <span class="number">0x40155f</span> &lt;main()+<span class="number">15</span>&gt;</span><br><span class="line">   <span class="keyword">and</span> ends <span class="meta">at</span> <span class="number">0x40157d</span> &lt;main()+<span class="number">45</span>&gt;.</span><br><span class="line">Line <span class="number">19</span> of <span class="string">&quot;main.cpp&quot;</span> starts <span class="meta">at</span> address <span class="number">0x40157d</span> &lt;main()+<span class="number">45</span>&gt;</span><br><span class="line"><span class="keyword">and</span> ends <span class="meta">at</span> <span class="number">0x40159b</span> &lt;main()+<span class="number">75</span>&gt;.</span><br></pre></td></tr></table></figure><br>从汇编代码可以看出new首先申请一块内存然后调用构造函数，而delete先调用析构函数然后在释放内存。</p>
<h3 id="array-new-x2F-delete"><a href="#array-new-x2F-delete" class="headerlink" title="array new&#x2F;delete[]"></a>array new&#x2F;delete[]</h3><p>测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x):<span class="built_in">x</span>(x)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::ctor&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::dtor&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    A* p = <span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        p[i].<span class="built_in">setX</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; p[i].<span class="built_in">getX</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看内存布局</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p p</span><br><span class="line">$<span class="number">2</span> = (A *) <span class="number">0x6e1e68</span></span><br><span class="line">(gdb) x/<span class="number">128</span>xb <span class="number">0x6e1e38</span></span><br><span class="line"><span class="number">0x6e1e38</span>:       <span class="number">0xab</span>    <span class="number">0xab</span>    <span class="number">0xab</span>    <span class="number">0xab</span>    <span class="number">0xab</span>    <span class="number">0xab</span>    <span class="number">0xab</span>    <span class="number">0xab</span></span><br><span class="line"><span class="number">0x6e1e40</span>:       <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x6e1e48</span>:       <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x6e1e50</span>:       <span class="number">0xee</span>    <span class="number">0xfe</span>    <span class="number">0xee</span>    <span class="number">0xfe</span>    <span class="number">0xee</span>    <span class="number">0xfe</span>    <span class="number">0xee</span>    <span class="number">0xfe</span>  </span><br><span class="line"><span class="number">0x6e1e58</span>:       <span class="number">0x97</span>    <span class="number">0x1a</span>    <span class="number">0x9c</span>    <span class="number">0x1e</span>    <span class="number">0xaf</span>    <span class="number">0x57</span>    <span class="number">0x00</span>    <span class="number">0x3f</span></span><br><span class="line"><span class="number">0x6e1e60</span>:       <span class="number">0x0a</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">//数组长度10</span></span><br><span class="line"><span class="number">0x6e1e68</span>:       <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x01</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">//p[0],p[1]</span></span><br><span class="line"><span class="number">0x6e1e70</span>:       <span class="number">0x02</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x03</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x6e1e78</span>:       <span class="number">0x04</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x05</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x6e1e80</span>:       <span class="number">0x06</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x07</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x6e1e88</span>:       <span class="number">0x08</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x09</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">//p[8],p[9]</span></span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure>
<p>查看delete[]的汇编代码</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">x0000000000401637 &lt;+<span class="number">231</span>&gt;:   <span class="keyword">je</span>     <span class="number">0x40168f</span> &lt;main()+<span class="number">319</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401639</span> &lt;+<span class="number">233</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x10</span>]<span class="comment">;将数组首地址移入寄存器</span></span><br><span class="line">   <span class="number">0x000000000040163d</span> &lt;+<span class="number">237</span>&gt;:   <span class="keyword">sub</span>    <span class="built_in">rax</span>,<span class="number">0x8</span><span class="comment">;向前8个字节</span></span><br><span class="line">   <span class="number">0x0000000000401641</span> &lt;+<span class="number">241</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>]<span class="comment">;数组长度</span></span><br><span class="line">   <span class="number">0x0000000000401644</span> &lt;+<span class="number">244</span>&gt;:   <span class="keyword">lea</span>    <span class="built_in">rdx</span>,[<span class="built_in">rax</span>*<span class="number">4</span>+<span class="number">0x0</span>]<span class="comment">;终点地址</span></span><br><span class="line">   <span class="number">0x000000000040164c</span> &lt;+<span class="number">252</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0x0000000000401650</span> &lt;+<span class="number">256</span>&gt;:   <span class="keyword">lea</span>    <span class="built_in">rbx</span>,[<span class="built_in">rdx</span>+<span class="built_in">rax</span>*<span class="number">1</span>]</span><br><span class="line">   <span class="number">0x0000000000401654</span> &lt;+<span class="number">260</span>&gt;:   <span class="keyword">cmp</span>    <span class="built_in">rbx</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0x0000000000401658</span> &lt;+<span class="number">264</span>&gt;:   <span class="keyword">je</span>     <span class="number">0x401668</span> &lt;main()+<span class="number">280</span>&gt;</span><br><span class="line">   <span class="number">0x000000000040165a</span> &lt;+<span class="number">266</span>&gt;:   <span class="keyword">sub</span>    <span class="built_in">rbx</span>,<span class="number">0x4</span> <span class="comment">;从最后一个开始析构，因此减sizeof(A) = 4</span></span><br><span class="line">   <span class="number">0x000000000040165e</span> &lt;+<span class="number">270</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401661</span> &lt;+<span class="number">273</span>&gt;:   <span class="keyword">call</span>   <span class="number">0x402ed0</span> &lt;A::~A()&gt;</span><br><span class="line">   <span class="number">0x0000000000401666</span> &lt;+<span class="number">278</span>&gt;:   <span class="keyword">jmp</span>    <span class="number">0x401654</span> &lt;main()+<span class="number">260</span>&gt;<span class="comment">;循环析构</span></span><br><span class="line">   <span class="number">0x0000000000401668</span> &lt;+<span class="number">280</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0x000000000040166c</span> &lt;+<span class="number">284</span>&gt;:   <span class="keyword">sub</span>    <span class="built_in">rax</span>,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x0000000000401670</span> &lt;+<span class="number">288</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>]</span><br><span class="line">   <span class="number">0x0000000000401673</span> &lt;+<span class="number">291</span>&gt;:   <span class="keyword">add</span>    <span class="built_in">rax</span>,<span class="number">0x2</span></span><br><span class="line">   <span class="number">0x0000000000401677</span> &lt;+<span class="number">295</span>&gt;:   <span class="keyword">lea</span>    <span class="built_in">rdx</span>,[<span class="built_in">rax</span>*<span class="number">4</span>+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x000000000040167f</span> &lt;+<span class="number">303</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0x0000000000401683</span> &lt;+<span class="number">307</span>&gt;:   <span class="keyword">sub</span>    <span class="built_in">rax</span>,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x0000000000401687</span> &lt;+<span class="number">311</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x000000000040168a</span> &lt;+<span class="number">314</span>&gt;:   <span class="keyword">call</span>   <span class="number">0x401780</span> &lt;_ZdaPvy&gt;</span><br><span class="line">   <span class="number">0x000000000040168f</span> &lt;+<span class="number">319</span>&gt;:   <span class="keyword">lea</span>    <span class="built_in">rcx</span>,[<span class="built_in">rip</span>+<span class="number">0x298a</span>]        # <span class="number">0x404020</span> &lt;_ZStL6ignore+<span class="number">23</span>&gt;</span><br></pre></td></tr></table></figure>
<p>delete[]获得对象数组的地址后，向前8个字节获得数组长度然后从最后一个对象开始析构，完成后释放整个空间。</p>
<h3 id="operator-new-x2F-operator-delete重载"><a href="#operator-new-x2F-operator-delete重载" class="headerlink" title="operator new&#x2F;operator delete重载"></a>operator new&#x2F;operator delete重载</h3><p>当我们需要在new的时候增加一些特殊的动作，比如输出一些调试信息等，我们需要自己对operator进行重载。例如假如我们重写了下面这个版本，输出一些信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size,string&amp; info)</span><span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; info;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p, string&amp; info)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">delete</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;info&quot;</span>)</span></span>;</span><br><span class="line">A* p = <span class="built_in">new</span> (s) <span class="built_in">A</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">delete</span>(p);</span><br></pre></td></tr></table></figure>
<p>看看汇编层面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info line <span class="number">26</span></span><br><span class="line">Line <span class="number">26</span> of <span class="string">&quot;main.cpp&quot;</span> starts at address <span class="number">0x4015fb</span> &lt;<span class="built_in">main</span>()+<span class="number">65</span>&gt; <span class="keyword">and</span> ends at <span class="number">0x40162d</span> &lt;<span class="built_in">main</span>()+<span class="number">115</span>&gt;.</span><br><span class="line"></span><br><span class="line">(gdb) info line <span class="number">27</span></span><br><span class="line">Line <span class="number">27</span> of <span class="string">&quot;main.cpp&quot;</span> starts at address <span class="number">0x40162d</span> &lt;<span class="built_in">main</span>()+<span class="number">115</span>&gt; <span class="keyword">and</span> ends at <span class="number">0x401639</span> &lt;<span class="built_in">main</span>()+<span class="number">127</span>&gt;.</span><br></pre></td></tr></table></figure>

<p>placement new:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00000000004015fb</span> &lt;+<span class="number">65</span>&gt;:    <span class="keyword">lea</span>    <span class="built_in">rax</span>,[<span class="built_in">rbp</span>-<span class="number">0x30</span>]</span><br><span class="line"><span class="number">0x00000000004015ff</span> &lt;+<span class="number">69</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rdx</span>,<span class="built_in">rax</span></span><br><span class="line"><span class="number">0x0000000000401602</span> &lt;+<span class="number">72</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="number">0x4</span></span><br><span class="line"><span class="number">0x0000000000401607</span> &lt;+<span class="number">77</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x401550</span> &lt;operator new(unsigned long long, <span class="keyword">std</span>::__cxx11::basic_string&lt;char, <span class="keyword">std</span>::char_traits&lt;char&gt;, <span class="keyword">std</span>::allocator&lt;char&gt; &gt;&amp;)&gt;</span><br><span class="line"><span class="number">0x000000000040160c</span> &lt;+<span class="number">82</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rbx</span>,<span class="built_in">rax</span></span><br><span class="line"><span class="number">0x000000000040160f</span> &lt;+<span class="number">85</span>&gt;:    <span class="keyword">test</span>   <span class="built_in">rbx</span>,<span class="built_in">rbx</span></span><br><span class="line"><span class="number">0x0000000000401612</span> &lt;+<span class="number">88</span>&gt;:    <span class="keyword">je</span>     <span class="number">0x401626</span> &lt;main()+<span class="number">108</span>&gt;</span><br><span class="line"><span class="number">0x0000000000401614</span> &lt;+<span class="number">90</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0xa</span></span><br><span class="line"><span class="number">0x0000000000401619</span> &lt;+<span class="number">95</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line"><span class="number">0x000000000040161c</span> &lt;+<span class="number">98</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x402e50</span> &lt;A::A(<span class="keyword">int</span>)&gt;</span><br><span class="line"><span class="number">0x0000000000401621</span> &lt;+<span class="number">103</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">rbx</span></span><br><span class="line"><span class="number">0x0000000000401624</span> &lt;+<span class="number">106</span>&gt;:   <span class="keyword">jmp</span>    <span class="number">0x401629</span> &lt;main()+<span class="number">111</span>&gt;</span><br><span class="line"><span class="number">0x0000000000401626</span> &lt;+<span class="number">108</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">rbx</span></span><br><span class="line"><span class="number">0x0000000000401629</span> &lt;+<span class="number">111</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x38</span>],<span class="built_in">rax</span></span><br><span class="line"><span class="number">0x000000000040162d</span> &lt;+<span class="number">115</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rbx</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x38</span>]</span><br></pre></td></tr></table></figure>
<p>placement delete:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0x0000000000401631</span> &lt;+<span class="number">119</span>&gt;:   <span class="keyword">test</span>   <span class="built_in">rbx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401634</span> &lt;+<span class="number">122</span>&gt;:   <span class="keyword">je</span>     <span class="number">0x40164b</span> &lt;main()+<span class="number">145</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401636</span> &lt;+<span class="number">124</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401639</span> &lt;+<span class="number">127</span>&gt;:   <span class="keyword">call</span>   <span class="number">0x402e90</span> &lt;A::~A()&gt;</span><br><span class="line">   <span class="number">0x000000000040163e</span> &lt;+<span class="number">132</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0x4</span></span><br><span class="line">   <span class="number">0x0000000000401643</span> &lt;+<span class="number">137</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401646</span> &lt;+<span class="number">140</span>&gt;:   <span class="keyword">call</span>   <span class="number">0x401748</span> &lt;_ZdlPvy&gt;</span><br><span class="line">=&gt; <span class="number">0x000000000040164b</span> &lt;+<span class="number">145</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>系统就会使用我们定义的版本进行内存分配。<br>既然默认new 和 delete工作的很好，问什么需要重载？</p>
<ul>
<li>可以用来检测运用上的错误</li>
<li>可以提高效率，节省不必要的内存，提高回收和分配的速度（比如针对某一对象的内存池）</li>
<li>可以收集对内存使用的数据统计</li>
<li>operator delete主要为了处理异常，一般情况下delete会调用全局operator delete释放内存。</li>
</ul>
<h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><p>placement new是重载operator new的一个标准、全局的版本，它不能被自定义的版本代替（不像普通的operator new和operator delete能够被替换成用户自定义的版本）。<br>它的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="type">size_t</span>, <span class="type">void</span> *p )</span> <span class="title">throw</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=orange>它不能够被自定义的版本代替（不像普通版本的operator new和operator delete能够被替换）</font>。如果你想在已经分配的内存中创建一个对象，使用new是不行的。也就是说placement new允许你在一个已经分配好的内存中（栈或堆中）构造一个新的对象。原型中void*p实际上就是指向一个已经分配好的内存缓冲区的的首地址。</p>
<ul>
<li><p>我们为什么需要placement new？</p>
<p>  1.用placement new 解决buffer的问题</p>
<p>  问题描述：用new分配的数组缓冲时，由于调用了默认构造函数，因此执行效率上不佳。若没有默认构造函数则会发生编译时错误。如果你想在预分配的内存上创建对象，用缺省的new操作符是行不通的。要解决这个问题，你可以用placement new构造。它允许你构造一个新对象到预分配的内存上。</p>
<p>  2.增大时空效率的问题</p>
<p>  使用new操作符分配内存需要在堆中查找足够大的剩余空间，显然这个操作速度是很慢的，而且有可能出现无法分配内存的异常（空间不够）。placement new就可以解决这个问题。我们构造对象都是在一个预先准备好了的内存缓冲区中进行，不需要查找内存，内存分配的时间是常数；而且不会出现在程序运行中途出现内存不足的异常。所以，placement new非常适合那些对时间要求比较高，长时间运行不希望被打断的应用程序。</p>
</li>
<li><p>placement new使用步骤</p>
<ul>
<li><p>第一步  缓存提前分配<br>  有三种方式：<br>  1.为了保证通过placement new使用的缓存区的memory alignment(内存队列)正确准备，使用普通的new来分配它：在堆上进行分配class Task。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * buff = <span class="keyword">new</span> [<span class="built_in">sizeof</span>(Task)]; <span class="comment">//分配内存</span></span><br></pre></td></tr></table></figure>
<p>  (请注意auto或者static内存并非都正确地为每一个对象类型排列，所以，你将不能以placement new使用它们。)</p>
<p>  2.在栈上进行分配</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> ;</span><br><span class="line"><span class="type">char</span> buf[<span class="function">N*<span class="title">sizeof</span><span class="params">(Task)</span>]</span>; <span class="comment">//分配内存</span></span><br></pre></td></tr></table></figure>
<p>  3.还有一种方式，就是直接通过地址来使用。(必须是有意义的地址)</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* buf = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt; (<span class="number">0xF00F</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步：对象的分配 </p>
<p>  在刚才已分配的缓存区调用placement new来构造一个对象。<br>  Task *ptask &#x3D; new (buf) Task</p>
</li>
<li><p>第三步：使用</p>
<p>  按照普通方式使用分配的对象：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptask-&gt;<span class="built_in">memberfunction</span>();</span><br><span class="line">ptask-&gt; member;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></li>
<li><p>第四步：对象的析构</p>
<p>  一旦你使用完这个对象，你必须调用它的析构函数来毁灭它。按照下面的方式调用析构函数：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptask-&gt;~<span class="built_in">Task</span>(); <span class="comment">//调用外在的析构函数</span></span><br></pre></td></tr></table></figure></li>
<li><p>第五步：释放</p>
<p>  你可以反复利用缓存并给它分配一个新的对象（重复步骤2，3，4）如果你不打算再次使用这个缓存，你可以象这样释放它：delete [] buf;</p>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/29/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%9Atcmalloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%9Atcmalloc/" class="post-title-link" itemprop="url">c++内存管理系列：tcmalloc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-29T00:00:00+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:55:52" itemprop="dateModified" datetime="2022-09-25T01:55:52+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>参考tcmalloc <a target="_blank" rel="noopener" href="https://github.com/google/tcmalloc/blob/master/docs/design.md">github官方文档</a><br>TCMalloc 是一种内存分配器，旨在替代系统默认分配器，具有以下特点：</p>
<ul>
<li>可以实现大多数对象的快速、无竞争的分配和释放。 对象被缓存，具体取决于模式，每个线程或每个逻辑 CPU。 大多数分配不需要锁定，因此多线程应用程序争用少，扩展性好。</li>
<li>灵活使用内存，因此释放的内存可以重新用于不同的对象大小，或返回给操作系统。</li>
<li>通过分配相同大小的对象的“页面”来降低每个对象的内存开销。小对象的空间损耗很少。</li>
<li>低开销采样，可以详细了解应用程序内存使用情况。<br>下面的框图显示了 TCMalloc 的粗略内部结构：<br><img src="/images/tcmalloc-1.png"></li>
</ul>
<p>我们可以将 TCMalloc 分解为三个组件。前端、中端和后端。职责的粗略分解是：</p>
<ul>
<li>前端是一个缓存，为应用程序提供快速的内存分配和释放。  </li>
<li>中端负责重新填充前端缓存。</li>
<li>后端处理从操作系统获取内存。<br>请注意，前端可以在 per-CPU 或 legacy per-thread 模式下运行，后端可以支持大页面感知 pageheap 或 legacy pageheap。</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>freelist是tcmalloc的实现基础，只不过tcmalloc采用了三层的架构：TreadCache、CentralCache、PageHeap。每一级的分配单元的粒度不一样。基本的原理就是：分配内存和释放内存都是按照从前到后的顺序，在各个层次中进行尝试，前面的层次分配内存失败，则从下一层分配一批补充上来；前面的层次释放了过多的内存，则回收一批到下一层次。</p>
<ul>
<li>tcmalloc有三个层次:<ul>
<li>TreadCache, 这个内存池是线程私有的, 每个线程一份. 每个线程首先会从这里请求内存. 由于是线程私有的, 不需要加锁同步, 所以非常高效. TreadCache维护一组不同类型的freelist, 基本单位是object, 为了实现变长内存的申请, object预设了一些规格(class), 比如8, 16, 32, 80等等</li>
<li>CentralCache, 这是第二层线程池, 这是全局的, 当线程在本地请求失败时会从这里请求object. CentralCache也维护一组关联obejct规格的freelist, 基本单位是span, span由多个连续page(物理单位)组成, 可以分隔为多个object(逻辑单位)。</li>
<li>Pageheap, 这是第三层, 当无法从CentralCache获取到内存时, 会从Pageheap中请求span. 如果PageHeap也没有内存, 则向操作系统请求. Pageheap根据page的数量维护一组freelist, 基本单位是span. 另外还维护这page到span的映射关系.</li>
</ul>
</li>
<li>小对象和大对象: 大于256kb的称为大对象, 大对象会直接向Pageheap申请span, 小对象的申请则需要经过TreadCache申请。</li>
<li>粒度: tcmalloc, 有两种粒度的内存, object和span. TreadCache维护的粒度是object, PageHeap维护的粒度是span. 而CentralCache是一个中间者, 维护span到object的映射关系.</li>
</ul>
<p>数据结构概览如图所示：<br><img src="/images/tcmalloc-3.png"></p>
<ul>
<li>TreadCache<br>线程本地缓存, 比较简单, 维护一组freelist, 尺寸小于256K的小对象, 均由它进行分配. 分配过程中不需要加锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadCache</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">     FreeList      list_[kNumClasses];    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>CentralCache<br>对应不同class的object, CentralCache中有多个CentralFreeList. CentralFreeList维护的是span链表, 每个span下有根据object的大小切割组成一个object链. objects链表示未被分配的object, 分配出去的object数量使用span.refcount_ 记录. span 的结构如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Span</span> &#123;</span></span><br><span class="line">  PageID        start;          <span class="comment">// Span描述的内存的起始地址</span></span><br><span class="line">  Length        length;        <span class="comment">// Span页面数量</span></span><br><span class="line">  Span*         next;           <span class="comment">// Span由双向链表组成，PageHeap和CentralFreeList中都用的到</span></span><br><span class="line">  Span*         prev;           <span class="comment">//</span></span><br><span class="line">  <span class="type">void</span>*         objects;        <span class="comment">// Span会在CentralFreeList中拆分成由object组成的free list</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  refcount : <span class="number">16</span>;  <span class="comment">// Span的object被引用次数，当refcount=0时，表示此Span没有被使用</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  sizeclass : <span class="number">8</span>;  <span class="comment">// Span属于的size class</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  location : <span class="number">2</span>;   <span class="comment">// Span在的位置IN_USE？normal？returned？</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  sample : <span class="number">1</span>;     <span class="comment">// Sampled object?</span></span><br><span class="line">  <span class="comment">// What freelist the span is on: IN_USE if on none, or normal or returned</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
CentralFreeList的结构:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CentralFreeList</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    SpinLock lock_;     <span class="comment">//控制线程访问的锁</span></span><br><span class="line">    <span class="type">size_t</span> size_class_;  <span class="comment">// span对应object的size class, 同上</span></span><br><span class="line">    Span empty_;         <span class="comment">// 放置没有空闲空间的span, 可以避免查找这部分span</span></span><br><span class="line">    Span nonempty_;  <span class="comment">// 和empty相对</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
CentralFreeList里有两个span链表：nonempty_和empty_，根据span的objects链是否有空闲，放入对应链表。</li>
</ul>
<p>CentralFreeList里面还有一个cache（tc_slots_），回收回来的一批object先放进cache，存不下了再回收进span的objects链。分配object给ThreadCache时也是先尝试在cache里面拿，没了再去span里面分配。</p>
<p>TreadCache一般都是以batch_size为一个批次像CentralCache请求, 而为了cache的简单高效，如果批次个数不等于batch_size，则会绕过cache。</p>
<ul>
<li>Pageheap</li>
</ul>
<p>整体结构如下图所示：<br><img src="/images/tcmalloc-6.png"></p>
<p>数组中第256个元素是所有大于255个页面都挂到该链表中.用多种定长 Page 来实现变长 Page 的分配，初始时只有 255 Page 的 Span，如果要分配 1 个 Page 的 Span，就把这个 Span 分裂成两个，1 + 254，把254再记录下来。对于 Span 的回收，需要考虑Span的合并问题，否则在分配回收多次之后，就只剩下很小的 Span 了，也就是带来了外部碎片 问题。</p>
<ul>
<li>page维护了两样东西: page -&gt; span的映射关系和空闲的span伙伴系统.</li>
</ul>
<ol>
<li><p>page -&gt; span 映射<br> page到span的映射关系通过radix 树来实现, 当释放一段内存时, 通过内存偏移和对齐, 就能计算出对应的page, 拿到page在radix树中查找到对应的span, 拿到span就拿到了sizeclass, 从而可以在CentralCache定位span, 将释放的object添加到span的objects链表. 另外通过radix树还可以找到span的相邻span, 如果相邻的span空闲, 则会合并他们。</p>
</li>
<li><p>伙伴系统(span freelist)<br> span的尺寸有从1个page到255个page的所有规格, 大于255个page的span单独归为一类，不作细分. PageHeap维护了这些不同规格的freelist:</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SpanList</span> &#123;</span></span><br><span class="line">Span        normal;</span><br><span class="line">Span        returned;</span><br><span class="line">&#125;;</span><br><span class="line">SpanList large_;                    <span class="comment">// 超过256k的span链表</span></span><br><span class="line">SpanList free_[kMaxPages]</span><br></pre></td></tr></table></figure>

<p> 在内存分配时, 会根据span的大小在伙伴系统中查找, 如果没有空闲的span时, 会向上层更大尺寸的span链表请求, 再没有, 就需要向系统申请了. span可以根据需要不断组合和分割.   </p>
<p> freelist其实是有两个链，normal和returned，以区别活跃跟不活跃的内存。    </p>
<p> PageHeap并不会将内存释放给kernel，因为它们之间的交互都是针对一批连续page的，要想回收到整批的page，可能性很小。在PageHeap里面，多余的内存会放到returned里面去，跟normal做一下隔离。这样一来，normal的内存总是优先被使用，kernel倾向于一直保留它们。而returned的内存则不常被使用，kernel在内存不够的时候会优先将它们swap掉。span进入returned时，tcmalloc还附加了一个操作，madvise(MADV_DONTNEED)，试图告诉kernel这个内存已经不用了</p>
<p> 其实不用returned也能完成这样的事情，因为normal是个链表，每次分配回收总是作用在链表头上，那么链表内的span本身就按从热到冷的顺序排序了。链表尾部的span如果长期不被使用，不管是否移动到returned链，kernel都会倾向于将它们swap掉</p>
<p> 为减少查询radix tree的开销，PageHeap还维护了一个最近最常使用的若干个page到class（span.sizeclass）的对应关系cache。为了保持cache的效率，cache只提供64K个固定坑位，旧的对应关系会被新来的对应关系替换掉。</p>
</li>
</ol>
<h3 id="分配和回收流程"><a href="#分配和回收流程" class="headerlink" title="分配和回收流程"></a>分配和回收流程</h3><p>一图胜千言<br><img src="/images/tcmalloc-4.png"></p>
<p><img src="/images/tcmalloc-5.png"></p>
<h3 id="与ptmalloc对比的优点"><a href="#与ptmalloc对比的优点" class="headerlink" title="与ptmalloc对比的优点"></a>与ptmalloc对比的优点</h3><p>优点：</p>
<ul>
<li>分配更快.小对象几乎无锁， &gt;32KB的对象从CentralCache中分配使用自旋锁。 并且&gt;32KB对象都是页面对齐分配，多线程的时候应尽量避免频繁分配，否则也会造成自旋锁的竞争和页面对齐造成的浪费。</li>
<li>占用额外空间少(例如，分配N个8字节对象可能要使用大约8N * 1.01字节的空间。即，多用百分之一的空间。Ptmalloc2使用最少8字节描述一个chunk。)</li>
<li>碎片化控制优越.ThreadCache会阶段性的回收内存到CentralCache里。 解决了ptmalloc2中arena之间不能迁移的问题。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/27/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9A%E8%99%9A%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/27/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9A%E8%99%9A%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">effective-c++系列：单继承、多继承、虚函数、虚继承内存布局</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-27 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-27T00:00:00+08:00">2021-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:57:09" itemprop="dateModified" datetime="2022-09-25T01:57:09+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="虚函数内存模型"><a href="#虚函数内存模型" class="headerlink" title="虚函数内存模型"></a>虚函数内存模型</h3><ul>
<li>我们可以用基类型A的引用或者指针持有实际类型为派生类B的对象，这意味着，编译时我们无法通过其声明类型来确定其实际类型，也就无法确定应该调用哪个具体的虚函数。考虑到程序中的每个函数都在内存中有着唯一的地址，我们可以将具体函数的地址作为成员变量，存放在对象之中，这样就可以在运行时，通过访问这个成员变量，获取到实际类型虚函数的地址。</li>
</ul>
<h3 id="单继承的内存模型"><a href="#单继承的内存模型" class="headerlink" title="单继承的内存模型"></a>单继承的内存模型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>&#125;</span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    A a;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; endl; </span><br><span class="line">    <span class="comment">// 16 = 虚函数指针（8） + int（4）+ 对齐（4）</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 24 = Base虚函数指针（8）+ Base int(4) + padding（4）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用gdb调试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -o main -g</span><br><span class="line">gdb main</span><br></pre></td></tr></table></figure>

<p>内存布局为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类内存</span></span><br><span class="line">(gdb) p b</span><br><span class="line">$<span class="number">1</span> = &#123;</span><br><span class="line">  _vptr.Base = <span class="number">0x404580</span> &lt;vtable <span class="keyword">for</span> Base+<span class="number">16</span>&gt;,</span><br><span class="line">  x = <span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line">(gdb) p &amp;b</span><br><span class="line">$<span class="number">4</span> = (Base *) <span class="number">0x61fe10</span></span><br><span class="line">(gdb) x/<span class="number">16</span>xb <span class="number">0x61fe10</span></span><br><span class="line"><span class="number">0x61fe10</span>:       <span class="number">0x40</span>    <span class="number">0x45</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x61fe18</span>:       <span class="number">0x10</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="comment">// 子类内存</span></span><br><span class="line">(gdb) p a</span><br><span class="line">$<span class="number">2</span> = &#123;</span><br><span class="line">  &lt;Base&gt; = &#123;</span><br><span class="line">    _vptr.Base = <span class="number">0x404520</span> &lt;vtable <span class="keyword">for</span> A+<span class="number">16</span>&gt;, </span><br><span class="line">    x = <span class="number">20</span></span><br><span class="line">  &#125;, &lt;No data fields&gt;&#125;</span><br><span class="line">(gdb) p &amp;a</span><br><span class="line">$<span class="number">5</span> = (A *) <span class="number">0x61fe00</span></span><br><span class="line">(gdb) x/<span class="number">16</span>xb <span class="number">0x61fe00</span></span><br><span class="line"><span class="number">0x61fe00</span>:       <span class="number">0x20</span>    <span class="number">0x45</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x61fe08</span>:       <span class="number">0x14</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<p>可以看出子类中含有父类的成员变量和一个虚函数指针，虚函数表指针在前。<br>子类覆盖了父类的函数f1()，因此在子类的虚函数表中会将Base::f1()覆盖为A::f1().</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p b.f1</span><br><span class="line">$<span class="number">2</span> = &#123;<span class="built_in">void</span> (Base * <span class="type">const</span>)&#125; <span class="number">0x402d80</span> &lt;Base::<span class="built_in">f1</span>()&gt;</span><br><span class="line">(gdb) p b</span><br><span class="line">$<span class="number">3</span> = &#123;_vptr.Base = <span class="number">0x404540</span> &lt;vtable <span class="keyword">for</span> Base+<span class="number">16</span>&gt;, x = <span class="number">16</span>&#125;</span><br><span class="line">(gdb) x/<span class="number">16</span>xb <span class="number">0x404540</span> <span class="comment">//Base虚函数表</span></span><br><span class="line"><span class="comment">//f1()函数地址</span></span><br><span class="line"><span class="number">0x404540</span> &lt;_ZTV4Base+<span class="number">16</span>&gt;:        <span class="number">0x80</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x404548</span> &lt;_ZTV4Base+<span class="number">24</span>&gt;:        <span class="number">0x90</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">gdb) p a</span><br><span class="line">$<span class="number">4</span> = &#123;&lt;Base&gt; = &#123;_vptr.Base = <span class="number">0x404520</span> &lt;vtable <span class="keyword">for</span> A+<span class="number">16</span>&gt;, x = <span class="number">20</span>&#125;, &lt;No data fields&gt;&#125;</span><br><span class="line">(gdb) x/<span class="number">16</span>xb <span class="number">0x404520</span> <span class="comment">//A虚函数表</span></span><br><span class="line"><span class="comment">//f1()函数</span></span><br><span class="line"><span class="number">0x404520</span> &lt;_ZTV1A+<span class="number">16</span>&gt;:   <span class="number">0x20</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x404528</span> &lt;_ZTV1A+<span class="number">24</span>&gt;:   <span class="number">0x90</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<p>在线性继承关系中，子类只需包含一个虚函数指针和直接父类的所有成员函数即可。  </p>
<h3 id="多继承内存模型"><a href="#多继承内存模型" class="headerlink" title="多继承内存模型"></a>多继承内存模型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f0</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">public</span> Base1,</span><br><span class="line">        <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::f1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::f2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(Base1);<span class="comment">//16</span></span><br><span class="line"><span class="built_in">sizeof</span>(Base2);<span class="comment">//16</span></span><br><span class="line"><span class="built_in">sizeof</span>(A);<span class="comment">//32</span></span><br></pre></td></tr></table></figure>
<p>同样使用gdb调试</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p a</span><br><span class="line">$<span class="number">2</span> = &#123;</span><br><span class="line">  &lt;Base1&gt; = &#123;</span><br><span class="line">    _vptr.Base1 = <span class="number">0x404560</span> &lt;vtable <span class="keyword">for</span> A+<span class="number">16</span>&gt;,</span><br><span class="line">    x = <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &lt;Base2&gt; = &#123;</span><br><span class="line">    _vptr.Base2 = <span class="number">0x404580</span> &lt;vtable <span class="keyword">for</span> A+<span class="number">48</span>&gt;,</span><br><span class="line">    x = <span class="number">16</span></span><br><span class="line">  &#125;, &lt;No data fields&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出Base1作为A的主基类，虚函数表从Base1的函数地址开始。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p &amp;a    </span><br><span class="line">$<span class="number">3</span> = (A *) <span class="number">0x61fe00</span></span><br><span class="line">(gdb) x/<span class="number">32</span>xb <span class="number">0x61fe00</span></span><br><span class="line"><span class="number">0x61fe00</span>:       <span class="number">0x60</span>    <span class="number">0x45</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x61fe08</span>:       <span class="number">0x14</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x61fe10</span>:       <span class="number">0x80</span>    <span class="number">0x45</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x61fe18</span>:       <span class="number">0x10</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<p>A中存在Base1的虚表指针，Base2的虚表指针。可以看到两个虚表是相连的，如果重写Base1的函数会直接在虚表中覆盖，Base2同理。<br>下面在内存中查看下两个虚表的布局</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/<span class="number">64</span>xb <span class="number">0x404550</span></span><br><span class="line"><span class="number">0x404550</span> &lt;_ZTV1A&gt;:      <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> </span><br><span class="line"><span class="number">0x404558</span> &lt;_ZTV1A+<span class="number">8</span>&gt;:    <span class="number">0xc0</span>    <span class="number">0x44</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">// RTTI:运行时类型信息(Run-Time Type Identification, RTTI)</span></span><br><span class="line"><span class="number">0x404560</span> &lt;_ZTV1A+<span class="number">16</span>&gt;:   <span class="number">0xa0</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">// Base1::f0()</span></span><br><span class="line"><span class="number">0x404568</span> &lt;_ZTV1A+<span class="number">24</span>&gt;:   <span class="number">0xf0</span>    <span class="number">0x2c</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">// A::f1()</span></span><br><span class="line"><span class="number">0x404570</span> &lt;_ZTV1A+<span class="number">32</span>&gt;:   <span class="number">0xf0</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span> <span class="comment">//offeset</span></span><br><span class="line"><span class="number">0x404578</span> &lt;_ZTV1A+<span class="number">40</span>&gt;:   <span class="number">0xc0</span>    <span class="number">0x44</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">// RTTI</span></span><br><span class="line"><span class="number">0x404580</span> &lt;_ZTV1A+<span class="number">48</span>&gt;:   <span class="number">0x00</span>    <span class="number">0x2e</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">//chunk A::f1()</span></span><br><span class="line"><span class="number">0x404588</span> &lt;_ZTV1A+<span class="number">56</span>&gt;:   <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<p>A将Base1作为主基类，也就是将它虚函数“并入”Base1的虚函数表之中，并将Base1的虚指针作为A的内存起始地址。</p>
<p>而类型Base2的虚指针_vptr.Base2并不能直接指向虚表中的第4个实体，这是因为_vptr.Base2所指向的虚表区域，在格式上必须也是一个完整的虚表。因此，需要为_vptr.Base2创建对应的虚表放在虚表Base1的部分之后。 </p>
<p>在多继承中，由于不同的基类起点可能处于不同的位置，因此当需要将它们转化为实际类型时，this指针的偏移量也不相同。由于实际类型在编译时是未知的，这要求偏移量必须能够在运行时获取。实体offset表示的就是实际类型起始地址到当前这个形式类型起始地址的偏移量。在向上动态转换到实际类型时，让this指针加上这个偏移量即可得到实际类型的地址。需要注意的是，由于一个类型即可以被单继承，也可以被多继承，因此即使只有单继承，实体offset也会存在于每一个多态类型之中。</p>
<p>而实体Thunk又是什么呢？如果不考虑这个Thunk，这里应该存放函数A::f1()的地址。然而，从内存分配可以看出，Thunk A::f1()和A::f1()的地址并不一样。</p>
<p>为了弄清楚Thunk是什么，我们首先要注意到，如果一个类型Base2 的引用持有了实际类型为A的变量，这个引用的起始地址在A+16处。当它调用由类型A重写的函数f1()时，如果直接使用this指针调用A::f1()会由于this指针的地址多出16字节的偏移量导致错误。 因此在调用之前，this指针必须要被调整至正确的位置 。这里的Thunk起到的就是这个作用：首先将this 指针调整到正确的位置，即减少16字节偏移量，然后再去调用函数A::f1()。 </p>
<p><font color=orange>简单来说，offerset的作用是编译器绑定对象，如果是Base1指针，就加上Base1对应的偏移量，如果是Base2，就加上Base2的偏移量。<br>而thunk的作用类似于重定位，当用户申请Base2指针指向A对象，并且调用f1()函数，在内存中首先是从0x404580开始找，找到thunk后，里面是一个代码段，首先将this指针向上指，然后再调用this-&gt;f1()</font>。</p>
<h3 id="虚继承的内存模型"><a href="#虚继承的内存模型" class="headerlink" title="虚继承的内存模型"></a>虚继承的内存模型</h3><p>上述的模型中，对于派生类对象，它的基类相对于它的偏移量总是确定的，因此动态向下转换并不需要依赖额外的运行时信息。</p>
<p>而虚继承破坏了这一条件。它表示虚基类相对于派生类的偏移量可以依实际类型不同而不同，且仅有一份拷贝，这使得虚基类的偏移量在运行时才可以确定。因此，我们需要对继承了虚基类的类型的虚表进行扩充，使其包含关于虚基类偏移量的信息。</p>
<p><font color=orange>虚继承最常用的场景是解决菱形继承的问题</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> ax;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;                                     </span><br><span class="line">    <span class="type">int</span> bx;                          </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f0</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;             </span><br><span class="line">&#125;;                                     </span><br><span class="line">                                      </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;                                     </span><br><span class="line">    <span class="type">int</span> cx;                          </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f0</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;             </span><br><span class="line">&#125;;                                    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line">    <span class="type">int</span> dx;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f0</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl; <span class="comment">// 16 虚指针A + int + pad</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; endl; <span class="comment">// 32 A + 虚指针B + int + pad</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; endl; <span class="comment">// 32 A + 虚指针C + int + pad</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(D) &lt;&lt; endl; <span class="comment">// 48 A + 虚指针D + int + pad</span></span><br></pre></td></tr></table></figure>
<p>A的内存布局和虚表没有太多变化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p a</span><br><span class="line">$<span class="number">6</span> = &#123;</span><br><span class="line">  _vptr.A = <span class="number">0x4056c0</span> &lt;vtable <span class="keyword">for</span> A+<span class="number">16</span>&gt;,</span><br><span class="line">  x = <span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line">(gdb) x/<span class="number">16</span>xb <span class="number">0x4056c0</span></span><br><span class="line"><span class="number">0x4056c0</span> &lt;_ZTV1A+<span class="number">16</span>&gt;:   <span class="number">0x70</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">// A::f0()</span></span><br><span class="line"><span class="number">0x4056c8</span> &lt;_ZTV1A+<span class="number">24</span>&gt;:   <span class="number">0x80</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">// A::f1()</span></span><br></pre></td></tr></table></figure>

<p>B&#x2F;C的内存布局</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$<span class="number">7</span> = &#123;</span><br><span class="line">  &lt;A&gt; = &#123;</span><br><span class="line">    _vptr.A = <span class="number">0x405710</span> &lt;vtable <span class="keyword">for</span> B+<span class="number">64</span>&gt;,</span><br><span class="line">    x = <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">  members of B:</span><br><span class="line">  _vptr.B = <span class="number">0x4056e8</span> &lt;vtable <span class="keyword">for</span> B+<span class="number">24</span>&gt;,</span><br><span class="line">  y = <span class="number">4199705</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B&#x2F;C的虚表内存为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/<span class="number">72</span>xb <span class="number">0x4056d0</span></span><br><span class="line"><span class="number">0x4056d0</span> &lt;_ZTV1B&gt;:      <span class="number">0x10</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">// vbase_offset</span></span><br><span class="line"><span class="number">0x4056d8</span> &lt;_ZTV1B+<span class="number">8</span>&gt;:    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>  <span class="comment">//offset_to_top</span></span><br><span class="line"><span class="number">0x4056e0</span> &lt;_ZTV1B+<span class="number">16</span>&gt;:   <span class="number">0x70</span>    <span class="number">0x55</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   <span class="comment">// RTTI of B</span></span><br><span class="line"><span class="number">0x4056e8</span> &lt;_ZTV1B+<span class="number">24</span>&gt;:   <span class="number">0xd0</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   <span class="comment">// B.f0()</span></span><br><span class="line"><span class="number">0x4056f0</span> &lt;_ZTV1B+<span class="number">32</span>&gt;:   <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   <span class="comment">//vcall_offset</span></span><br><span class="line"><span class="number">0x4056f8</span> &lt;_ZTV1B+<span class="number">40</span>&gt;:   <span class="number">0xf0</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>   <span class="comment">//vcall_offset</span></span><br><span class="line"><span class="number">0x405700</span> &lt;_ZTV1B+<span class="number">48</span>&gt;:   <span class="number">0xf0</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>   <span class="comment">//offset_to_top</span></span><br><span class="line"><span class="number">0x405708</span> &lt;_ZTV1B+<span class="number">56</span>&gt;:   <span class="number">0x70</span>    <span class="number">0x55</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   <span class="comment">//RTTI for B</span></span><br><span class="line"><span class="number">0x405710</span> &lt;_ZTV1B+<span class="number">64</span>&gt;:   <span class="number">0xb0</span>    <span class="number">0x2f</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   <span class="comment">//Thunk B::f0()</span></span><br><span class="line"><span class="number">0x405718</span> &lt;_ZTV1B+<span class="number">72</span>&gt;:   <span class="number">0x80</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   <span class="comment">//A::f1()</span></span><br></pre></td></tr></table></figure>
<p>可以表示为下面这个结构</p>
<p><img src="/images/003.png"></p>
<center>B的内存布局</center>
对于形式类型为B的引用，在编译时，无法确定它的基类A它在内存中的偏移量。 因此，需要在虚表中额外再提供一个实体，表明运行时它的基类所在的位置，这个实体称为vbase_offset，位于offset_to_top上方。  

<p>除此之外，如果在B中调用A声明且B没有重写的函数，由于A的偏移量无法在编译时确定，而这些函数的调用由必须在A的偏移量确定之后进行， 因此这些函数的调用相当于使用A的引用调用。也因此，当使用虚基类A的引用调用重载函数时 ，每一个函数对this指针的偏移量调整都可能不同，它们被记录在镜像位置的vcall_offset中。例如，调用A::bar()时，this指针指向的是vptr_A，正是函数所属的类A的位置，因此不需要调整，即vcall_offset(0)；而B::f0()是由类型B实现的， 因此需要将this指针向前调整16字节。</p>
<p>D的内存布局 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p d</span><br><span class="line">$<span class="number">8</span> = &#123;</span><br><span class="line">  &lt;B&gt; = &#123;</span><br><span class="line">    &lt;A&gt; = &#123;</span><br><span class="line">      _vptr.A = <span class="number">0x4057d0</span> &lt;vtable <span class="keyword">for</span> D+<span class="number">96</span>&gt;,</span><br><span class="line">      x = <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    members of B:</span><br><span class="line">    _vptr.B = <span class="number">0x405788</span> &lt;vtable <span class="keyword">for</span> D+<span class="number">24</span>&gt;,</span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &lt;C&gt; = &#123;</span><br><span class="line">    members of C:</span><br><span class="line">    _vptr.C = <span class="number">0x4057a8</span> &lt;vtable <span class="keyword">for</span> D+<span class="number">56</span>&gt;,</span><br><span class="line">    z = <span class="number">-605902202</span></span><br><span class="line">  &#125;,</span><br><span class="line">  members of D:</span><br><span class="line">  d = <span class="number">32763</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚表内存为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/<span class="number">176</span>xb <span class="number">0x405770</span></span><br><span class="line"><span class="number">0x405770</span> &lt;_ZTV1D&gt;:      <span class="number">0x20</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x405778</span> &lt;_ZTV1D+<span class="number">8</span>&gt;:    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x405780</span> &lt;_ZTV1D+<span class="number">16</span>&gt;:   <span class="number">0xd0</span>    <span class="number">0x55</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x405788</span> &lt;_ZTV1D+<span class="number">24</span>&gt;:   <span class="number">0x10</span>    <span class="number">0x2f</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x405790</span> &lt;_ZTV1D+<span class="number">32</span>&gt;:   <span class="number">0x10</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x405798</span> &lt;_ZTV1D+<span class="number">40</span>&gt;:   <span class="number">0xf0</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>   </span><br><span class="line"><span class="number">0x4057a0</span> &lt;_ZTV1D+<span class="number">48</span>&gt;:   <span class="number">0xd0</span>    <span class="number">0x55</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x4057a8</span> &lt;_ZTV1D+<span class="number">56</span>&gt;:   <span class="number">0xa0</span>    <span class="number">0x2f</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x4057b0</span> &lt;_ZTV1D+<span class="number">64</span>&gt;:   <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x4057b8</span> &lt;_ZTV1D+<span class="number">72</span>&gt;:   <span class="number">0xe0</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span></span><br><span class="line"><span class="number">0x4057c0</span> &lt;_ZTV1D+<span class="number">80</span>&gt;:   <span class="number">0xe0</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>   </span><br><span class="line"><span class="number">0x4057c8</span> &lt;_ZTV1D+<span class="number">88</span>&gt;:   <span class="number">0xd0</span>    <span class="number">0x55</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x4057d0</span> &lt;_ZTV1D+<span class="number">96</span>&gt;:   <span class="number">0xd0</span>    <span class="number">0x2f</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x4057d8</span> &lt;_ZTV1D+<span class="number">104</span>&gt;:  <span class="number">0x80</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="comment">//下面为调试信息</span></span><br><span class="line"><span class="number">0x4057e0</span> &lt;_ZTV1D+<span class="number">112</span>&gt;:  <span class="number">0x47</span>    <span class="number">0x43</span>    <span class="number">0x43</span>    <span class="number">0x3a</span>    <span class="number">0x20</span>    <span class="number">0x28</span>    <span class="number">0x78</span>    <span class="number">0x38</span></span><br><span class="line"><span class="number">0x4057e8</span> &lt;_ZTV1D+<span class="number">120</span>&gt;:  <span class="number">0x36</span>    <span class="number">0x5f</span>    <span class="number">0x36</span>    <span class="number">0x34</span>    <span class="number">0x2d</span>    <span class="number">0x70</span>    <span class="number">0x6f</span>    <span class="number">0x73</span>   </span><br><span class="line"><span class="number">0x4057f0</span> &lt;_ZTV1D+<span class="number">128</span>&gt;:  <span class="number">0x69</span>    <span class="number">0x78</span>    <span class="number">0x2d</span>    <span class="number">0x73</span>    <span class="number">0x65</span>    <span class="number">0x68</span>    <span class="number">0x2d</span>    <span class="number">0x72</span>   </span><br><span class="line"><span class="number">0x4057f8</span> &lt;_ZTV1D+<span class="number">136</span>&gt;:  <span class="number">0x65</span>    <span class="number">0x76</span>    <span class="number">0x30</span>    <span class="number">0x2c</span>    <span class="number">0x20</span>    <span class="number">0x42</span>    <span class="number">0x75</span>    <span class="number">0x69</span>   </span><br><span class="line"><span class="number">0x405800</span> &lt;_ZTV1D+<span class="number">144</span>&gt;:  <span class="number">0x6c</span>    <span class="number">0x74</span>    <span class="number">0x20</span>    <span class="number">0x62</span>    <span class="number">0x79</span>    <span class="number">0x20</span>    <span class="number">0x4d</span>    <span class="number">0x69</span>   </span><br><span class="line"><span class="number">0x405808</span> &lt;_ZTV1D+<span class="number">152</span>&gt;:  <span class="number">0x6e</span>    <span class="number">0x47</span>    <span class="number">0x57</span>    <span class="number">0x2d</span>    <span class="number">0x57</span>    <span class="number">0x36</span>    <span class="number">0x34</span>    <span class="number">0x20</span></span><br><span class="line"><span class="number">0x405810</span> &lt;_ZTV1D+<span class="number">160</span>&gt;:  <span class="number">0x70</span>    <span class="number">0x72</span>    <span class="number">0x6f</span>    <span class="number">0x6a</span>    <span class="number">0x65</span>    <span class="number">0x63</span>    <span class="number">0x74</span>    <span class="number">0x29</span>   </span><br><span class="line"><span class="number">0x405818</span> &lt;_ZTV1D+<span class="number">168</span>&gt;:  <span class="number">0x20</span>    <span class="number">0x38</span>    <span class="number">0x2e</span>    <span class="number">0x31</span>    <span class="number">0x2e</span>    <span class="number">0x30</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<p>可以表示为下面这个结构</p>
<p><img src="/images/004.png">  </p>
<center>D的虚表结构</center>

<p>与非虚继承相似，通过虚继承产生的派生类在构造和析构时，所调用的虚函数只是当前阶段的的虚表中对应的函数。一个问题也就由此产生，由于在虚基类的不同的派生类中，虚基类相对于该类型的偏移量是可以不同的，如果直接使用2.3中的方法，直接用继承虚基类的类型自身的虚表作为构建该类时使用的虚表，会由于偏移量的不同，导致无法正确获取虚基类中的对象。<br>这个描述比较抽象拗口，我们通过3.1中的菱形继承的例子进行解释。四个类型A，B，C和D的继承关系如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> ax;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;                                     </span><br><span class="line">    <span class="type">int</span> bx;                          </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f0</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;             </span><br><span class="line">&#125;;                                     </span><br><span class="line">                                      </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;                                     </span><br><span class="line">    <span class="type">int</span> cx;                          </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f0</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;             </span><br><span class="line">&#125;;                                    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line">    <span class="type">int</span> dx;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f0</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>观察实际类型为B和实际类型为D对象的内存布局可以发现，如果实际类型为B，虚基类A对B的首地址的偏移量为16；若实际类型为D，则其中A对B首地址的偏移量为32。这明显与B自身的虚表冲突。如果构建D::B时还采用的是B自身的虚表，会由于偏移量的不同导致错误。</p>
<p>这一问题的解决方法其实很粗暴，那就是在对象构造、析构阶段，会用到多少种虚表，会用到多少种虚指针就生成多少种虚指针。在构造或析构时，“按需分配”。</p>
<p>例如，这里的类型D是类型B和C的子类，而B和C虚继承了类型A。 这种继承关系会导致D内部含有的B(称作B-in-D)、C(称作C-in-D)的虚表与B、C的虚表不同。 因此，这需要生成两张新的虚表，即B-in-D和C-in-D的虚表。</p>
<p>由于B-in-D也是B类型的一种布局，B的一个虚表对应两个虚指针，分别是vptr_B和vptr_A，因此它也有两个着两个虚指针。在构造或析构D::B时，其对象的内存布局和虚表布局如图所示：</p>
<p><img src="/images/005.png">  </p>
<p>同样的，在C-in-D中也会有两个虚指针，分别是vptr_C和vptr_A。此外，在最终的D中还有三个虚指针，总计7个不同的虚指针，它们指向3张虚表的7个不同位置。因此编译器为类型D总共生成了3个不同的虚表，和7个不同的虚指针。将这7个虚指针合并到一个表中，这个表就是虚表的表(Virtual Table Table, VTT)。显然，只有当一个类的父类是继承了虚基类的类型时，编译器才会为它创建VTT。</p>
<p>在构造和析构过程中，子类的构造函数或析构函数向基类传递一个合适的、指向VTT某个部分指针，使得父类的构造函数或析构函数获取到正确的虚表。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/25/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9Aprivate%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9Aprivate%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">effective-c++系列：private继承和多继承</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-25T00:00:00+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:57:21" itemprop="dateModified" datetime="2022-09-25T01:57:21+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="private继承"><a href="#private继承" class="headerlink" title="private继承"></a>private继承</h3><ul>
<li><p>如果class之间的继承关系是private，那么编译器不会自动将一个子类对象转换为父类对象。</p>
</li>
<li><p>使用private继承的所有父类成员，在子类中都是private类型的，即使成员在父类中是public或者protected的。</p>
</li>
<li><p>private意味着只有实现部分被继承，接口部分应略去。</p>
</li>
<li><p>private继承可以造成empty base最优化，如下代码  </p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    Empty e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(A);<span class="comment">//8</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>);<span class="comment">//4</span></span><br><span class="line">```  </span><br><span class="line">使用私有继承可以避免</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">private</span> Empty&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(A);<span class="comment">//4</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>);<span class="comment">//4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul>
<li><p>多重继承中的歧义<br>看下面的代码  </p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: </span><br><span class="line">    <span class="keyword">public</span> A,</span><br><span class="line">    <span class="keyword">public</span> B&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">d.<span class="built_in">f1</span>(); <span class="comment">//ambiguous! A::f1() or B::f1()</span></span><br></pre></td></tr></table></figure>
<p>  在基类中定义命名相同的函数很容易造成这种问题，即使继承方式可能是私有或者方法名是私有，都会造成歧义。可以使用作用域+函数的方式显示声明要调用的函数，如A::f1();</p>
</li>
<li><p>菱形继承</p>
</li>
</ul>
<p><img src="/images/002.png"></p>
<center>菱形继承</center>  

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span>&#123;</span><br><span class="line">    string filename;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span> : <span class="keyword">public</span> File&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span> : <span class="keyword">public</span> File&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile,</span><br><span class="line">              <span class="keyword">public</span> OutputFile&#123;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是一个典型的菱形继承，假设File类有个成员变量Filename，那么IOFile内有多少个Filename呢？有两种说法。<br>  IOFile从InputFile和OutputFile均复制了一份，存在两份filename。<br>  IOFile只应该有一份。<br>  c++默认的做法是第一种，产生两个filename成员。</li>
<li>解决方式是<font color=orange>virtual继承</font>，也就是说File类必须是virtual base class</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span>&#123;</span><br><span class="line">    string filename;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> File&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> File&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile,</span><br><span class="line">              <span class="keyword">public</span> OutputFile&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这样在IOFile内部就只有一份filename副本。<br>那么虚继承是怎么实现这个功能的呢。具体在虚继承内存布局章节会讨论。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/23/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9Apublic%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/23/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9Apublic%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">effective-c++系列：public继承注意事项</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-23 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-23T00:00:00+08:00">2021-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:57:28" itemprop="dateModified" datetime="2022-09-25T01:57:28+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="public继承-x3D-x3D-is-a关系"><a href="#public继承-x3D-x3D-is-a关系" class="headerlink" title="public继承&#x3D;&#x3D;is_a关系"></a>public继承&#x3D;&#x3D;is_a关系</h3><ul>
<li><p>如果<font color=green>class D </font>以public形式继承<font color=green>class B</font>，那么相当于告诉c++编译器，每一个类型为D的对象同时也是一个类型为B的对象，反之不成立。 </p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> Person&#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果任何函数期望获得Person，那么也能接受一个Student</p>
</li>
<li><p>继承带来的问题</p>
<ul>
<li>子类可能不具有父类的某些行为（emmm, 个人觉得一方面因为抽象的层次不够高，或者继承范围太模糊）</li>
<li>父类的一些函数会破坏子类的性质（例如父类是一个矩形，子类是一个正方形，扩展长方形的长宽函数应用在子类会破坏正方形的性质。</li>
</ul>
</li>
</ul>
<h3 id="命名遮盖规则"><a href="#命名遮盖规则" class="headerlink" title="命名遮盖规则"></a>命名遮盖规则</h3><ul>
<li><p>对于下面的代码  </p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<font color=orange>dosomething() </font>函数中，cin的对象是<font color=green>double x</font>变量，这遵从c++的名称遮掩规则，即内层作用域会遮盖外层作用域。</p>
</li>
<li><p>同理而言，在继承关系中也是这样</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  <font color=orange>class Base</font>包含了纯虚函数，虚函数和普通成员函数，以此来说明命名遮盖和只和函数名有关而与其他无关。<br>  假设<font color=orange>f4()</font>实现代码如下  </p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::f4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  当编译器遇到<font color=orange>f2()</font>函数时，会查找作用域，首先看<font color=orange>f4()</font>函数内部，没有找到，于是朝赵<font color=orange>class Derived</font>作用域也没有找到，最后查找<font color=orange>class Base</font>作用域找到<font color=orange>f2()</font>。假如<font color=orange>class Base</font>中也没有，那就在<font color=orange>class Base</font>所在<font color=orange>namespace</font>中查找，最后在全局作用域 找。  </p>
<p>  下面看一个更复杂的例子</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> )</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f1 - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f2 - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f3 - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">double</span>)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f3 - b - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f1 - d&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f3 - d&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f4 - d&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">d.<span class="built_in">f1</span>(); <span class="comment">//ok</span></span><br><span class="line">d.<span class="built_in">f1</span>(x); <span class="comment">//error! Base::f1()被覆盖</span></span><br><span class="line">d.<span class="built_in">f2</span>(); <span class="comment">//ok Base::f2()</span></span><br><span class="line">d.<span class="built_in">f3</span>(); <span class="comment">//ok</span></span><br><span class="line">d.<span class="built_in">f3</span>(x); <span class="comment">//error! Base::f3(int)被Derived::f3()遮盖</span></span><br></pre></td></tr></table></figure>
<p>  子类的<font color=orange>f3()</font>函数将父类的<font color=orange>f3()和f3(int)</font>都覆盖掉。<br>  如果想避免这种情况，可以像下面这样  </p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> )</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f1 - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f2 - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f3 - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">double</span>)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f3 - b - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::f1;</span><br><span class="line">    <span class="keyword">using</span> Base::f3;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f1 - d&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f3 - d&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f4 - d&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">d.<span class="built_in">f1</span>(); <span class="comment">//ok</span></span><br><span class="line">d.<span class="built_in">f1</span>(x); <span class="comment">//ok</span></span><br><span class="line">d.<span class="built_in">f2</span>(); <span class="comment">//ok Base::f2()</span></span><br><span class="line">d.<span class="built_in">f3</span>(); <span class="comment">//ok</span></span><br><span class="line">d.<span class="built_in">f3</span>(x); <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<p>  那假如我们只想继承父类的一部分函数呢？这时候<font color=orange>using</font>就不管用了，因为一旦声明using，父类同名所有函数可见。这时候可以采用<font color=orange>转交函数（forwarding function）</font>完成。  </p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//virtual void f1() = 0; effective c++ 160页为纯虚函数？此处存疑。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base::<span class="built_in">f1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="接口继承和实现继承"><a href="#接口继承和实现继承" class="headerlink" title="接口继承和实现继承"></a>接口继承和实现继承</h3><ul>
<li>成员函数的接口总是会被继承。</li>
<li>声明一个纯虚函数的目的是为了让子类只继承函数接口。<font color=orange>纯虚函数对象不能被实例化</font>。</li>
<li>声明一个虚函数（非纯虚函数）的目的是让子类继承该函数的接口和缺省实现。</li>
<li>声明一个非虚函数的目的是为了让子类继承函数的接口和一份强制性实现。非虚函数是<font color=orange>不变性（invariant）和凌驾特异性（specialization）</font>的。所以它不该在子类中被重新定义。</li>
</ul>
<h3 id="默认参数的继承"><a href="#默认参数的继承" class="headerlink" title="默认参数的继承"></a>默认参数的继承</h3><ul>
<li><p>考虑下面默认参数继承的代码</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Option</span> &#123;First, Second, Third&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(Option op = First)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(Option op = Second)</span> <span class="type">const</span></span>;<span class="comment">//赋予不同的默认值，这很糟糕</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(Option op)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 如果这么写，用户以对象调用一定要指定参数值，</span></span><br><span class="line">    <span class="comment">// 因为静态绑定下不从基类继承默认值</span></span><br><span class="line">    <span class="comment">// 如果使用指针或者引用调用，可以不指定因为动态绑定下这个函数会从基类</span></span><br><span class="line">    <span class="comment">// 继承默认值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>静态类型：变量声明的时候指定的类型名。</p>
</li>
<li><p>动态类型：目前所指对象的类型。  </p>
<pre><code class="cpp">Base* b;             //静态类型为Base*,无动态类型
Base* d1 = new D1;   //静态类型为Base*,动态类型为D1*
Base* d2 = new D2;   //静态类型为Base*,动态类型为D2*
b = d1;              //静态类型为Base*,动态类型为D1*
d1 = d2;             //静态类型为Base*,动态类型为D2*
</code></pre>
</li>
<li><p><font color=orange>virtual函数动态绑定，默认参数却是静态绑定</font>  </p>
<pre><code class="cpp">D2 -&gt; f1(); //使用的是D2的函数，参数却是Base的。
</code></pre>
<p>  问：为什么要采用这种方式运行呢？<br>  答：提高运行期效率。在编译器直接决定，不在运行期动态确定（降低编译器实现难度，增加速度）。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/22/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%85%A5%E6%8E%A2%E6%9E%90swap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/22/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%85%A5%E6%8E%A2%E6%9E%90swap/" class="post-title-link" itemprop="url">effective-c++系列：深入探析swap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-22T00:00:00+08:00">2021-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:57:04" itemprop="dateModified" datetime="2022-09-25T01:57:04+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="swap介绍"><a href="#swap介绍" class="headerlink" title="swap介绍"></a>swap介绍</h3><ul>
<li><p>swap作为STL的一部分，在算法、容器、迭代器中被广泛使用。<br>c++为用户定义了算法的默认形式如下：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; x, T&amp; y)</span></span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">tmp</span><span class="params">(x)</span></span>;</span><br><span class="line">        x = y;</span><br><span class="line">        y = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  如果类型T支持拷贝构造和拷贝赋值就可以完成交换。</p>
</li>
</ul>
<h3 id="内含指针的类型交换"><a href="#内含指针的类型交换" class="headerlink" title="内含指针的类型交换"></a>内含指针的类型交换</h3><ul>
<li><p>从上面可以看出，默认版本需要执行一次拷贝构造，两次拷贝赋值才能完成交换，如果类型内部像下面这种pimpl（内含指针，指向数据）的形式，显然只需要交换指针即可，如果采用默认版本就回降低效率。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A_impl</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    A_impl* p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; rhs)&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        *p = *(rhs.p);</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">A</span><span class="params">(<span class="type">const</span> A&amp; rhs)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>很自然地，我们可以通过函数重载来在类内自定义swap函数：</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A_impl</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">A_impl</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    A_impl* p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">A</span><span class="params">(<span class="type">const</span> A&amp; rhs)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">A</span><span class="params">(A_impl* p)</span>:p(p)&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span></span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(p, rhs.p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getVal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p -&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;A&gt;(A&amp; lhs, A&amp; rhs)&#123;</span><br><span class="line">        lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A* d1 = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="keyword">new</span> <span class="built_in">A_impl</span>(<span class="number">0</span>));</span><br><span class="line">A* d2 = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="keyword">new</span> <span class="built_in">A_impl</span>(<span class="number">3</span>));</span><br><span class="line">cout &lt;&lt; d1-&gt;<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//0</span></span><br><span class="line">cout &lt;&lt; d2-&gt;<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//3</span></span><br><span class="line"><span class="built_in">swap</span>(d1, d2);</span><br><span class="line">cout &lt;&lt; d1-&gt;<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//3</span></span><br><span class="line">cout &lt;&lt; d2-&gt;<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="swap函数重载和特化"><a href="#swap函数重载和特化" class="headerlink" title="swap函数重载和特化"></a>swap函数重载和特化</h3><ul>
<li>对于模板类，如何设计swap<br>假如我们现在有个模板类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    T val;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span></span>&#123;</span><br><span class="line">        T tmp = val;</span><br><span class="line">        val = rhs.val;</span><br><span class="line">        rhs.val = tmp;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getVal</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们希望写出它的特化版本,但是很不幸会报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">void</span> swap&lt;A&lt;T&gt;&gt;(A&lt;T&gt;&amp; lhs, A&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">        lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//error: non-class, non-variable partial specialization &#x27;swap&lt;A&lt;T&gt; &gt;&#x27; is not allowed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下我们是偏特化一个函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(A&lt;T&gt;&amp; lhs, A&lt;T&gt;&amp; rhs)</span></span>&#123;</span><br><span class="line">        lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">d1</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; d1.<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//0</span></span><br><span class="line">cout &lt;&lt; d2.<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//3</span></span><br><span class="line"><span class="built_in">swap</span>(d1, d2);</span><br><span class="line">cout &lt;&lt; d1.<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//3</span></span><br><span class="line">cout &lt;&lt; d2.<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>但是c++的std命名空间很特殊，如果不必要，尽量不要在其中添加自定义的操作。那么我们该怎么让程序调用我们自己的版本呢？很简单，定义一个非成员swap，并置于某个命名空间中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> hqin&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(A&lt;T&gt;&amp; lhs, A&lt;T&gt;&amp; rhs)</span></span>&#123;</span><br><span class="line">        lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看看我们在调用下面这个函数时会发生肾么事</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(T&amp; lhs, T&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(lhs, rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行到swap后编译器有很多不同版本可以选择：</p>
<ul>
<li>std一般化版本</li>
<li>std特化版本</li>
<li>某个命名空间中的T专属版本</li>
</ul>
<p>事实情况是编译器会优先匹配global空间或T所在命名空间中的所有T专属的版本，如果不存在就使用std特化版本，最后使用一般版本。</p>
<h3 id="swap异常"><a href="#swap异常" class="headerlink" title="swap异常"></a>swap异常</h3><ul>
<li>成员版的swap绝不可抛出异常。因为swap的一个最好的应用就是帮助class提供强烈的一场安全性保障。</li>
<li>非成员版本可以抛出异常。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/20/c++%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/20/c++%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">c++小知识点汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-20T00:00:00+08:00">2021-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:56:09" itemprop="dateModified" datetime="2022-09-25T01:56:09+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="能不能使用struct代替模板的class-x2F-typename"><a href="#能不能使用struct代替模板的class-x2F-typename" class="headerlink" title="能不能使用struct代替模板的class&#x2F;typename"></a>能不能使用struct代替模板的class&#x2F;typename</h3><p>答： c++保留struct主要为了兼容c语言，但是在c语言中是不存在模板的，所有没有必要在模板中支持struct声明模板形参。</p>
<h3 id="重复free会发生什么"><a href="#重复free会发生什么" class="headerlink" title="重复free会发生什么"></a>重复free会发生什么</h3><p>答：编译通过，运行时出错。由于free之后没有立即初始化，可能会被注入病毒。<a target="_blank" rel="noopener" href="http://d0m021ng.github.io/2017/02/24/PWN/Linux%E5%A0%86%E6%BC%8F%E6%B4%9E%E4%B9%8BDouble-free/">http://d0m021ng.github.io/2017/02/24/PWN/Linux%E5%A0%86%E6%BC%8F%E6%B4%9E%E4%B9%8BDouble-free/</a></p>
<h3 id="nullptr解决了什么问题"><a href="#nullptr解决了什么问题" class="headerlink" title="nullptr解决了什么问题"></a>nullptr解决了什么问题</h3><p>在c语言中，0可以用来表示空指针，在c++中，不允许void指针隐式转换为其他类型指针，但是允许0作为指针类型的字面值常量。因此会遇到下面这种问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用的是void func(int)这个函数，在编译时也有可能报二义性错误。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/20/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%9D%82%E8%B0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/20/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%9D%82%E8%B0%88/" class="post-title-link" itemprop="url">effective-c++系列：对象模型杂谈（1）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-20T00:00:00+08:00">2021-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:56:57" itemprop="dateModified" datetime="2022-09-25T01:56:57+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="编译器版本的默认构造-x2F-析构-x2F-赋值-x2F-拷贝构造函数"><a href="#编译器版本的默认构造-x2F-析构-x2F-赋值-x2F-拷贝构造函数" class="headerlink" title="编译器版本的默认构造&#x2F;析构&#x2F;赋值&#x2F;拷贝构造函数"></a>编译器版本的默认构造&#x2F;析构&#x2F;赋值&#x2F;拷贝构造函数</h3><ul>
<li><p>当用户没有在类内声明上述三个函数时，如果程序中需要调用，编译器会为用户自动编写<font color=green>默认构造&#x2F;析构&#x2F;拷贝构造</font>这三个重要的函数，即所谓的Big Three，和拷贝构造函数，并且这些函数都是<font color=orange>inline</font>的。在c++ 11后编译器新增了move构造和move赋值两个函数：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Handle</span> &#123;</span><br><span class="line">        T* p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Handle</span>(T* pp) : p&#123;pp&#125; &#123;&#125;</span><br><span class="line">        <span class="comment">// 用户定义构造函数： 没有隐式的拷贝和移动操作</span></span><br><span class="line">        ~<span class="built_in">Handle</span>() &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">        <span class="built_in">Handle</span>(Handle&amp;&amp; h) :p&#123;h.p&#125;<span class="comment">//移动拷贝</span></span><br><span class="line">            &#123; h.p=<span class="literal">nullptr</span>; &#125;; </span><br><span class="line">        Handle&amp; <span class="keyword">operator</span>=(Handle&amp;&amp; h) <span class="comment">//移动赋值</span></span><br><span class="line">            &#123; <span class="keyword">delete</span> p; p=h.p; h.p=<span class="literal">nullptr</span>; &#125; </span><br><span class="line">        <span class="built_in">Handle</span>(<span class="type">const</span> Handle&amp;) = <span class="keyword">delete</span>;  <span class="comment">//禁用拷贝构造函数</span></span><br><span class="line">        Handle&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Handle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ```  </span><br><span class="line">- 一旦我们显式地指明（ 声明, 定义, =<span class="keyword">default</span>, 或者 =<span class="keyword">delete</span> ）了上述五个函数之中的任意一个，编译器将不会默认自动生成move操作。  </span><br><span class="line">- 一旦我们显式地指明（ 声明, 定义, =<span class="keyword">default</span>, 或者 =<span class="keyword">delete</span> ）了上述五个函数之中的任意一个，编译器将默认自动生成所有的拷贝操作。但是，我们应该尽量避免这种情况的发生，不要依赖于编译器的默认动作。</span><br><span class="line"></span><br><span class="line">### 使用默认版本函数会发生什么？</span><br><span class="line">- 编译器产生的析构函数是none-<span class="keyword">virtual</span>的，除非<span class="keyword">class</span>的base <span class="keyword">class</span>自身声明有<span class="keyword">virtual</span>构造函数。</span><br><span class="line">- 编译器产生的构造函数和拷贝构造函数只是单纯将non-<span class="type">static</span>成员变量拷贝到目标对象，考虑一个对象内部如果存在指针，那么只是单纯地复制指针，对于指针所指的内存区域不进行拷贝，这样的浅拷贝技术可能在后续使用过程中酿成大祸。</span><br><span class="line"></span><br><span class="line">### 如何避免使用编译器自动生成的函数？</span><br><span class="line">- 如果你不想让类支持拷贝构造或者拷贝赋值函数  </span><br><span class="line">    使用<span class="keyword">private</span>关键字</span><br><span class="line">    ```cpp</span><br><span class="line">    <span class="keyword">class</span> A&#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">const</span> A&amp;);</span><br><span class="line">        A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp;);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>  继承一个不可拷贝赋值和拷贝构造的类</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  c++11后可以使用delete关键字</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;) =<span class="keyword">delete</span>;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp;) =<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基类析构函数可以是none-virtual的吗？"><a href="#基类析构函数可以是none-virtual的吗？" class="headerlink" title="基类析构函数可以是none-virtual的吗？"></a>基类析构函数可以是none-virtual的吗？</h3><ul>
<li>当基类析构函数带有多态性质，也就是使用基类指针调用子类函数的时候，析构函数必须是virtual类型的。<ul>
<li>当需要多态的时候，一般情况下需要在堆中分配内存，这样在delete的时候就存在问题：delete的是一个父类指针，但是父类析构函数不是虚函数，那么这个子类对象中子类的部分就无法释放，这样就会存在局部销毁的情况，会导致严重的资源泄露。</li>
</ul>
</li>
<li>凡是一个类中带有virtual字样的函数，一般情况下析构函数都要是虚函数。</li>
<li>当一个类不是父类的时候，析构函数尽量不要设置成虚函数。<ul>
<li>因为一个类只要有虚函数，就携带虚表指针，占用额外的内存，当类内数据量很小的时候，虚表指针就回造成很大比例的内存浪费。</li>
</ul>
</li>
</ul>
<h3 id="析构函数可以抛出异常吗？"><a href="#析构函数可以抛出异常吗？" class="headerlink" title="析构函数可以抛出异常吗？"></a>析构函数可以抛出异常吗？</h3><ul>
<li>一般情况下不要在析构函数中抛异常<br>比如在析构函数中释放多个资源，但是在释放过程中出现异常，那么剩余资源就无法被释放，就会造成内存泄露。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        <span class="comment">// throws...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;A&gt; resource;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//dtor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>异常处理<br>  捕捉异常，结束程序  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//do delete</span></span><br><span class="line">        &#125;<span class="built_in">catch</span>()&#123;</span><br><span class="line">            std::<span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  捕捉异常，不执行任何操作  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//do delete</span></span><br><span class="line">        &#125;<span class="built_in">catch</span>()&#123;</span><br><span class="line">            <span class="comment">//记录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://haoqinx.github.io/2021/08/20/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%9D%82%E8%B0%88%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/001.jpg">
      <meta itemprop="name" content="hqin">
      <meta itemprop="description" content="星海横流 岁月成碑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向自由编程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/20/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%9D%82%E8%B0%88%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">effective-c++系列：对象模型杂谈（2）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-20T00:00:00+08:00">2021-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-25 01:57:01" itemprop="dateModified" datetime="2022-09-25T01:57:01+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="在构造函数和析构函数中能调用虚函数吗？"><a href="#在构造函数和析构函数中能调用虚函数吗？" class="headerlink" title="在构造函数和析构函数中能调用虚函数吗？"></a>在构造函数和析构函数中能调用虚函数吗？</h3><ul>
<li><p>严禁在构造函数中调用虚函数</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dosome</span><span class="params">()</span><span class="type">const</span></span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        <span class="built_in">dosome</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">B b;<span class="comment">//往往会出现意想不到的错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果在父类的构造函数中调用虚函数，当使用子类对象的时候，会首先调用父类的构造函数。  </li>
<li>在父类构造函数执行过程中，this指针为base class对象，因此在dosome()函数中的操作是在父类对象中完成的。</li>
<li><font color=orange>由于虚函数dosome()在父类对象中完成，往往达不到多态（延迟绑定）的目的。</font></li>
</ul>
</li>
<li><p>严禁在析构函数中调用虚函数</p>
<ul>
<li>在子类对象析构时顺序为先将自身的local data释放，然后调用父类的析构函数，如果父类析构存在虚函数，那么编译器会有两种选择：调用虚函数的基类版本或者调用虚函数的派生类版本。</li>
<li>如果调用派生类版本的函数，此时子类部分已经释放，会导致严重错误。</li>
<li><font color=orange>实际情况是编译器会调用基类版本的虚函数，那么和构造函数一样，不会发生多态。</font></li>
</ul>
</li>
<li><p>解决方式</p>
<ul>
<li>将在构造或析构函数中调用的函数设置为non-virtual，要求子类对象在构造时传递必要的信息。</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dosome</span><span class="params">(<span class="type">const</span> string&amp; info)</span><span class="type">const</span></span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> string&amp; info)&#123;</span><br><span class="line">        <span class="built_in">dosome</span>(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> string <span class="title">createParamter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">B</span>():<span class="built_in">A</span>(<span class="built_in">createParamter</span>())&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="如果new、delete、delete-没有成对使用会发生什么？"><a href="#如果new、delete、delete-没有成对使用会发生什么？" class="headerlink" title="如果new、delete、delete[]没有成对使用会发生什么？"></a>如果new、delete、delete[]没有成对使用会发生什么？</h3><p><img src="/images/001.png">  </p>
<center>单个对象和对象数组的内存布局</center>

<ul>
<li><p>使用delete释放对象数组</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string* s = <span class="keyword">new</span> string[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="keyword">delete</span> s;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述情况下，只会调用第一个s的函数，其余99个对象不执行任何操作，后面程序也不会再拿到其句柄，从而会造成内存泄露。</li>
<li>实际上，对于一组对象，delete[]会寻找数组前的一个count计数来获取数组长度。</li>
</ul>
</li>
<li><p>使用delete[]释放单个对象</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string* s = <span class="keyword">new</span> string;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="keyword">delete</span>[] s;<span class="comment">// Exception has occurred.Segmentation fault</span></span><br></pre></td></tr></table></figure>
<ul>
<li>delete[]在内存中读取s指针前4字节内存作为数组长度，这样做显然是非法的。</li>
</ul>
</li>
</ul>
<h3 id="设计一个class需要注意什么？"><a href="#设计一个class需要注意什么？" class="headerlink" title="设计一个class需要注意什么？"></a>设计一个class需要注意什么？</h3><ul>
<li>对象创建和销毁（构造、析构函数、内存分配）</li>
<li>对象初始化和赋值</li>
<li>对象如果pass by value应该怎么做？（如果对象内存在指针，是否需要深拷贝）</li>
<li>定义class约束（数据类型检查）</li>
<li>继承或者被继承</li>
<li>类型转换（隐式类型转换）</li>
<li>操作符重载</li>
<li>标准函数是否适用（拷贝赋值，拷贝构造）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hqin"
      src="/images/001.jpg">
  <p class="site-author-name" itemprop="name">hqin</p>
  <div class="site-description" itemprop="description">星海横流 岁月成碑</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">137</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hqin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

  


</body>
</html>
