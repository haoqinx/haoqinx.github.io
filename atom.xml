<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>面向自由编程</title>
  
  
  <link href="http://haoqinx.github.io/atom.xml" rel="self"/>
  
  <link href="http://haoqinx.github.io/"/>
  <updated>2024-01-03T13:37:00.386Z</updated>
  <id>http://haoqinx.github.io/</id>
  
  <author>
    <name>hqin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://haoqinx.github.io/2023/12/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://haoqinx.github.io/2023/12/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <published>2023-12-03T13:05:27.000Z</published>
    <updated>2024-01-03T13:37:00.386Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务基本概念"><a href="#事务基本概念" class="headerlink" title="事务基本概念"></a>事务基本概念</h3><h4 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h4><ol><li>原子性：构成事务的所有操作要不全部执行成功，要么全部执行失败，不可能出现部分成功，部分失败的情况</li><li>一致性：在事务执行之前和执行之后，数据完整性约束始终保持一致的状态。（比较重要，在后面章节将重点介绍）</li><li>隔离型：并发执行的两个事务之间互不干扰。</li><li>持久性：事务对数据的更改操作将会被持久化道数据库中。<span id="more"></span></li></ol><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><h4 id="二将军问题"><a href="#二将军问题" class="headerlink" title="二将军问题"></a>二将军问题</h4><p>由于网络的不确定性，会导致一致性问题</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol><li><p>一致性：实际应用中往往会将⼀份数据复制多份进⾏存储。⼀致性是指⽤户对数据的更新操作（包括新增、修改和删除），要么在所有的数据副本都执⾏成功，要么在所有的数据副本都执⾏失败。<strong>也就是说，⼀致性要求对所有数据节点的数据副本的修改是原⼦操作</strong>。所有数据节点的数据副本的数据都是最新的，从任意数据节点读取的数据都是最新的状态。</p></li><li><p>可用性：客户端访问数据的时候，能够快速得到响应。需要注意的是，系统处于可⽤性状态时，每个存储节点的数据可能会不⼀致，并不要求应⽤程序向数据库写⼊数据时能够⽴刻读取到最新的数据。也就是说，处于可⽤性状态的系统，任何事务的操作都可以得到响应的结果，不会存在超时或者响应错误的情况。</p></li><li><p>分区容忍性：如果只是将存储系统部署并运⾏在⼀个节点上，当系统出现故障时，整个系统将不可⽤。如果将存储系统部署并运⾏在多个不同的节点上，并且这些节点处于不同的⽹络中，这就形成了⽹络分区。此时，不可避免地会出现⽹络问题，导致节点之间的通信出现失败的情况，但是，此时的系统仍能对外提供服务，这就是分区容忍性。</p></li></ol><h4 id="一些组合方式"><a href="#一些组合方式" class="headerlink" title="一些组合方式"></a>一些组合方式</h4><ol><li>AP：放弃一致性，追求系统可用性和分区容忍性。实际工作中大部分分布式系统的设计方案。</li><li>CP：放弃可用性，追求系统一致性和分区容忍性。跨行转账业务中有应用。</li><li>CA：放弃分区容忍性，追求系统一致性和可用性。一般不采用，因为分区容忍性在现在的网络架构下不会被消除。</li></ol><h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><p>分布式系统最多只能同时满⾜CAP理论中的两个特性。在实际场景中，⼤部分分布式系统会采⽤AP⽅式，即舍弃⼀致性，保证可⽤性和分区容忍性。但是通常情况下还是要保证⼀致性，这种⼀致性与CAP中描述的⼀致性有所区别：CAP中的⼀致性要求的是强⼀致性，即任何时间读取任意节点的数据都必须⼀致，⽽这⾥的⼀致性指的是最终⼀致性，允许在⼀段时间内每个节点的数据不⼀致，但经过⼀段时间后，每个节点的数据达到⼀致。</p><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><p>BASE理论是对CAP理论中AP的⼀个扩展，它通过牺牲强⼀致性来获得可⽤性。BASE理论中的Base是</p><ul><li>基本可⽤（Basically Available）</li><li>软状态（Soft State）</li><li>最终⼀致性（Eventually Consistent）</li></ul><p>当系统出现故障时，Base理论允许部分数据不可⽤，但是会保证核⼼功能可⽤；允许数据在⼀段时间内不⼀致，这种状态称为“软状态”，但是经过⼀段时间，数据最终是⼀致的。符合Base理论的事务可以称为柔性事务。</p><h4 id="一致性分类"><a href="#一致性分类" class="headerlink" title="一致性分类"></a>一致性分类</h4><p><a href="https://haoqinx.github.io/2023/11/18/%E5%BC%84%E6%B8%85%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7-md/#more">参考另一篇文章</a></p><h3 id="分布式事务分类"><a href="#分布式事务分类" class="headerlink" title="分布式事务分类"></a>分布式事务分类</h3><p>如下思维导图所示，分为柔性事务和刚性事务，刚性事务满足CP理论，柔性事务满足BASE理论。</p><p>按个人理解还可以通过数据库保证、业务保证两个层面进行分类。数据库保证表示数据库内核中实现了分布式事务的强一致性，或者提供一些接口供外部调用来保证一致性。业务保证表示通过业务层的控制来实现业务层面的一致性，无数据库本身的实现无关，本次介绍的Seata框架就是基于中间件框架去保证一致性。</p><h3 id="分布式事务解决方案-Seata"><a href="#分布式事务解决方案-Seata" class="headerlink" title="分布式事务解决方案-Seata"></a>分布式事务解决方案-Seata</h3><h5 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h5><p><img src="/images/image-20231203224216006.png" alt="image-20231203224216006"></p><ul><li>TM（Transaction Manager）:事务管理器。与TC交互，开启、提交、回滚事务，负责AT模式事务的并发控制。</li><li>RM（Resource Manager）：资源管理器。与TC交互，负责分支事务注册和分支事务状态上报。</li><li>TC（Transaction Coordinator）：事务协调器。维护全局事务和分支事务的状态，推进事务两阶段处理。</li></ul><p>TC单独作为一个服务部署、TM和聚合服务一起部署、RM和微服务一起部署，如下图。</p><p><img src="/images/image-20231203224820472.png" alt="image-20231203224820472"></p><h5 id="四大模式："><a href="#四大模式：" class="headerlink" title="四大模式："></a>四大模式：</h5><ul><li>TCC：用户根据自己的业务实现try()、confirm()、cancel()三个接口，事务发起方在一阶段之行try()、在二阶段提交执行confirm()、在二阶段回滚执行cancel()方法。</li></ul><p><img src="/images/image-20231203222946253.png" alt="image-20231203222946253"></p><ul><li>Saga：业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现。</li></ul><p><img src="/images/image-20231203223045837.png" alt="image-20231203223045837"></p><ul><li>XA：使用支持XA事务的数据库即可。</li></ul><p><img src="/images/image-20231203223211867.png" alt="image-20231203223211867"></p><ul><li>AT：Seata自创的分布式事务解决方案，业务入侵少，对数据库本身的依赖小，应用最广泛的一种策略。</li></ul><h4 id="AT模式详解"><a href="#AT模式详解" class="headerlink" title="AT模式详解"></a>AT模式详解</h4><p>假设现在有两个服务，积分服务和余额服务，余额服务负责管理用户的余额并调用积分服务，积分服务负责管理用户的积分，用户充值的时候，两个事务被声明为全局事务，AT模式的执行流程如下图所示。</p><p><img src="/images/image-20231203232303000.png" alt="image-20231203232303000"></p><h5 id="事务日志管理器"><a href="#事务日志管理器" class="headerlink" title="事务日志管理器"></a>事务日志管理器</h5><p>在AT模式中，Seata框架的数据代理源会拦截业务SQL语句，生成包含前镜像和后镜像的事务日志表（undo log），依赖的组件就是事务日志管理器。主要干下面几个事情：</p><ul><li>保存事务日志</li><li>二阶段回滚调用undo()方法</li><li>二阶段回滚后删除事务日志</li><li>二阶段提交后批量删除事务日志</li><li>根据创建时间删除事务日志</li></ul><p>以MySQL为例，创建的undo log表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>其中rollback_info字段记录了修改字段的前像和后像：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.seata.rm.datasource.undo.BranchUndoLog&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;xid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.181.2:8091:4386660905323926065&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;branchId&quot;</span><span class="punctuation">:</span> <span class="number">4386660905323926071</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sqlUndoLogs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;java.util.ArrayList&quot;</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.seata.rm.datasource.undo.SQLUndoLog&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sqlType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;INSERT&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_order&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;beforeImage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.seata.rm.datasource.sql.struct.TableRecords$EmptyTableRecords&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_order&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;java.util.ArrayList&quot;</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;afterImage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.seata.rm.datasource.sql.struct.TableRecords&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_order&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;java.util.ArrayList&quot;</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.seata.rm.datasource.sql.struct.Row&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;java.util.ArrayList&quot;</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.seata.rm.datasource.sql.struct.Field&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;keyType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY_KEY&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">31</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.seata.rm.datasource.sql.struct.Field&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;order_no&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;keyType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NULL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;63098e74e93b49bba77f1957e8fdab39&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.seata.rm.datasource.sql.struct.Field&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;keyType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NULL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.seata.rm.datasource.sql.struct.Field&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commodity_code&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;keyType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NULL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C201901140001&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.seata.rm.datasource.sql.struct.Field&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;count&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;keyType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NULL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">50</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;io.seata.rm.datasource.sql.struct.Field&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;amount&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;keyType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NULL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">100.0</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>insert操作，前镜像为空，后镜像为插入后数据</li><li>delete操作，前镜像为删除前操作，后镜像为空</li><li>update操作，前镜像为更新前操作，后镜像为更新后操作。</li></ul><p>前镜像和后镜像结合表元数据，就能执行基于业务的回滚操作了（表元数据通过seata执行一条查询语句从数据库中获得，包括主表和索引元数据） </p><p>上面的undo log是seata自动进行操作的，用户只需要在调用的方法上加一个注解。seata中使用包装类将执行SQL语句的数据源进行代理，在SQL执行前后、事务commit、rollback执行前后进行了一些与seata分布式事务相关的操作如分支事务注册、分支状态汇报、全局锁查询、事务日志插入等。</p><p><strong>从上面可以看出，如果是一个批量插入或者删除的SQL，其产生的rollback_info是非常大的，所以seata可以配置Bzip2、Gzip、lz4等压缩算法进行压缩。</strong></p><p>在本地事务提交之前，seata会把undo插入到数据库中，插入完成之后才会进行事务提交，因此只要事务提交了就一定有undo，如果数据库在undo插入之后，事务提交之前宕机了，残留的undo log也会通过过期时间进行清理。如果因为网络二将军问题，在收到二阶段回滚命令之后TC并没有收到ACK，那么由于在执行回滚之后会立即删除undo log，因此第二次执行回滚检查undo log不存在后会停止回滚。</p><h5 id="AT的隔离级别"><a href="#AT的隔离级别" class="headerlink" title="AT的隔离级别"></a>AT的隔离级别</h5><p>分布式事务的默认隔离级别都是读未提交，分布式事务的脏读和数据库的脏读在语义上不同，前者在业务中对业务是没有影响的，后者是数据库默认需要避免的。如果在实际生产环境中确实需要使用读已提交的分布式事务隔离级别，例如现在有一个广告业务，扫描订单表进行推送，当一个订单表的全局事务在本地提交之后，广告业务扫到了，但订单表的TC决定回滚，此时发生分布式事务的脏读，此时需要加入全局锁来提升隔离级别。</p><p>注意seata目前支持的SQL类型就是IUD+select…for update四种，其中select…for update默认需要申请全局锁，工作在读已提交隔离级别下面。</p><p>行锁的格式为“表名:主键1:主键2”，如果表不支持主键怎么办？Seata不支持不带主键。                                                                                                                </p><h5 id="AT的两阶段提交"><a href="#AT的两阶段提交" class="headerlink" title="AT的两阶段提交"></a>AT的两阶段提交</h5><ol><li>一阶段</li></ol><p><img src="/images/image-20231204224341291.png" alt="image-20231204224341291"></p><p>以update students set name&#x3D;’zhangsan’ where name &#x3D;’lisi’;为例，流程如下：</p><ul><li>解析SQL语句，得到SQL类型为update、表名为student，where 条件为name&#x3D;’lisi’;</li><li>开启一个数据库本地事务；</li><li>执行select id from name where name&#x3D;’list’;查找前镜像；</li><li>执行原始SQL语句；</li><li>执行select id,* from name where id&#x3D;xxx，查找后镜像；</li><li>生成事务日志和事务锁数据</li><li>注册分支事务<ul><li>如果全局锁冲突，回滚本地事务，在休眠一段时间后重新执行</li><li>无冲突则分支事务注册成功</li></ul></li><li>提交本地事务</li><li>向事务协调器汇报分支状态</li></ul><ol start="2"><li>二阶段</li></ol><p><img src="/images/image-20231204232143355.png" alt="image-20231204232143355"></p><p>这里为了性能考虑，如果提交成功不会立刻删除中间数据，而是立刻返回成功，中间数据在异步线程中进行删除。</p><p>如果提交失败，需要进行回滚操作，这里需要先对比后镜像是不是和现在数据库里面的数据一致，如果一直执行回滚，如果不一致说明发生了脏写，这个时候需要人工干预了。</p><h5 id="AT模式的全局锁"><a href="#AT模式的全局锁" class="headerlink" title="AT模式的全局锁"></a>AT模式的全局锁</h5><p>如果没有全局锁会发生什么？</p><p><img src="/images/image-20231204235132627.png" alt="image-20231204235132627"></p><p>在seata分支事务中，锁处理的流程如下：</p><ul><li>开启数据库本地事务，获取数据库锁，这个时候可以修改数据库数据，但不能修改事务信息；</li><li>通过事务协调器，获取全局锁，意味着可以修改数据并持久化。</li><li>提交本地事务，释放数据库锁。</li><li>在全局事务提交或者回滚之后是否全局锁。</li></ul><p>下面直接看一个例子来理解：</p><p>事务1和事务2都要对表的m字段进行变更</p><p><img src="/images/image-20231204234000587.png" alt="image-20231204234000587"></p><p>tx1二阶段全局提交，释放全局锁之后，tx2拿到全局锁提交本地事务。</p><p><img src="/images/image-20231204234150615.png" alt="image-20231204234150615"></p><p>如果tx1二阶段回滚，此时tx1修改数据库数据需要本地锁，而tx2需要全局锁提交事务，发生死锁，seata规定分支事务回滚会一直重试，直到tx2获取全局锁超时，发生回滚释放本地锁。特殊情况是当用户使用select…for update的时候，也需要申请全局锁，当查询的数据正在被更新则被阻塞。</p><p><img src="/images/image-20231204234541621.png" alt="image-20231204234541621"></p><p>那么这个全局锁到底存放在哪，通过什么管理的？seata有三种方式：</p><ul><li>基于数据库</li><li>基于文件实现</li><li>基于Redis实现</li></ul><p><a href="https://juejin.cn/post/7164254193362927624">基于数据库的实现</a></p><p>seata搞了一个强制放锁的逻辑，超过一定时间之后，允许别的事务抢锁，因此在释放锁的时候如果发现锁的持有者不是自己则不能释放。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;事务基本概念&quot;&gt;&lt;a href=&quot;#事务基本概念&quot; class=&quot;headerlink&quot; title=&quot;事务基本概念&quot;&gt;&lt;/a&gt;事务基本概念&lt;/h3&gt;&lt;h4 id=&quot;ACID特性&quot;&gt;&lt;a href=&quot;#ACID特性&quot; class=&quot;headerlink&quot; title=&quot;ACID特性&quot;&gt;&lt;/a&gt;ACID特性&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;原子性：构成事务的所有操作要不全部执行成功，要么全部执行失败，不可能出现部分成功，部分失败的情况&lt;/li&gt;
&lt;li&gt;一致性：在事务执行之前和执行之后，数据完整性约束始终保持一致的状态。（比较重要，在后面章节将重点介绍）&lt;/li&gt;
&lt;li&gt;隔离型：并发执行的两个事务之间互不干扰。&lt;/li&gt;
&lt;li&gt;持久性：事务对数据的更改操作将会被持久化道数据库中。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>弄清事务一致性</title>
    <link href="http://haoqinx.github.io/2023/11/18/%E5%BC%84%E6%B8%85%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7-md/"/>
    <id>http://haoqinx.github.io/2023/11/18/%E5%BC%84%E6%B8%85%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7-md/</id>
    <published>2023-11-18T11:55:43.000Z</published>
    <updated>2023-12-03T14:03:18.225Z</updated>
    
    <content type="html"><![CDATA[<h3 id="请区分这些一致性"><a href="#请区分这些一致性" class="headerlink" title="请区分这些一致性"></a>请区分这些一致性</h3><ol><li>数据库ACID中的consistency：这里的一致性是指在数据库系统中的完整性约束没有被破坏，例如主键、外键、触发器、check等约束，或者用户程序中定义的一致性条件。</li><li>CAP理论的一致性：强一致性，所有节点在同一时刻具有相同的值，都是最新的数据副本。这里的一致性其实可以看作一致性模型的一种“线性一致性”。</li><li>一致性模型：在并发编程中，系统和开发这之间的一种约定，如果开发者遵循某些规则，那么执行读操作和写操作的结果是可预测的，所谓“可预测”，对应了程序逻辑的正确性。</li></ol><p>本次阐述的一致性均代指一致性模型中的一致性。</p><span id="more"></span><h3 id="常见的几个一致性模型"><a href="#常见的几个一致性模型" class="headerlink" title="常见的几个一致性模型"></a>常见的几个一致性模型</h3><p><img src="/images/image-20231203213149207.png" alt="image-20231203213149207"></p><p>如上图所示，一致性模型具有三类，绿色代表不可用，蓝色代表基本可用，黄色代表高可用。如何理解？“不可用”表示当系统为了保证CAP中的CP时，系统将变得不可用；“基本可用”表示当系统出现故障节点时仍然可用，但是客户端不能将请求发送到不可用的副本节点；“高可用”表示当系统发生了网络分区之后，在无故障节点上依然可用。下面介绍下这几个一致性。</p><ul><li><p>线性一致性（强一致性、严格一致性、原子一致性）：最强的一致性模型，当系统从表现上看就像是只有一个节点，所有操作看起来都好像是原子的，所有操作就像是在一个全局时钟下执行的原子操作。</p></li><li><p>顺序一致性：同一个客户端或进程的操作在排序后保持先后顺序不变，执行结果符合某个顺序执行的结果。</p></li><li><p>因果一致性：必须以相同的顺序看到因果相关的操作。</p><p>微信朋友圈评论就使用了因果—致性°微信的数据分布在上海、深训、香港和加拿大数据中心。加入一个用户发表了一条朋友圈,上海的朋友和香港的朋友都来评论，这时如何保持正确性和一致性呢？</p><p>（1）每条评论都有一个唯一且单调递增的数字ID,评论ID需要全局唯—；</p><p>（2）每条新评论的ID都必须比本地已经见过的全局最大的ID大,确保因果关系；</p><p>（3）广播本地看到的所有评论和新评论到其他数据中心;相同ID的评论合并排重；</p><p>例如香港的朋友发表ID为2的评论,接着系统广播上海朋友的评论到其他数据中心上，上海朋友的多条评论ID为［1，4，7］，此时如果香港的朋友再发表评论,那么ID就要为8以维持因果顺序。评论ID合并后为［1，2，4，7，8]</p></li><li><p>最终一致性：操作之间没有因果，允许使用更宽松的一致性模型。</p></li><li><p>单调读：如果客户端读到关键字x的值为v,那么该客户端对于x的任何后续的读操作必须返回v或比v更新的值，即保证客户端不会读到旧的值。</p></li><li><p>单调写：同一个客户端（或进程）的写操作在所有副本上都以同样的‖顷序执行’即保证客户端的写操作是串行的。例如,客户端先执行写操作×＝0再执行写操作x＝1,如果另—个客户端不停地读x的值，那么会读到x的值先为0再为1，不会读到1再读到0。</p></li><li><p>读你所写：当写操作完成后，在同一副本或其他副本上的读操作必须能够读到写入的值。注意，读你所写一致性必须是单个客户端（进程）。</p></li><li><p>PARM一致性：它由单调读、单调写和读你所写三个一致性模型组成，同一个客户端的多个写操作将被所有的副本按照同样的执行顺序观察到,但不同客户端发出的写操作可以以不同的执行顺序被观察到。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;请区分这些一致性&quot;&gt;&lt;a href=&quot;#请区分这些一致性&quot; class=&quot;headerlink&quot; title=&quot;请区分这些一致性&quot;&gt;&lt;/a&gt;请区分这些一致性&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;数据库ACID中的consistency：这里的一致性是指在数据库系统中的完整性约束没有被破坏，例如主键、外键、触发器、check等约束，或者用户程序中定义的一致性条件。&lt;/li&gt;
&lt;li&gt;CAP理论的一致性：强一致性，所有节点在同一时刻具有相同的值，都是最新的数据副本。这里的一致性其实可以看作一致性模型的一种“线性一致性”。&lt;/li&gt;
&lt;li&gt;一致性模型：在并发编程中，系统和开发这之间的一种约定，如果开发者遵循某些规则，那么执行读操作和写操作的结果是可预测的，所谓“可预测”，对应了程序逻辑的正确性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本次阐述的一致性均代指一致性模型中的一致性。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库内核学习资料</title>
    <link href="http://haoqinx.github.io/2023/04/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    <id>http://haoqinx.github.io/2023/04/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</id>
    <published>2023-04-09T16:00:00.000Z</published>
    <updated>2023-11-18T14:28:44.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库开发学习资料"><a href="#数据库开发学习资料" class="headerlink" title="数据库开发学习资料"></a>数据库开发学习资料</h2><ul><li>CMU <a href="https://15445.courses.cs.cmu.edu/fall2022/">Database Systems (15-445&#x2F;645)，Andy</a> Pavlo 的数据库入门课程</li><li>CMU <a href="https://15721.courses.cs.cmu.edu/spring2020/">Advanced Database Systems (15-721)，Andy</a> Pavlo 的数据库进阶课程</li><li>课程视频均在 <a href="https://www.youtube.com/@CMUDatabaseGroup">YouTube</a></li><li>课程的配套<a href="https://github.com/cmu-db/bustub">实验代码</a></li><li>伯克利大学 <a href="https://cs186berkeley.net/">Introduction to Database Systems</a></li><li>斯坦福大学 <a href="https://web.stanford.edu/class/cs346/2015/">Database System Implementation</a></li><li>康纳尔大学 <a href="http://www.databaselecture.com/">Introduction to Database Systems</a></li><li>斯坦福大学 <a href="https://www.youtube.com/playlist?list=PLrw6a1wE39_tb2fErI4-WkMbsvGQk9_UB">MIT.6824 分布式系统</a><span id="more"></span></li></ul><h4 id="1-实战教程"><a href="#1-实战教程" class="headerlink" title="1. 实战教程"></a>1. 实战教程</h4><ul><li><a href="https://cstack.github.io/db_tutorial/">Let’s Build A Simple Database</a>，构建一个极简的数据库，C 语言实现</li><li><a href="https://github.com/talent-plan/tinykv">PingCAP TinyKV 构建一个分布式 KV 存储系统，Go 语言实现</a></li><li><a href="https://github.com/talent-plan/tinysql">PingCAP TinySQL构建一个分布式数据库，Go 语言实现</a></li><li><a href="https://github.com/chenjiandongx/mandodb">从零开始写时序数据库，Go语言实现 </a></li><li>OceanBase 的 <a href="https://github.com/oceanbase/miniob">miniob 教程，C++实现</a> </li><li><a href="https://github.com/openacid/paxoskv">200 行代码实现 Paxos KV 存储，Go 语言实现</a></li><li><a href="https://github.com/nothingax/micro-DB">关系型数据库从 0 到 1，基于 Java 的简易数据库</a></li><li><a href="https://github.com/flower-corp/minidb">从零实现极简的 bitcask KV 存储引擎，Go 语言实现</a></li><li><a href="https://github.com/skyzh/mini-lsm">mini-lsm，迷你LSM Tree 存储引擎，Rust 语言实现</a> </li><li><a href="https://github.com/auxten/go-sqldb">go-sqldb，Go语言实现的简单的关系型数据库</a> </li><li><a href="https://github.com/qw4990/NYADB2">NYADB2 Go 语言实现的简单数据库，用于学习</a></li><li><a href="https://github.com/BohuTANG/nessDB">nessDB 事务型 KV 存储，基于 Fractal-Tree，C 语言实现</a></li></ul><p>书籍</p><ul><li>斯坦福大学数据库教程：<a href="http://infolab.stanford.edu/~ullman/dscb.html">Database Systems: The Complete Book</a></li><li><a href="https://github.com/Vonng/ddia">数据密集型应用系统设计（DDIA）</a></li><li><a href="https://www.oreilly.com/library/view/database-internals/9781492040330/">数据库系统内幕</a></li><li><a href="http://webdam.inria.fr/Alice/">Foundations of Databases</a></li><li><a href="http://www.redbook.io/">Readings in Database Systems, 5th Edition</a></li><li><a href="https://www.amazon.com/dp/3030338355">Database Design and Implementation: Second Edition (Data-Centric Systems and Applications)</a></li><li><a href="https://www.amazon.com/dp/3030262529">Principles of Distributed Database Systems, 4th ed</a></li><li><a href="https://books.google.com/books?id=QoxUx8GOjKMC&printsec=frontcover&source=gbs_ge_summary_r&cad=0#v=onepage&q&f=false">Inside SQLite</a>，SQLite 内幕</li><li><a href="https://dsf.berkeley.edu/papers/fntdb07-architecture.pdf">Architecture of a Database System，数据库系统架构</a></li><li><a href="https://www.amazon.com/Relational-Optimizers-Lahdenmaki-published-Wiley-Blackwell/dp/B00EKYLFSI">Relational Database Index Design and the Optimizers</a></li><li><a href="https://www.sciencedirect.com/book/9781558605084/transactional-information-systems">Transactional Information Systems</a></li></ul><p>博客&#x2F;专栏</p><ul><li><a href="https://www.zhihu.com/column/distributed-storage">分布式和存储的那些事</a></li><li><a href="https://catkang.github.io/">CatKang 的博客</a></li><li><a href="https://ericfu.me/">CodingHusky 的博客</a></li><li><a href="https://www.codedump.info/">Codedump 的网络日志</a></li><li><a href="http://mysql.taobao.org/monthly/">数据库内核月报</a></li><li><a href="https://github.com/rxin/db-readings">db-readings</a>，关于数据库的一些论文</li><li><a href="https://postgrespro.com/blog/pgsql">PostgreSQL 内核系列文章</a></li><li><a href="https://cn.pingcap.com/blog/">PingCAP 官方博客</a></li><li><a href="https://www.infoq.cn/theme/46">数据库内核杂谈</a></li><li><a href="https://www.qtmuniao.com/">木鸟杂记</a></li><li><a href="https://bohutang.me/">虎哥的博客</a></li><li><a href="https://zhuanlan.zhihu.com/db-readings">数据系统论文阅读小组</a></li><li><a href="https://www.zhihu.com/column/presto-cn">Presto 专栏</a></li><li><a href="https://github.com/ClickHouse/clickhouse-presentations">ClickHouse 分享 PPT</a></li><li><a href="https://github.com/digoal/blog">PostgreSQL 数据库学习</a></li></ul><h4 id="2-SQL-简介"><a href="#2-SQL-简介" class="headerlink" title="2. SQL 简介"></a>2. SQL 简介</h4><ul><li>CMU 数据库课程 <a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html">Database Systems (15-445&#x2F;645)</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html#aug-26-2019">Course Introduction and the Relational Model</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html#aug-28-2019">Advanced SQL</a></li><li>UC Berkeley 数据库课程 <a href="https://cs186berkeley.net/calendar/">Introduction to Database Systems</a></li><li>Introduction + SQL I</li><li>SQL II</li><li>Relational Algebra</li><li><a href="https://learnsql.com/blog/">SQL Overview, </a>learn SQL 网站</li><li><a href="https://www.w3schools.com/sql/">SQL 语法教程，w3schools</a> 教程</li></ul><h4 id="3-关系模型-博客"><a href="#3-关系模型-博客" class="headerlink" title="3. 关系模型 博客"></a>3. 关系模型 博客</h4><ul><li><a href="https://www.oracle.com/hk/database/what-is-a-relational-database/">What is a relational database, by </a>Oracle</li><li><a href="https://www.ibm.com/topics/relational-databases">https://www.ibm.com/topics/relational-databases, by IBM</a></li><li><a href="https://careerkarma.com/blog/relational-database/">https://careerkarma.com/blog/relational-database</a></li><li><a href="https://www.geeksforgeeks.org/relational-model-in-dbms/?ref=lbp">Relation Model in DBMS, by</a> Geeks for Geeks</li><li><a href="https://www.tutorialspoint.com/dbms/er_model_to_relational_model.htm">ER Model to Relation Model</a></li></ul><p>维基百科</p><ul><li><a href="https://en.wikipedia.org/wiki/Relational_database">什么是关系型数据库</a></li></ul><h4 id="4-优化器-课程"><a href="#4-优化器-课程" class="headerlink" title="4. 优化器 课程"></a>4. 优化器 课程</h4><ul><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html">CMU Database Systems (15-445&#x2F;645)</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html#oct-14-2019">Query Planning &amp; Optimization I</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html#oct-21-2019">Query Planning &amp; Optimization II</a></li></ul><p>博客</p><ul><li><a href="https://www.infoq.cn/theme/46">数据库内核杂谈</a></li><li><a href="https://www.infoq.cn/article/GhhQlV10HWLFQjTTxRtA">数据库内核杂谈（七）：数据库优化器（上）</a></li><li><a href="https://www.infoq.cn/article/JCJyMrGDQHl8osMFQ7ZR">数据库内核杂谈（八）：数据库优化器（下）</a></li><li><a href="https://www.infoq.cn/article/5o16ehoz5zk6fzpsjpt2">数据库内核杂谈（九）：开源优化器 ORCA</a></li><li><a href="https://yq.aliyun.com/articles/610128">SQL优化器原理 - 查询优化器综述</a></li><li><a href="https://cloud.tencent.com/developer/article/1831087">深入浅出查询优化器</a></li><li><a href="https://www.zhihu.com/question/544427791/answer/2692512370">学习数据库优化器如何入手，知乎 </a>henry liang</li><li><a href="https://www.zhihu.com/column/c_1364661018229141504">优化器技术论文学习</a></li></ul><h4 id="5-Planner-Models"><a href="#5-Planner-Models" class="headerlink" title="5. Planner Models"></a>5. Planner Models</h4><p>博客</p><ul><li><a href="https://www.infoq.cn/theme/46">数据库内核杂谈</a></li><li><a href="https://zhuanlan.zhihu.com/p/48735419">SQL 查询优化原理与 Volcano Optimizer 介绍, by 张茄子</a></li><li><a href="https://zhuanlan.zhihu.com/p/73545345">Cascades Optimizer</a></li></ul><p>论文</p><ul><li>1979, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.71.3735&rep=rep1&type=pdf">Access Path Selection in a Relational Database Management System, SIGMOD</a></li><li>1979, <a href="http://15721.courses.cs.cmu.edu/spring2016/papers/p239-lehman.pdf">Query Processing in Main Memory Database Management Systems, VLDB</a></li><li>1987, <a href="http://ftp.cs.wisc.edu/pub/techreports/1987/TR693.pdf">Query Optimization by Simulated Annealing, SIGMOD</a></li><li>1988, <a href="https://people.eecs.berkeley.edu/~brewer/cs262/23-lohman88.pdf">Grammar-like Functional Rules for Representing Query Optimization Alternatives, SIGMOD</a></li><li>1993, <a href="https://pdfs.semanticscholar.org/a817/a3e74d1663d9eb35b4baf3161ab16f57df85.pdf">The Volcano Optimizer Generator- Extensibility and Efficient Search, ICDE</a></li><li>1995, <a href="https://pdfs.semanticscholar.org/360e/cdfc79850873162ee4185bed8f334da30031.pdf">The Cascades Framework for Query Optimization, IEEE Data engineering Bulltin</a> </li><li>1998, <a href="https://web.stanford.edu/class/cs345d-01/rl/chaudhuri98.pdf">An Overview of Query Optimization in Relational Systems, PODS</a></li><li>2001, <a href="http://15721.courses.cs.cmu.edu/spring2016/papers/stillger-vldb2001.pdf">LEO – DB2’s LEarning Optimizer, VLDB</a></li><li>2004, <a href="https://www.cse.iitb.ac.in/infolab/Data/Courses/CS632/2006/Papers/sigmod04-markl.pdf">Robust Query Processing through Progressive Optimization, SIGMOD</a></li><li>2014, <a href="http://15721.courses.cs.cmu.edu/spring2016/papers/p337-soliman.pdf">Orca: A Modular Query Optimizer Architecture for Big Data, SIGMOD</a></li><li>2016, <a href="http://www.vldb.org/pvldb/vol9/p660-trummer.pdf">Parallelizing Query Optimization on Shared-Nothing Architectures, VLDB </a></li><li>2016, <a href="http://www.vldb.org/pvldb/vol9/p1401-chen.pdf">The MemSQL Query Optimizer: A modern optimizer for real-time analytics in a distributed database, VLDB</a></li></ul><h4 id="6-Subquery-Optimization"><a href="#6-Subquery-Optimization" class="headerlink" title="6. Subquery Optimization"></a>6. Subquery Optimization</h4><p>博客</p><ul><li><a href="https://zhuanlan.zhihu.com/p/60380557">SQL 子查询的优化, by</a> </li><li><a href="https://www.zhihu.com/people/fuyufjh">Eric Fu</a></li><li><a href="https://zhuanlan.zhihu.com/p/62338250">Calcite 子查询处理 - I (RemoveSubQuery), by </a><a href="https://www.zhihu.com/people/loop_recur">一只无情的小猫咪</a></li><li><a href="https://zhuanlan.zhihu.com/p/66227661">Calcite 子查询处理 - II (Decorrelate), by </a><a href="https://www.zhihu.com/people/loop_recur">一只无情的小猫咪</a></li></ul><p>论文</p><ul><li>2001, <a href="https://www.comp.nus.edu.sg/~cs5226/papers/subqueries-sigmod01.pdf">Orthogonal Optimization of Subqueries and Aggregation, SIGMOD</a></li><li>2009, <a href="https://www.researchgate.net/publication/220538535_Enhanced_Subquery_Optimizations_in_Oracle">Enhanced subquery optimizations in Oracle, VLDB</a></li><li>2015, <a href="http://www.btw-2015.de/res/proceedings/Hauptband/Wiss/Neumann-Unnesting_Arbitrary_Querie.pdf">Unnesting Arbitrary Queries, BTW</a></li></ul><p>Join Order Optimization 论文</p><ul><li>2006, <a href="http://www.vldb.org/conf/2006/p930-moerkotte.pdf">Analysis of Two Existing and One New Dynamic Programming Algorithm for the Generation of Optimal Bushy Join Trees without Cross Products, VLDB</a></li><li>2015, <a href="http://www.vldb.org/pvldb/vol9/p204-leis.pdf">How Good Are Query Optimizers, Really?, VLDB</a></li><li>2018, <a href="https://db.in.tum.de/~radke/papers/hugejoins.pdf">Adaptive Optimization of Very Large Join Queries, SIGMOD</a></li></ul><h4 id="7-Functional-Dependency-amp-Physical-Properties"><a href="#7-Functional-Dependency-amp-Physical-Properties" class="headerlink" title="7. Functional Dependency &amp; Physical Properties"></a>7. Functional Dependency &amp; Physical Properties</h4><p>论文</p><ul><li><p>2000, <a href="https://cs.uwaterloo.ca/research/tr/2000/11/CS-2000-11.thesis.pdf">Exploiting Functional Dependence in Query Optimization</a></p></li><li><p>1996, <a href="https://cs.uwaterloo.ca/~gweddell/cs798/p57-simmen.pdf">Fundamental Techniques for Order Optimization, SIGMOD</a></p></li><li><p>2004, <a href="https://www.researchgate.net/publication/4084912_An_efficient_framework_for_order_optimization">An Efficient Framework for Order Optimization, ICDE</a></p></li><li><p>2010, <a href="http://www.cs.albany.edu/~jhh/courses/readings/zhou10.pdf">Incorporating Partitioning and Parallel Plans into the SCOPE Optimizer, ICDE</a></p></li></ul><h4 id="8-Cost-Model"><a href="#8-Cost-Model" class="headerlink" title="8. Cost Model"></a>8. Cost Model</h4><p>论文</p><ul><li>1996, Modelling Costs for a MM-DBMS, in Real-Time Databases</li><li>2014, <a href="https://infoscience.epfl.ch/record/219202/files/p1299-trummer.pdf">Approximation Schemes for Many-Objective Query Optimization, SIGMOD</a></li><li>2015, <a href="http://www.vldb.org/pvldb/vol8/p221-trummer.pdf">Multi-Objective Parametric Query Optimization, VLDB</a></li></ul><h4 id="9-Statistics"><a href="#9-Statistics" class="headerlink" title="9. Statistics"></a>9. Statistics</h4><p>论文</p><ul><li>1984, <a href="https://dl.acm.org/doi/pdf/10.1145/971697.602294">Accurate Estimation of the Number of Tuples Satisfying a Condition, SIGMOD </a></li><li>1993, <a href="https://dl.acm.org/doi/pdf/10.1145/169725.169708">Optimal Histograms for Limiting Worst-Case Error Propagation in the Size of Join Results, </a>ACM Trans. on Database Systems </li><li>1993, <a href="https://pdfs.semanticscholar.org/deeb/d2fa377a41de49e5556ea948191a741faa1e.pdf">Universality of Serial Histograms, VLDB </a></li><li>1995, <a href="https://dl.acm.org/doi/pdf/10.1145/223784.223841">Balancing Histogram Optimality and Practicality for Query Result Size Estimation, </a>SIGMOD </li><li>1996, <a href="https://dl.acm.org/doi/pdf/10.1145/233269.233342">Improved Histograms for Selectivity Estimation of Range Predicates, SIGMOD </a></li><li>1997, <a href="https://dl.acm.org/doi/pdf/10.1007/s007780050043?download=true">SEEKing the truth about ad hoc join costs, VLDB </a></li><li>2000, <a href="https://dl.acm.org/doi/pdf/10.1145/335168.335230">Towards Estimation Error Guarantees for Distinct Values, SIGMOD&#x2F;PODS </a></li><li>2001, <a href="http://vldb.org/conf/2001/P541.pdf">Distinct Sampling for Highly-Accurate Answers to Distinct Values Queries and Event Reports, </a>VLDB</li><li>2003, <a href="http://www.vldb.org/conf/2003/papers/S02P01.pdf">The History of Histograms, VLDB</a></li><li>2005, <a href="http://dimacs.rutgers.edu/~graham/pubs/papers/cm-full.pdf">An Improved Data Stream Summary: The Count-Min Sketch and its Applications, </a>Journal of Algorithms</li><li>2007, <a href="http://webdocs.cs.ualberta.ca/~drafiei/papers/cmm.pdf">New Estimation Algorithms for Streaming Data: Count-min Can Do More</a></li><li>2009, <a href="https://dl.acm.org/doi/pdf/10.14778/1687627.1687738">Preventing Bad Plans by Bounding the Impact of Cardinality Estimation Errors, </a>VLDB</li><li>2010, <a href="https://dl.acm.org/doi/pdf/10.1145/1807167.1807239">Histograms Reloaded: The Merits of Bucket Diversity, SIGMOD</a></li><li>2014, <a href="https://dl.acm.org/doi/pdf/10.1145/2588555.2595629">Exploiting Ordered Dictionaries to Efficiently Construct Histograms with Q-Error Guarantees in SAP HANA, </a>SIGMOD</li><li>2017, <a href="http://www.vldb.org/pvldb/vol10/p1813-zait.pdf">Adaptive Statistics in Oracle 12c, VLDB</a></li><li>2019, <a href="https://dl.acm.org/doi/pdf/10.1145/3299869.3319894">Pessimistic Cardinality Estimation: Tighter Upper Bounds for Intermediate Join Cardinalities, </a>SIGMOD </li><li>2019, <a href="http://www.vldb.org/pvldb/vol13/p279-yang.pdf">Deep Unsupervised Cardinality Estimation, VLDB </a></li><li>2020, <a href="https://vldb.org/pvldb/vol14/p61-yang.pdf">NeuroCard: One Cardinality Estimator for All Tables, VLDB</a></li></ul><p>书籍</p><ul><li><a href="https://db.cs.berkeley.edu/cs286/papers/synopses-fntdb2012.pdf">Synopses for Massive Data: Samples, Histograms, Wavelets, Sketches</a></li></ul><h4 id="10-执行引擎"><a href="#10-执行引擎" class="headerlink" title="10. 执行引擎"></a>10. 执行引擎</h4><p>课程</p><ul><li>CMU 数据库 <a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html">Introduction to Database Systems (15-445&#x2F;645), by Andy </a>Pavlo</li><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html#oct-07-2019">Query Execution I</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html#oct-09-2019">Query Execution II</a></li></ul><h4 id="11-Execution-Framework"><a href="#11-Execution-Framework" class="headerlink" title="11. Execution Framework"></a>11. Execution Framework</h4><p>博客</p><ul><li><a href="https://zhuanlan.zhihu.com/p/41562506">数据库查询引擎的进化之路，OceanBase</a></li><li><a href="https://www.qin.news/wu-li-zhi-xing-yin-qing-zhi-huo-shan-yin-qing/">物理执行引擎之火山引擎</a></li></ul><p>论文</p><ul><li>1994, <a href="https://paperhub.s3.amazonaws.com/dace52a42c07f7f8348b08dc2b186061.pdf">Volcano-An Extensible and Parallel Query Evaluation System, IEEE </a>Transactions on Knowledge and Data EngineeringFebruary</li><li>2014, <a href="https://15721.courses.cs.cmu.edu/spring2019/papers/14-scheduling/p743-leis.pdf">Morsel-Driven Parallelism: A NUMA-Aware Query Evaluation Framework for the Many-Core Age, </a>SIGMOD</li></ul><h4 id="12-Vectorization-vs-Compilation"><a href="#12-Vectorization-vs-Compilation" class="headerlink" title="12. Vectorization vs Compilation"></a>12. Vectorization vs Compilation</h4><p>博客</p><ul><li><a href="https://github.com/pivotal/blog/blob/master/content/post/codegen-gpdb-qx.md">Overhead of a Generalized Query Execution Engine, from </a>The <a href="https://github.com/pivotal/blog">Pivotal Engineering Journal</a></li></ul><p>论文</p><ul><li>2005, <a href="http://cidrdb.org/cidr2005/papers/P19.pdf">MonetDB&#x2F;X100: Hyper-Pipelining Query Execution, CIDR</a></li><li>2011, <a href="https://www.vldb.org/pvldb/vol4/p539-neumann.pdf">Efficiently Compiling Efficient Query Plans for Modern Hardware, VLDB</a></li><li>2017, <a href="http://www.vldb.org/pvldb/vol11/p1-menon.pdf">Relaxed Operator Fusion for In-Memory Databases: Making Compilation, Vectorization, and Prefetching Work Together At Last, VLDB</a></li><li>2018, <a href="http://www.vldb.org/pvldb/vol11/p2209-kersten.pdf">Everything You Always Wanted to Know About Compiled and Vectorized Queries But Were Afraid to Ask, VLDB</a></li><li>2018, <a href="https://db.in.tum.de/~leis/papers/adaptiveexecution.pdf">Adaptive Execution of Compiled Queries, ICDE</a></li></ul><h4 id="13-Join"><a href="#13-Join" class="headerlink" title="13. Join"></a>13. Join</h4><p>论文</p><ul><li>2013, <a href="http://www.vldb.org/pvldb/vol7/p85-balkesen.pdf">Multi-Core, Main-Memory Joins: Sort vs. Hash Revisited, VLDB</a></li><li>2017, <a href="http://www.vldb.org/pvldb/vol10/p889-zhu.pdf">Looking Ahead Makes Query Plans Robust, VLDB</a></li></ul><h4 id="14-Hash-Table-课程"><a href="#14-Hash-Table-课程" class="headerlink" title="14. Hash Table 课程"></a>14. Hash Table 课程</h4><ul><li>CMU <a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html">Database Systems (15-445&#x2F;645), by Andy</a> <a href="http://www.cs.cmu.edu/~pavlo/">Pavlo</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html#sep-16-2019">Hash Tables</a></li></ul><p>博客</p><ul><li><a href="https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/">Fibonacci Hashing: The Optimization that the World Forgot (or: a Better Alternative to Integer Modulo), by</a> <a href="https://probablydance.com/">Malte Skarupke</a></li><li><a href="https://databasearchitects.blogspot.com/2020/01/all-hash-table-sizes-you-will-ever-need.html">All hash table sizes you will ever need, by </a><a href="https://databasearchitects.blogspot.com/">Database Architects - Thomas Neumann</a></li></ul><h4 id="15-Bloom-Filter"><a href="#15-Bloom-Filter" class="headerlink" title="15. Bloom Filter"></a>15. Bloom Filter</h4><p>论文</p><ul><li>2018, <a href="https://www.cs.cmu.edu/~pavlo/papers/mod601-zhangA-hm.pdf">SuRF: Practical Range Query Filtering with Fast Succinct Tries, SIGMOD</a></li></ul><h4 id="16-事务"><a href="#16-事务" class="headerlink" title="16. 事务"></a>16. 事务</h4><p>隔离级别 博客</p><ul><li><a href="https://www.jianshu.com/p/3673e612cce2">一致性模型, by</a> <a href="https://www.jianshu.com/u/1yJ3ge">siddontang</a></li><li><a href="https://levelup.gitconnected.com/understanding-isolation-levels-in-a-database-transaction-af78aea3f44">Understanding Isolation Levels in a Database Transaction</a></li><li><a href="https://zhuanlan.zhihu.com/p/27035174">浅析数据库事务的隔离性</a></li><li><a href="https://zhuanlan.zhihu.com/p/117476959">MySQL 的事务隔离级别和实现原理</a></li><li><a href="https://www.infoq.cn/theme/46">数据库内核杂谈，by</a> 顾仲贤</li><li><a href="https://www.infoq.cn/article/teJA7X43BO2alp6rLCWk">事务、隔离、并发（1）</a></li><li><a href="https://www.infoq.cn/article/KyZjpzySYHUYDJa2e1fS">事务、隔离、并发（2）</a></li><li><a href="https://www.infoq.cn/article/gaOh3me9PmJBiQFD2j15">事务、隔离、并发（3）</a></li></ul><p>论文</p><ul><li>1995, <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">A Critique of ANSI SQL Isolation Levels, SIGMOD</a></li><li>2000, <a href="http://pmg.csail.mit.edu/papers/icde00.pdf">Generalized Isolation Level Definitions, Proceedings</a> of 16th International Conference on Data Engineering</li></ul><p>并发控制 课程</p><ul><li>CMU 数据库 <a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html">Database Systems (15-445&#x2F;645), by Andy</a> <a href="http://www.cs.cmu.edu/~pavlo/">Pavlo</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html#oct-23-2019">Concurrency Control Theory</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html#oct-28-2019">Two-Phase Locking Concurrency Control</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html#oct-30-2019">Timestamp Ordering Concurrency Control</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html#nov-04-2019">Multi-Version Concurrency Control</a></li><li>CMU 数据库进阶 <a href="https://15721.courses.cs.cmu.edu/spring2020/schedule.html">Advanced Database Systems (15-721), by Andy </a>Pavlo</li><li><a href="https://15721.courses.cs.cmu.edu/spring2020/schedule.html#jan-22-2020">Multi-Version Concurrency Control (Design Decisions)</a></li><li><a href="https://15721.courses.cs.cmu.edu/spring2020/schedule.html#jan-27-2020">Multi-Version Concurrency Control (Protocols)</a></li><li><a href="https://15721.courses.cs.cmu.edu/spring2020/schedule.html#jan-29-2020">Multi-Version Concurrency Control (Garbage Collection)</a></li></ul><p>论文</p><ul><li>1976, <a href="http://jimgray.azurewebsites.net/papers/on%20the%20notions%20of%20consistency%20and%20predicate%20locks%20in%20a%20database%20system%20cacm.pdf">The Notions of Consistency and Predicate Locks in a Database System, </a>Communications of the ACM</li><li>1981, <a href="https://people.eecs.berkeley.edu/~brewer/cs262/concurrency-distributed-databases.pdf">Concurrency Control in Distributed Database Systems, ACM </a>Computing Surveys</li><li>1981, <a href="https://www.eecs.harvard.edu/~htk/publication/1981-tods-kung-robinson.pdf">On Optimistic Methods for Concurrency Control, ACM </a>Transactions on Database Systems</li><li>1983, <a href="https://sites.fas.harvard.edu/~cs265/papers/bernstein-1983.pdf">Multiversion Concurrency Control - Theory and Algorithms, ACM </a>Transactions on Database Systems</li><li>2012, <a href="http://www.vldb.org/pvldb/vol4/p783-jung.pdf">Serializable Snapshot Isolation in PostgreSQL, VLDB</a></li><li>2012, <a href="http://cs.yale.edu/homes/thomson/publications/calvin-sigmod12.pdf">Calvin: Fast Distributed Transactions for Partitioned Database Systems, SIGMOD</a></li><li>2014, <a href="http://www.nawab.me/Uploads/MaaT_VLDB2014.pdf">MaaT: effective and scalable coordination of distributed transactions in the cloud, </a>VLDB</li><li>2014, <a href="http://www.vldb.org/pvldb/vol8/p209-yu.pdf">Staring into the Abyss: An Evaluation of Concurrency Control with One Thousand Cores, </a>VLDB</li><li>2014, <a href="http://www.vldb.org/pvldb/vol7/p821-ren.pdf">An Evaluation of the Advantages and Disadvantages of Deterministic Database Systems, </a>VLDB</li><li>2015, <a href="https://db.in.tum.de/~muehlbau/papers/mvcc.pdf">Fast Serializable Multi-Version Concurrency Control for Main-Memory Database Systems, </a>SIGMOD </li><li>2017, <a href="http://www.vldb.org/pvldb/vol10/p781-Wu.pdf">An Empirical Evaluation of In-Memory Multi-Version Concurrency Control, VLDB</a></li><li>2017, <a href="https://www.vldb.org/pvldb/vol10/p553-harding.pdf">An Evaluation of Distributed Concurrency Control, VLDB </a></li><li>2019, <a href="https://db.in.tum.de/~boettcher/p128-boettcher.pdf">Scalable Garbage Collection for In-Memory MVCC Systems, VLDB</a></li></ul><h4 id="17-网络"><a href="#17-网络" class="headerlink" title="17. 网络"></a>17. 网络</h4><p>课程</p><ul><li>CMU 数据库进阶 <a href="https://15721.courses.cs.cmu.edu/spring2020/schedule.html">Advanced Database Systems (15-721), by Andy </a>Pavlo</li><li><a href="https://15721.courses.cs.cmu.edu/spring2020/schedule.html#feb-19-2020">Networking Protocols</a></li></ul><p>论文</p><ul><li>2016, <a href="http://www.vldb.org/pvldb/vol9/p528-binnig.pdf">The End of Slow Networks: It’s Time for a Redesign, VLDB</a></li><li>2016, <a href="https://15721.courses.cs.cmu.edu/spring2020/papers/11-networking/li-sigmod2016.pdf">Accelerating Relational Databases by Leveraging Remote Memory and RDMA, </a>SIGMOD</li><li>2017, <a href="http://www.vldb.org/pvldb/vol10/p1022-muehleisen.pdf">Don’t Hold My Data Hostage: A Case for Client Protocol Redesign, VLDB</a></li></ul><h4 id="18-存储"><a href="#18-存储" class="headerlink" title="18. 存储"></a>18. 存储</h4><p>NoSQL 系统 书籍</p><ul><li><a href="https://www.amazon.cn/NoSQL%E7%B2%BE%E7%B2%B9-%E5%A1%9E%E5%BE%97%E6%8B%89%E5%90%89/dp/B00EEQ2GPS/ref=sr_1_1?ie=UTF8&qid=1432615573&sr=8-1&keywords=nosql">NoSQL 精粹</a></li></ul><p>博客</p><ul><li><a href="https://www.couchbase.com/resources/why-nosql/">What is NoSQL database?</a></li></ul><p>论文</p><ul><li>2006, <a href="https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf">Bigtable: A Distributed Storage System for Structured Data, OSDI</a></li><li>2007, <a href="https://sites.cs.ucsb.edu/~agrawal/fall2009/dynamo.pdf">Dynamo: Amazon’s Highly Available Key-value Store, SOSP</a></li><li>2008, <a href="https://sites.cs.ucsb.edu/~agrawal/fall2009/PNUTS.pdf">PNUTS: Yahoo!’s Hosted Data Serving Platform, VLDB</a></li><li>2010, <a href="https://www.cs.cornell.edu/projects/ladis2009/papers/lakshman-ladis2009.pdf">Cassandra - A Decentralized Structured Storage System, SOSP</a></li><li>2019, <a href="http://www.vldb.org/pvldb/vol12/p2300-cooper.pdf">PNUTS to Sherpa: Lessons from Yahoo!’s Cloud Database, VLDB</a></li></ul><h4 id="19-Buffer-管理-课程"><a href="#19-Buffer-管理-课程" class="headerlink" title="19. Buffer 管理 课程"></a>19. Buffer 管理 课程</h4><ul><li>CMU 数据库 <a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html">Database Systems (15-445&#x2F;645), by Andy</a> <a href="http://www.cs.cmu.edu/~pavlo/">Pavlo</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html#sep-11-2019">Buffer Pools</a></li></ul><p>论文</p><ul><li>1987, <a href="https://www.hpl.hp.com/techreports/tandem/TR-86.1.pdf">The 5 Minute Rule for Trading Memory for Disc Accesses and the 5 Byte Rule for Trading Memory for CPU Time, SIGMOD</a></li><li>2008, <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.227.3846&rep=rep1&type=pdf">The Five Minute Rule 20 Years Later and How Flash Memory Changes the Rules, </a>ACM Queue</li><li>2018, <a href="https://db.in.tum.de/people/sites/vanrenen/papers/HyMem.pdf?lang=de">Managing Non-Volatile Memory in Database Systems, SIGMOD</a></li><li>2018, <a href="https://db.in.tum.de/~leis/papers/leanstore.pdf">LeanStore: In-Memory Data Management Beyond Main Memory, ICDE</a></li><li>2020, <a href="http://cidrdb.org/cidr2020/papers/p29-neumann-cidr20.pdf">Umbra: A Disk-Based System with In-Memory Performance, CIDR</a></li></ul><h4 id="20-磁盘-IO-博客"><a href="#20-磁盘-IO-博客" class="headerlink" title="20. 磁盘 IO 博客"></a>20. 磁盘 IO 博客</h4><ul><li><a href="https://medium.com/databasss/on-disk-io-part-1-flavours-of-io-8e1ace1de017">On Disk IO, Part 1: Flavors of IO, thanks</a> to Alex</li><li><a href="https://medium.com/databasss/on-disk-io-part-2-more-flavours-of-io-c945db3edb13">On Disk IO, Part 2: More Flavours of IO, thanks</a> to Alex</li><li><a href="https://medium.com/databasss/on-disk-io-part-3-lsm-trees-8b2da218496f">On Disk IO, Part 3: LSM Trees, thanks</a> to Alex</li><li><a href="https://medium.com/databasss/on-disk-storage-part-4-b-trees-30791060741">On Disk IO, Part 4: B-Trees and RUM Conjecture, thanks</a> to Alex</li><li><a href="https://medium.com/databasss/on-disk-io-access-patterns-in-lsm-trees-2ba8dffc05f9">On Disk IO, Part 5: Access Patterns in LSM Trees, thanks</a> to Alex</li><li><a href="https://lwn.net/Articles/457667/">Ensuring data reaches disk(LWN)</a></li><li><a href="http://smalldatum.blogspot.com/2015/11/read-write-space-amplification-pick-2_23.html">Read, write &amp; space amplification - pick 2, thanks</a> to Mark <a href="https://twitter.com/markcallaghandb">Callaghan</a></li></ul><p>论文</p><ul><li>2016, <a href="http://scholar.harvard.edu/files/stratos/files/rum-tutorial.pdf?m=1461167186">Design Tradeoffs of Data Access Methods, SIGMOD</a></li><li>2016, <a href="https://stratos.seas.harvard.edu/files/stratos/files/rum.pdf">Designing Access Methods: The RUM Conjecture, EDBT</a></li></ul><h4 id="21-B-树"><a href="#21-B-树" class="headerlink" title="21. B+ 树"></a>21. B+ 树</h4><p>博客</p><ul><li><a href="https://www.codedump.info/post/20200609-btree-1/">B树、B+树索引算法原理（上） by </a><a href="https://www.codedump.info/">codedump</a></li><li><a href="https://www.codedump.info/post/20200615-btree-2/">B树、B+树索引算法原理（下）</a></li><li><a href="https://zhuanlan.zhihu.com/p/372830975">B-link Tree：一种 B+Tree 的并发优化</a></li><li><a href="https://zhmin.github.io/posts/blink-tree/">B+ Tree 的并发优化</a></li></ul><p>课程</p><ul><li>CMU <a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html">Database Systems (15-445&#x2F;645), by Andy</a> <a href="http://www.cs.cmu.edu/~pavlo/">Pavlo</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html#sep-18-2019">Trees Indexes I</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html#sep-23-2019">Trees Indexes II</a></li><li>CMU <a href="https://15721.courses.cs.cmu.edu/spring2020/schedule.html">Advanced Database Systems (15-721), by Andy</a> <a href="http://www.cs.cmu.edu/~pavlo/">Pavlo</a></li><li><a href="https://15721.courses.cs.cmu.edu/spring2020/schedule.html#feb-03-2020">OLTP Indexes (B+Tree Data Structures)</a></li></ul><p>论文</p><ul><li>1979, <a href="http://carlosproal.com/ir/papers/p121-comer.pdf">The Ubiquitous B-Tree</a></li></ul><p>项目</p><ul><li><a href="https://github.com/etcd-io/bbolt">boltdb</a></li><li><a href="https://github.com/sqlite/sqlite">sqlite</a></li></ul><h4 id="22-LSM-Tree"><a href="#22-LSM-Tree" class="headerlink" title="22. LSM Tree"></a>22. LSM Tree</h4><p>博客</p><ul><li><a href="https://zhuanlan.zhihu.com/p/38810568">LSM-Tree 设计</a></li><li><a href="https://zhuanlan.zhihu.com/p/389397486">浅析 LSM Tree（WiscKey，Bourbon、Rum）</a></li><li><a href="https://www.zhihu.com/column/c_1282795241104465920">LevelDB 源码剖析</a></li></ul><p>论文</p><ul><li>1996, <a href="https://www.cs.umb.edu/~poneil/lsmtree.pdf">The Log-Structured Merge-Tree (LSM-Tree),</a></li><li>2014, <a href="http://www.pandademo.com/wp-content/uploads/2017/12/A-Comparison-of-Fractal-Trees-to-Log-Structured-Merge-LSM-Trees.pdf">A Comparison of Fractal Trees to Log-Structured Merge (LSM) Trees</a></li><li>2017, <a href="https://www.usenix.org/system/files/conference/fast16/fast16-papers-lu.pdf">WiscKey: Separating Keys from Values in SSD-conscious Storage, TOS</a></li><li>2019, <a href="https://arxiv.org/pdf/1812.07527.pdf">LSM-based Storage Techniques: A Survey</a></li></ul><p>项目</p><ul><li><a href="https://github.com/google/leveldb">leveldb</a></li><li><a href="https://github.com/facebook/rocksdb">rocksdb</a></li><li><a href="https://github.com/syndtr/goleveldb">goleveldb</a></li><li><a href="https://github.com/cockroachdb/pebble">pebble</a></li><li><a href="https://github.com/dgraph-io/badger">badger</a></li></ul><h4 id="23-数据分区"><a href="#23-数据分区" class="headerlink" title="23. 数据分区"></a>23. 数据分区</h4><p>博客</p><ul><li><a href="https://pingcap.com/blog/2017-07-11-tidbinternal1/">TiDB Internal (I) - Data Storage</a></li><li><a href="https://dzone.com/articles/partitioning-behavior-of-dynamodb">Partitioning Behavior of DynamoDB, by </a>Parth<a href="https://dzone.com/users/3098371/parthmodi.html"> Modi</a></li></ul><p>论文</p><ul><li>2007, <a href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">Dynamo: Amazon’s Highly Available Key-value Store, SOSP</a></li></ul><h4 id="24-复制-x2F-一致性"><a href="#24-复制-x2F-一致性" class="headerlink" title="24. 复制&#x2F;一致性"></a>24. 复制&#x2F;一致性</h4><p>博客</p><ul><li><a href="https://dzone.com/articles/tick-or-tock-keeping-time-and-order-in-distributed-1">Tick or Tock? Keeping Time and Order in Distributed Databases, by Liu Tang</a></li><li><a href="http://thesecretlivesofdata.com/raft/">Raft 算法</a></li></ul><p>论文</p><ul><li>2012, <a href="http://www.cs.umd.edu/~abadi/papers/abadi-pacelc.pdf">Consistency Tradeoffs in Modern Distributed Database System Design</a></li><li>2020, <a href="http://pages.cs.wisc.edu/~ag/cad.pdf">Strong and Efficient Consistency with Consistency-Aware Durability, FAST 2020</a></li></ul><h4 id="25-基准测试"><a href="#25-基准测试" class="headerlink" title="25. 基准测试"></a>25. 基准测试</h4><p>博客</p><ul><li><a href="https://medium.com/@siddontang/use-go-ycsb-to-benchmark-different-databases-8850f6edb3a7">Use go-ycsb to benchmark different databases (1), by siddontang</a></li><li><a href="https://dzone.com/articles/chaos-tools-and-techniques-for-testing-the-tidb-di-1">Chaos Tools and Techniques for Testing the TiDB Distributed NewSQL Database, by Liu </a><a href="https://dzone.com/users/3186309/siddontang.html">Tang</a></li><li><a href="https://www.percona.com/blog/2019/04/25/creating-custom-sysbench-scripts/">Creating Custom Sysbench Scripts, by </a><a href="https://www.percona.com/blog/author/matthew-boehm/">Matthew Boehm</a></li></ul><p>Papers:</p><ul><li>2010, <a href="https://courses.cs.duke.edu/fall13/compsci590.4/838-CloudPapers/ycsb.pdf">Benchmarking Cloud Serving Systems with YCSB, SOCC</a></li></ul><h4 id="26-HTAP-博客"><a href="#26-HTAP-博客" class="headerlink" title="26. HTAP 博客"></a>26. HTAP 博客</h4><ul><li><a href="https://www.singlestore.com/blog/what-is-htap/">What is HTAP？, </a>single store</li><li><a href="https://www.snowflake.com/guides/htap-hybrid-transactional-and-analytical-processing">HTAP: HYBRID TRANSACTIONAL AND ANALYTICAL PROCESSING</a></li><li><a href="https://medium.com/swlh/making-an-htap-database-a-reality-what-i-learned-from-pingcaps-vldb-paper-6d249c930a11">Making An HTAP Database Reality</a></li></ul><p>论文</p><ul><li><a href="https://www.vldb.org/pvldb/vol13/p3072-huang.pdf">TiDB: A Raft-based HTAP Database</a></li><li><a href="https://pages.cs.wisc.edu/~yxy/cs839-s20/papers/htap-survey.pdf">Hybrid Transactional&#x2F;Analytical Processing: A Survey</a></li></ul><h4 id="27-其他"><a href="#27-其他" class="headerlink" title="27. 其他"></a>27. 其他</h4><ul><li><a href="https://db-engines.com/en/ranking">数据库排名</a> DB-ranking</li><li><a href="https://landscape.cncf.io/card-mode?category=database">CNCF-Database</a> 全景图</li><li><a href="https://dbdb.io/">dbdb.io</a>: 各类数据库大汇总</li><li>数据库社区：<a href="https://www.modb.pro/">墨天轮</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据库开发学习资料&quot;&gt;&lt;a href=&quot;#数据库开发学习资料&quot; class=&quot;headerlink&quot; title=&quot;数据库开发学习资料&quot;&gt;&lt;/a&gt;数据库开发学习资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CMU &lt;a href=&quot;https://15445.courses.cs.cmu.edu/fall2022/&quot;&gt;Database Systems (15-445&amp;#x2F;645)，Andy&lt;/a&gt; Pavlo 的数据库入门课程&lt;/li&gt;
&lt;li&gt;CMU &lt;a href=&quot;https://15721.courses.cs.cmu.edu/spring2020/&quot;&gt;Advanced Database Systems (15-721)，Andy&lt;/a&gt; Pavlo 的数据库进阶课程&lt;/li&gt;
&lt;li&gt;课程视频均在 &lt;a href=&quot;https://www.youtube.com/@CMUDatabaseGroup&quot;&gt;YouTube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;课程的配套&lt;a href=&quot;https://github.com/cmu-db/bustub&quot;&gt;实验代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;伯克利大学 &lt;a href=&quot;https://cs186berkeley.net/&quot;&gt;Introduction to Database Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;斯坦福大学 &lt;a href=&quot;https://web.stanford.edu/class/cs346/2015/&quot;&gt;Database System Implementation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;康纳尔大学 &lt;a href=&quot;http://www.databaselecture.com/&quot;&gt;Introduction to Database Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;斯坦福大学 &lt;a href=&quot;https://www.youtube.com/playlist?list=PLrw6a1wE39_tb2fErI4-WkMbsvGQk9_UB&quot;&gt;MIT.6824 分布式系统&lt;/a&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>计算机专业基础</title>
    <link href="http://haoqinx.github.io/2023/04/02/%E5%9F%BA%E7%A1%80%E8%B5%84%E6%96%99/"/>
    <id>http://haoqinx.github.io/2023/04/02/%E5%9F%BA%E7%A1%80%E8%B5%84%E6%96%99/</id>
    <published>2023-04-01T16:00:00.000Z</published>
    <updated>2023-04-12T14:12:39.555Z</updated>
    
    <content type="html"><![CDATA[<p>#计算机专业书籍</p><hr><p>###编程</p><ul><li>C<ol><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/C_Interfaces_and_Implementations__Techniques_for_Creating_Reusable_Software.pdf">C Interfaces and Implementations</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/C%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0.pdf">C语言接口与实现（中文版）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/C%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7.pdf">C缺陷与陷阱</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B.pdf">C专家编程</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/The%20C%20Programming%20Language%EF%BC%88%E4%B8%AD%E6%96%87%E7%AC%AC2%E7%89%88%EF%BC%89.pdf">The C Programming Language（中文第2版）</a><span id="more"></span></li></ol></li><li>C++<ol start="10"><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/C%2B%2B.Primer.Plus%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%E7%AC%AC5%E7%89%88%EF%BC%89.pdf">C++ Primer Plus（中文版第5版）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/Effective%20C%2B%2B%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%E7%AC%AC3%E7%89%88%EF%BC%89.pdf">Effective C++（中文版第3版）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/The%20C%2B%2B%20Programming%20Language.pdf">The C++ Programming Language(3rd Edition)</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%88%E4%BE%AF%E6%8D%B7%E8%AF%91%EF%BC%89.pdf">STL源码剖析（侯捷译）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.pdf">深度探索C++对象模型</a></li></ol></li><li>Linux<ol start="20"><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E6%96%87%E7%AC%AC2%E7%89%88%EF%BC%89.pdf">UNIX环境高级编程（中文第2版）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/The%20Linux%20Programming%20Interface.pdf">The Linux Programming Interface</a> </li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/UNIX%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89.pdf">UNIX编程艺术（中文）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71%EF%BC%9A%E5%A5%97%E6%8E%A5%E5%AD%97%E8%81%94%E7%BD%91API%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89.pdf">UNIX网络编程卷1：套接字联网API（第3版）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B72%EF%BC%9A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89.pdf">UNIX网络编程卷2：进程间通信（第2版）</a></li></ol></li><li>脚本<ol start="21"><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.pdf">Python 核心编程（中文第2版）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/How%20to%20Think%20Like%20a%20Computer%20Scientist--Learinig%20with%20Python.pdf">How to Think Like a Computer Scientist–Learinig with Python</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/ANSI%20Common%20Lisp%20%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E7%89%88.pdf">ANSI Common Lisp（中文版）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/%E9%AB%98%E7%BA%A7Bash%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97.pdf">高级Bash脚本编程指南</a></li></ol></li><li>调试<ol start="50"><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/Debug.Hacks%20%E6%B7%B1%E5%85%A5%E8%B0%83%E8%AF%95%E7%9A%84%E6%8A%80%E6%9C%AF%E5%92%8C%E5%B7%A5%E5%85%B7.pdf">Debug.Hacks 深入调试的技术和工具</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/01_programming/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E2%80%94%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93.pdf">程序员的自我修养—链接、装载与库</a></li></ol></li></ul><p>###算法</p><ol><li><a href="https://github.com/onestraw/ebook/blob/master/02_algorithm/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%88%E4%B8%AD%E6%96%87%E7%AC%AC2%E7%89%88%EF%BC%89.pdf">算法导论（中文第2版）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/02_algorithm/%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97%EF%BC%9A%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%A5%E7%A7%98%EF%BC%88%E4%B8%AD%E6%96%87%E7%AC%AC2%E7%89%88%EF%BC%89.pdf">算法心得：高效算法的奥秘（中文第2版）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/02_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E2%80%94C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%EF%BC%88%E4%B8%AD%E6%96%87%E7%AC%AC2%E7%89%88%EF%BC%89.pdf">数据结构与算法分析——C语言描述（中文第2版）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/02_algorithm/Data_Structures_and_Algorithm_Analysis_in_C.pdf">Data Structures and Algorithm Analysis in C</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/02_algorithm/Algorithms_on_String_Trees_and_Sequences-libre.pdf">Algorithms on Strings, Trees and Sequences</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/02_algorithm/The%20Algorithm%20Design%20Manual.pdf">The Algorithm Design Manual(2nd Edition)</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/02_algorithm/Hacker%27s%20Delight%202nd%20Edition.pdf">Hacker’s Delight(2nd Edition)</a></li></ol><p>###操作系统</p><ol><li><a href="https://github.com/onestraw/ebook/blob/master/03_operating_system/Operating%20Systems%20-%20Internals%20and%20Design%20Principles%207th.pdf">Operating Systems：Internals and Design Principles(7th Edition)</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/03_operating_system/the_design_of_the_unix_operating_system.pdf">The Design of the Unix Operating System</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/03_operating_system/UNIX%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.pdf">UNIX 操作系统设计（中文版）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/03_operating_system/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%AD%E6%96%87%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89.pdf">Linux内核设计与实现（中文第3版）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/03_operating_system/Linux.Kernel.Development.3rd.Edition.pdf">Linux Kernel Development(3rd Edition)</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/03_operating_system/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90.pdf">Linux内核源代码情景分析</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/03_operating_system/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%EF%BC%88%E4%B8%AD%E6%96%87%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89.pdf">深入理解linux内核（中文第三版）</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/03_operating_system/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B.pdf">Linux内核编程</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/03_operating_system/The%20Linux%20Kernel%20Module%20Programming%20Guide.pdf">The Linux Kernel Module Programming Guide</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/03_operating_system/Linux.Kernel.Development.3rd.Edition.pdf">Linux Device Drivers.3rd.Edition</a></li></ol><p>###网络协议</p><ol><li><a href="https://github.com/onestraw/ebook/blob/master/04_network/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B7I.pdf">TCP&#x2F;IP详解卷I</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/04_network/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B7II.pdf">TCP&#x2F;IP详解卷II</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/04_network/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B7III.pdf">TCP&#x2F;IP详解卷III</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/04_network/%E5%9B%BE%E8%A7%A3TCP_IP_%E7%AC%AC5%E7%89%88.pdf">图解TCP&#x2F;IP</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/04_network/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.pdf">HTTP权威指南</a></li></ol><p>###其它</p><ol><li><a href="https://github.com/onestraw/ebook/blob/master/09_other/How-Google-Tests-Software.pdf">How Google Tests Software</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/09_other/Google%20Hacking%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C.pdf">Google Hacking技术手册</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/09_other/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3%EF%BC%9A15%E4%BD%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%A4%A9%E6%89%8D%E5%8F%8A%E5%85%B6%E9%87%8D%E5%A4%A7%E5%8F%91%E7%8E%B0.pdf">奇思妙想：15位计算机天才及其重大发现</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/09_other/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6.pdf">黑客与画家</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/09_other/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85.pdf">浪潮之巅</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/09_other/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E.pdf">数学之美</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/09_other/%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8EBeautiful%20Code.pdf">代码之美</a></li><li><a href="https://github.com/onestraw/ebook/blob/master/09_other/%E9%AB%98%E6%95%88%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8445%E4%B8%AA%E4%B9%A0%E6%83%AF.pdf">高效程序员的45个习惯</a></li><li>[从零到一]</li></ol><p>###链接</p><ol><li><a href="https://github.com/zh-google-styleguide/zh-google-styleguide">Google编程风格指南</a></li><li><a href="http://code.google.com/p/google-styleguide/">Google style guide</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;#计算机专业书籍&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;###编程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/onestraw/ebook/blob/master/01_programming/C_Interfaces_and_Implementations__Techniques_for_Creating_Reusable_Software.pdf&quot;&gt;C Interfaces and Implementations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/onestraw/ebook/blob/master/01_programming/C%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0.pdf&quot;&gt;C语言接口与实现（中文版）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/onestraw/ebook/blob/master/01_programming/C%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7.pdf&quot;&gt;C缺陷与陷阱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/onestraw/ebook/blob/master/01_programming/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B.pdf&quot;&gt;C专家编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/onestraw/ebook/blob/master/01_programming/The%20C%20Programming%20Language%EF%BC%88%E4%B8%AD%E6%96%87%E7%AC%AC2%E7%89%88%EF%BC%89.pdf&quot;&gt;The C Programming Language（中文第2版）&lt;/a&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库的多维数据查询</title>
    <link href="http://haoqinx.github.io/2023/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%9A%E7%BB%B4%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"/>
    <id>http://haoqinx.github.io/2023/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%9A%E7%BB%B4%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</id>
    <published>2023-03-21T11:30:54.000Z</published>
    <updated>2023-03-26T14:22:40.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL中的多维数据查询"><a href="#SQL中的多维数据查询" class="headerlink" title="SQL中的多维数据查询"></a>SQL中的多维数据查询</h2><ul><li>多维数据可存储在传统的关系数据库中</li><li>需要将许多查询表达为SQL形式，例如部分匹配查询，范围查询，最近邻查询，where-am-i查询  <span id="more"></span>如：<br>SELECT*<br>FROM POINTS p<br>WHERE NOT EXISTS(<br>  SELECT &amp;<br>  FROM POINTS q<br>  WHERE (q.x - 10) * (q.x - 10) + (q.y - 20) * (q.y - 20) &lt; (p.x - 10) * (p.x - 10) + (p.y - 20) * (p.y - 20)<br>);</li><li>步骤<ul><li>在多位数据每个维度上建立B树辅助索引，给出每个维度的查询范围</li><li>根据每个维度的查询范围，利用B树找出符合条件的记录</li><li>将每个记录查询结果求交集，得出最终查询结果</li></ul></li></ul><h2 id="多维索引结构"><a href="#多维索引结构" class="headerlink" title="多维索引结构"></a>多维索引结构</h2><h3 id="类散列表方法"><a href="#类散列表方法" class="headerlink" title="类散列表方法"></a>类散列表方法</h3><h4 id="网格文件"><a href="#网格文件" class="headerlink" title="网格文件"></a>网格文件</h4><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%A4%9A%E7%BB%B4%E5%AD%98%E5%82%A8.png"><br>网格存储方式将数据按照键值对区间进行划分，在划分过程中尽量保证每个区间的数据分布均匀</p><ul><li>查找：查询每个维度分量在网格中的位置，每一维的位置决定所属的桶。</li><li>插入：遵循查找记录的过程，并把记录放到查询的桶中，如果该桶没有空间，通常有两种方法：<ul><li>添加溢出块</li><li>通过增加或移动网格先来重组结构</li></ul></li></ul><h4 id="分段散列函数"><a href="#分段散列函数" class="headerlink" title="分段散列函数"></a>分段散列函数</h4><p><img src="/images/%E5%88%86%E6%AE%B5%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0.png"></p><h3 id="类树方法"><a href="#类树方法" class="headerlink" title="类树方法"></a>类树方法</h3><h4 id="多键索引"><a href="#多键索引" class="headerlink" title="多键索引"></a>多键索引</h4><p><img src="/images/%E5%A4%9A%E9%94%AE%E7%B4%A2%E5%BC%95.png"></p><ul><li>部分查询：如果第一个属性被指定，访问效率很高，否则必须搜索子索引。</li><li>范围查询：如果索引本身在属性上支持范围查询则效率高。</li><li>最近邻查询：可以通过一系列范围查询完成。</li></ul><h4 id="kd-树"><a href="#kd-树" class="headerlink" title="kd-树"></a>kd-树</h4><p><a href="https://zh.wikipedia.org/zh-hans/K-d%E6%A0%91">wiki介绍</a><br>本质上讲就是循环以不同维度的中位数为父节点建树。</p><ul><li>部分匹配查询：处于属性已知的层的节点，可以往子树的一个方向走；处于属性未知的层的节点，要考虑两个子节点。</li><li>范围查询：范围在子节点划分值之外，考虑两个子节点，否则考虑一个。</li><li>最近邻查询：与之前相同，需要进行多次范围查询，必要时扩大查询范围。</li></ul><h4 id="四叉树"><a href="#四叉树" class="headerlink" title="四叉树"></a>四叉树</h4><p><a href="https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%8F%89%E6%A0%91">wiki介绍</a><br>本质上讲就是二叉树在二维上的扩充，每个节点的子节点分为4个方向。</p><h4 id="R-树"><a href="#R-树" class="headerlink" title="R-树"></a>R-树</h4><p><a href="https://zhuanlan.zhihu.com/p/62639268">知乎介绍</a><br><a href="https://www.cnblogs.com/cmi-sh-love/p/kong-jian-shud-ju-suo-yinRTree-wan-quan-jie-xi-jiJa.html">相关操作和实现</a></p><h3 id="位图索引"><a href="#位图索引" class="headerlink" title="位图索引"></a>位图索引</h3><p>假设关系R有n个记录，字段F有m种取值，位图索引是一个长度为n的位向量几何，该集合有m个元素，对于F的任意一个取值v，对应的n位向量记为v，对于记录ri，如果ri[F]&#x3D;v，那么vi&#x3D;1，否则vi&#x3D;0。<br><img src="/images/%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95.png"></p><ul><li>部分匹配查询：使用位向量与操作即可</li><li>范围查询：同属性或，不同属性循环与<br>位图压缩：位图中有很多0，浪费空间，可以采用压缩位图来存储</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;SQL中的多维数据查询&quot;&gt;&lt;a href=&quot;#SQL中的多维数据查询&quot; class=&quot;headerlink&quot; title=&quot;SQL中的多维数据查询&quot;&gt;&lt;/a&gt;SQL中的多维数据查询&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;多维数据可存储在传统的关系数据库中&lt;/li&gt;
&lt;li&gt;需要将许多查询表达为SQL形式，例如部分匹配查询，范围查询，最近邻查询，where-am-i查询</summary>
    
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CMU-cs445:Undo &amp;&amp; Redo</title>
    <link href="http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E6%97%A5%E5%BF%97%E5%92%8C%E5%A4%87%E4%BB%BD/"/>
    <id>http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E6%97%A5%E5%BF%97%E5%92%8C%E5%A4%87%E4%BB%BD/</id>
    <published>2022-09-24T17:40:36.326Z</published>
    <updated>2022-10-19T09:12:46.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Undo-amp-Redo"><a href="#Undo-amp-Redo" class="headerlink" title="Undo &amp; Redo"></a>Undo &amp; Redo</h3><ul><li>Undo:移除一个终止的事务的影响</li><li>Redo：重新执行一个事务进行持久化<span id="more"></span></li><li>Steal Policy<br>允许未提交的事务回写到磁盘</li><li>Force Policy<br>要求所有事务提交之前必须回写到磁盘</li><li>No Steal + Force<ul><li>Shodow Paging<br><img src="/images/db-43.png"></li></ul></li><li>Steal + No Force<ul><li>write-ahead log<br><img src="/images/db-44.png"><br> 什么时间提交这些日志条目？<ul><li>事务提交时</li><li>组提交，这时会出现未提交事务的条目，但是不影响。</li></ul></li></ul></li><li>Logging Schemes<ul><li>Physical</li><li>Logical</li><li>Physiological<br><img src="/images/db-45.png"></li></ul></li><li>CheckPoints<br>使用预写日志，为了避免恢复时间过长，在某个时间点将所有脏页面持久化到磁盘。写入一个Checkpoint条目。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Undo-amp-Redo&quot;&gt;&lt;a href=&quot;#Undo-amp-Redo&quot; class=&quot;headerlink&quot; title=&quot;Undo &amp;amp; Redo&quot;&gt;&lt;/a&gt;Undo &amp;amp; Redo&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Undo:移除一个终止的事务的影响&lt;/li&gt;
&lt;li&gt;Redo：重新执行一个事务进行持久化</summary>
    
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CMU-cs445:查询引擎实现</title>
    <link href="http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-09-24T17:40:36.326Z</published>
    <updated>2022-10-19T09:12:14.349Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li>数据库中的table不能完全放到内存中</li><li>计算得到的中间结果不能完全放入内存中<span id="more"></span></li></ul><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><ul><li>外部排序（多路归并排序）<ul><li>读取B个page到内存，对page排序并且回写到磁盘</li><li>使用prefetch预读加速</li></ul></li><li>B+树<ul><li>如果需要排序的key作为b+树存储，可以复用b+树</li><li>只能在聚簇索引（物理相邻）的b+树上使用，因为如果不是聚簇索引，每次获得数据都需要一次磁盘io</li></ul></li></ul><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><ul><li>排序聚合</li><li>非排序聚合<ul><li>external hashing aggregate<br>  <img src="/images/db-7.png"></li></ul></li></ul><h3 id="Join操作"><a href="#Join操作" class="headerlink" title="Join操作"></a>Join操作</h3><ul><li><p>data在查询语法树中的传递</p><ul><li>一个常规做法是将两个表所有属性拷贝到新表中，这样下面的操作不必再考虑前面的数据，也就是不用再到磁盘中进行retrieve.</li><li>另一种方法是指穿入我们所需的最小限度信息（join keys）.然后根据这些信息在后面的操作总从数据库中获取tuple的其他数据.这种方法叫做late materialization，对于列式存储比较友好，因为不用将其他列的信息粘合起来，这些信息通常位于不同的page中。现在这种优化很少，因为数据的获取（第一阶段）的代价通常很大。</li></ul></li><li><p>Nested Loop Join<br>  <img src="/images/db-8.png"><br>  <img src="/images/db-9.png"><br>  这是一种非常暴力的方法，一种优化手段是block nested loop join，这种方法把outter table的tuple缓存，减少了对inner table的io次数。<br>  <img src="/images/db-10.png"><br>  <img src="/images/db-11.png"><br>  另一种优化手段是index nested loop join，在内循环中去查询索引，这样避免了遍历操作，是O（logn）的复杂度，但是如果要查询的索引不是聚簇索引，还需要一次回表操作。<br>  <img src="/images/db-12.png"></p></li><li><p>Sort-Merge Join<br>  首先是对需要join的key(s)进行排序，然后利用两个游标在两个有序表上进行匹配。<br>  <img src="/images/db-13.png"></p></li><li><p>Hash Join<br>  原理就是对两个表中需要join的那个值进行hash操作，那么相同的值肯定会映射到一个partition中，我们每次只需要在一个partition中进行比较就行了。<br>  <img src="/images/db-14.png"><br>  在分布式场景下，可能两个表存在不同的主机上，那么传递哈希表是一个非常消耗资源的事，一个优化手段是使用布隆过滤器，布隆过滤器通常只有几kb大小，非常容易在主机之间进行网络通信，在建立第一个表的哈希表的时候填充布隆过滤器，那么我们对第二个表进行哈希的时候，可以直接判断是否存在。<br>  哈希之后的数据量可能非常大，不能放在内存中，因此我们可以使用Grace Hash Join优化。<br>  <img src="/images/db-15.png1"><br>  也就是分别对两个表进行哈希，然后对每对bucket进行Nested Loop Join，如果bucket也不能完全放到内存中，那就再进行一次哈希，递归进行。<br>  <img src="/images/db-16.png"></p></li><li><p>总结<br>  <img src="/images/db-17.png"></p></li></ul><h3 id="处理模型（processing-model）"><a href="#处理模型（processing-model）" class="headerlink" title="处理模型（processing model）"></a>处理模型（processing model）</h3><ul><li><p>迭代模型（Iterator Model）<br>  <img src="/images/db-18.png"><br>  每一个查询操作符都实现一个Next函数，函数调用其子节点的Next函数。Next每次处理一个tuple数据，需要迭代所有tuple才能完成所有操作。<br>  一些操作符必须获得所有子节点的tuple，例如Joins，Subqueries，Order By</p></li><li><p>Materialization Model<br>  不同于迭代模型，每次子节点都将整个结果传递给上层<br>  <img src="/images/db-19.png"><br>  在OLTP中进行点查询，这种方式比较高效，但是在OLAP中存在大量的中间结果，会产生锁延时，并且对于含有LIMIT的查询，如果数据量很大，每次传递给上层所有数据，这种资源消耗是不必要的。</p></li><li><p>Vectorization Model<br>  对迭代模型的优化，每次不是产生一个tuple，而是产生一个batch的tuple.<br>  <img src="/images/db-20.png"><br>  这种方式能够使用SIMD技术对数据进行分析计算，对于OLAP非常友好</p></li></ul><h3 id="Access-Method"><a href="#Access-Method" class="headerlink" title="Access Method"></a>Access Method</h3><ul><li>Sequential Scan<br>  普通遍历，对每页的tuple基于cursor做遍历，这通常效率非常低，有一些优化：预读，Buffer Pool Bypass，并行化，Zone Maps，Late Materialization，Heap CLustering<ul><li>Zone Maps：预先对page中的数据做聚合计算，DBMS在访问page的时候先去检查这些字段，如果不需要访问就直接跳过这个page<br>  <img src="/images/db-21.png"></li><li>Late Materialization：在列式存储数据库中，由于数据被按列存储到不同的page中，那么在每次opertaor之后，不用将整个tuple传给上层，直接传tuple对应的offset值，然后到root节点再到不同page中获取每一列的值。</li></ul></li><li>Index Scan<ul><li>Multi-Index Scan：通过不同的索引进行多次查找，基于我们的判断在对结果进行合并<br>  <img src="/images/db-22.png"></li><li>非聚簇索引的随机IO问题：对于非聚簇索引，我们可以不去一一随机IO，我们先将要访问的page id记录下来排序然后去一次访问page，拿到所有需要的tuple.</li></ul></li></ul><h3 id="表达式评估（Expression-Evaluation）"><a href="#表达式评估（Expression-Evaluation）" class="headerlink" title="表达式评估（Expression Evaluation）"></a>表达式评估（Expression Evaluation）</h3><p>DBMS将WHERE语句转化成一个expression tree<br><img src="/images/db-23.png"><br>每次遇到一个tuple，去匹配这个树，这样的话效率很低。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;关键点&quot;&gt;&lt;a href=&quot;#关键点&quot; class=&quot;headerlink&quot; title=&quot;关键点&quot;&gt;&lt;/a&gt;关键点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数据库中的table不能完全放到内存中&lt;/li&gt;
&lt;li&gt;计算得到的中间结果不能完全放入内存中</summary>
    
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CMU-cs445:数据存储表示</title>
    <link href="http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AD%98%E5%82%A8%E4%BA%8C%E8%A1%A8%E7%A4%BA/"/>
    <id>http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AD%98%E5%82%A8%E4%BA%8C%E8%A1%A8%E7%A4%BA/</id>
    <published>2022-09-24T17:40:36.325Z</published>
    <updated>2022-10-19T09:12:32.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2><pre><code>涉及浮点数和定点数的存储，不同的是我们需要更多的信息去记录浮点数，包括字符串形式的数据以及其他辅助信息，运算过程为字符串相加相乘类似。</code></pre><span id="more"></span><h2 id="大数据表示"><a href="#大数据表示" class="headerlink" title="大数据表示"></a>大数据表示</h2><pre><code>当需要存储的数据大于单页大小，有以下解决方案- overflow page：存储指向overflow page的指针，如果仍然无法全部存储，就形成链表结构。通常比较难以维护，包括overflow page上的元信息。- 外部存储：数据库存一个文件路径。缺点是无法受到数据库保护。</code></pre><h2 id="catalogs"><a href="#catalogs" class="headerlink" title="catalogs"></a>catalogs</h2><pre><code>存储表，列，索引，视图，用户，权限，内部的统计信息等</code></pre><h2 id="workload"><a href="#workload" class="headerlink" title="workload"></a>workload</h2><pre><code>- OLTP(On-line Transaction Processing)    简单查询，每次读取或者更新数据库中很小一部分数据-  OLAP(On-line Analytical Processing)复杂查询，常常读取分析大批量数据</code></pre><h2 id="tuple存储形式"><a href="#tuple存储形式" class="headerlink" title="tuple存储形式"></a>tuple存储形式</h2><pre><code>- N-array tuple以行的形式存储    - 优点:插入更新删除快，对需要整个tuple的查询友好    - 缺点:对于全表扫描或者tuple一部分字段的查询不友好- Column store：每页存储相同字段的值。    - 优点:可以对数据进行压缩，降低字段查询时的系统io。    - 缺点:小数据的增删改查比较费时</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据表示&quot;&gt;&lt;a href=&quot;#数据表示&quot; class=&quot;headerlink&quot; title=&quot;数据表示&quot;&gt;&lt;/a&gt;数据表示&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;涉及浮点数和定点数的存储，不同的是我们需要更多的信息去记录浮点数，包括字符串形式的数据以及其他辅助信息，运算过程为字符串相加相乘类似。
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CMU-cs445:存储引擎</title>
    <link href="http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AD%98%E5%82%A8%E4%B8%80%E5%B8%83%E5%B1%80/"/>
    <id>http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AD%98%E5%82%A8%E4%B8%80%E5%B8%83%E5%B1%80/</id>
    <published>2022-09-24T17:40:36.325Z</published>
    <updated>2022-10-19T09:12:36.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储层次"><a href="#存储层次" class="headerlink" title="存储层次"></a>存储层次</h2><p><img src="/images/db-1.png"></p><ul><li>tips：在数据库存储上尽量不要使用mmap，这会带来内存&#x2F;并发等一系列问题，会成为系统瓶颈。<span id="more"></span></li></ul><h2 id="页式存储引擎"><a href="#页式存储引擎" class="headerlink" title="页式存储引擎"></a>页式存储引擎</h2><ol><li>页<br> a. 数据往往存储在以页为单位的空间中，页中包含元数据&#x2F;索引&#x2F;表数据，有的数据库将元数据和对应的表数据存放在一起，为了保证其他页丢失的情况下本页不受影响。<br> b. 通常一页不会存放不同类型的数据，例如某页都是tuple，另一页全都是索引数据.<br> c. 每个page会被赋予一个唯一的内部标识符，系统会生成属于page的ID.<br> d. indirection层会吧page id映射到某个文件的某个位置（也就是记录一个相对位置，当文件整体移动后，使用相对位置+偏移量就能重新找到page）<br> e. 物理页和操作系统页都在4kb左右，数据库的页在512b～16kb</li><li>管理页的方式<br> a. Heap File Organization<br> b. Sequential&#x2F;sorted File Organization<br> c. Hashing File Organization</li><li>Heap File管理方式<br> heap file是许多页的无序集合，有两种组织形式：链表和页目录<ul><li>链表管理就是定义两个链表，一个数据链表表示都是存满的数据页，另一个时空闲链表，用来新写入数据。</li><li>页目录管理：使用一些特殊的页记录数据页page id和他的位置的映射关系，甚至可以记录页的剩余空间的大小。</li></ul></li><li>页头（page header）<ul><li>page size</li><li>checksum</li><li>DBMS version</li><li>transaction Visibility</li><li>压缩信息</li></ul></li><li>页内tuple布局<ul><li>长度固定方法：每个tuple固定长度</li><li>slotted pages：如下图所示，为了支持可变长度的记录作出的妥协。<br> <img src="/images/db-2.png"></li></ul></li><li>tuple布局<br> <img src="/images/db-3.png"><ul><li>header：Visibility info（并发控制信息），Bit Map for NULL values.header并不需要存储数据的元数据，因为他们都是按顺序记录的。</li><li>record数据按定义时顺序写入</li></ul></li></ol><h2 id="日志式文件布局"><a href="#日志式文件布局" class="headerlink" title="日志式文件布局"></a>日志式文件布局</h2><pre><code>![](/images/db-3.png)通过追加命令的方式记录信息，有点像redis的rdb模式比较出名的有leveldb，基于leveldb，移除其mmap的rocksdb等。</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;存储层次&quot;&gt;&lt;a href=&quot;#存储层次&quot; class=&quot;headerlink&quot; title=&quot;存储层次&quot;&gt;&lt;/a&gt;存储层次&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/db-1.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tips：在数据库存储上尽量不要使用mmap，这会带来内存&amp;#x2F;并发等一系列问题，会成为系统瓶颈。</summary>
    
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CMU-cs445:查询优化</title>
    <link href="http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <id>http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</id>
    <published>2022-09-24T17:40:36.325Z</published>
    <updated>2022-10-19T09:12:19.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><ul><li><p>Heuristics&#x2F;Rules 规则&#x2F;静态触发</p><span id="more"></span><p>当查询中的某些部分满足我们的规则或者条件，我们就重写这部分.这部分需要我们去检查catelog.</p></li><li><p>Cost-based Search</p></li></ul><p>方法的思想是使用一个模型去评估一个查询的负载，然后使用多种不同的查询计划去替换这个查询，找出最小负载的方案。</p><p>下面是整个查询优化过程<br><img src="/images/db-26.png"></p><h3 id="Relational-Algebra-Equivalences-等价关系代数"><a href="#Relational-Algebra-Equivalences-等价关系代数" class="headerlink" title="Relational Algebra Equivalences(等价关系代数)"></a>Relational Algebra Equivalences(等价关系代数)</h3><ul><li>predicate pushdown:在join前尽量过滤数据。</li><li>对过滤条件进行排序，让更具有分辨性的条件排在前面。</li><li>对复杂判断进行简化</li><li>对于行存储类型数据库，projection越早越好。</li></ul><h3 id="Plan-Cost-Estimation"><a href="#Plan-Cost-Estimation" class="headerlink" title="Plan Cost Estimation"></a>Plan Cost Estimation</h3><ul><li>CPU</li><li>磁盘</li><li>内存</li><li>网络</li></ul><p>在数据库的catelog中，会维护相关信息，并且在特定时间或者遍历表的时候更跟这些信息，在执行查询之前，将这些变量带入公式，计算出最小代价的查询。在系统中，我们定义一些统计量：</p><ul><li>$N_R$: 关系R的tuple数量</li><li>V(A,R):属性A不同值的数量</li><li>Selection Cardinality：$N_R$&#x2F;V(A,R)</li><li>selectivity: 选择率，给定一个条件，计算table中符合条件的tuple数量</li><li>Range Predicate：计算范围值的比例，有点像概率计算，因此可以引入概率论中的结论,但是为了计算方便，有下面三个前提：<br><img src="/images/db-27.png"></li></ul><h5 id="直方图法"><a href="#直方图法" class="headerlink" title="直方图法"></a>直方图法</h5><p>对于数据分布不均匀的关系，在一些高端数据库中会使用直方图来跟踪数据的分布。对于数据量极大或者属性值分布很广的情况，我们会使用相同宽度的<strong>bucket</strong>来记录值的分布，但是这种情况会导致某个桶内数据分布极不均匀的情况，我们可以使用<strong>分位数</strong>来解决这个问题，即累计一定比例的数据分桶，桶的宽度可变，但是总体占比大致相当。</p><h5 id="采样法"><a href="#采样法" class="headerlink" title="采样法"></a>采样法</h5><p>对于直方图，其实是对表中数据的一种缩略表达，那么在大数据量的table中，我们可以直接采样来近似代表整个表的数据分布。当表进行大规模更新或者到达一个指定时间点，我们去更新这个采样表。</p><h3 id="Plan-Enumeration"><a href="#Plan-Enumeration" class="headerlink" title="Plan Enumeration"></a>Plan Enumeration</h3><h5 id="单关系查询计划"><a href="#单关系查询计划" class="headerlink" title="单关系查询计划"></a>单关系查询计划</h5><ul><li>循序遍历</li><li>二分查找（对于聚集索引）</li><li>索引遍历</li></ul><h5 id="多关系查询计划"><a href="#多关系查询计划" class="headerlink" title="多关系查询计划"></a>多关系查询计划</h5><ul><li><p>left-deep join tree<br><img src="/images/db-28.png"><br>在上面三个查询树中，System R不考虑后面两个，只考虑第一种。为什么采用第一种？后面两种实现过程中会有大量结果溢出到磁盘，影响性能。</p></li><li><p>步骤（System R based）<br><img src="/images/db-29.png"></p></li><li><p>步骤（遗传算法）<br><img src="/images/db-30.png"></p></li></ul><h3 id="Nested-Sub-queries"><a href="#Nested-Sub-queries" class="headerlink" title="Nested Sub-queries"></a>Nested Sub-queries</h3><p>通常情况下将where作为函数，穿入参数然后返回一组值，有两种方法进行查询优化：</p><ul><li>重写查询，去除关联性，让其扁平化</li><li>将内部查询提取出来作为单独查询来执行，将结果缓存起来，这样不用每次执行上层查询都再执行一次子查询</li></ul><p>(<a href="https://dbdb.io/">https://dbdb.io/</a>)</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;查询优化&quot;&gt;&lt;a href=&quot;#查询优化&quot; class=&quot;headerlink&quot; title=&quot;查询优化&quot;&gt;&lt;/a&gt;查询优化&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Heuristics&amp;#x2F;Rules 规则&amp;#x2F;静态触发&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CMU-cs445:查询执行</title>
    <link href="http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"/>
    <id>http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/</id>
    <published>2022-09-24T17:40:36.325Z</published>
    <updated>2022-10-19T09:12:27.414Z</updated>
    
    <content type="html"><![CDATA[<h3 id="并行处理模型"><a href="#并行处理模型" class="headerlink" title="并行处理模型"></a>并行处理模型</h3><ul><li>Process per DBMS Worker<ul><li>使用一个进程处理一个请求</li><li>使用共享内存对全局数据进行共享，如buffer pool，不用将相同的page加载两次</li><li>单进程奔溃不会导致整个系统崩溃</li></ul></li><li>Process Pool<ul><li>使用进程池来处理请求</li><li>对cpu缓存不友好</li><li>减少了创建销毁进程开销</li></ul></li><li>Thread per DBMS Worker<ul><li>单进程多线程</li><li>线程崩溃导致进程崩溃</li><li>上下文切换开销很小</li><li>不需要管理共享内存<span id="more"></span></li></ul></li></ul><h3 id="并行查询方式"><a href="#并行查询方式" class="headerlink" title="并行查询方式"></a>并行查询方式</h3><ul><li><p>Inter-Query：同时执行多个查询</p></li><li><p>Intra-Query：同时执行一个查询的多个operator，一般有三种，注意下main这三种不是互斥的，他们可以相互组合。</p><ul><li>Intra-Operator（Horizontal）：将完整的操作拆分成多个平行的操作，也就是说把我们要处理的数据分成几段，并行处理，在DBMS中有一个特殊的exchange操作符，将数据分段，分别处理数据，然后最后将数据组合起来。exchange有三种类型：<ul><li>Gather：组合不同worker的数据合并成一个输出流传给上层操作符。</li><li>Repartition：将不同worker的数据分成不同的流，如group by</li><li>Distribute：将一个输入流转化成多个输出流<br>  <img src="/images/db-24.png"></li></ul></li><li>Inter-Operator（Vertical）：不同线程同一时间执行不同的operator.<br>  <img src="/images/db-25.png"></li><li>Bushy</li></ul></li></ul><h3 id="IO并行"><a href="#IO并行" class="headerlink" title="IO并行"></a>IO并行</h3><ul><li>multi-disk 并行：使用多个冗余磁盘存储相同的数据</li><li>database partitioning：将数据分成不相交的子集，分别存储在物理磁盘上单独管理<ul><li>垂直分区：将数据按照列进行分区</li><li>水平分区：将数据按照行进行分区</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;并行处理模型&quot;&gt;&lt;a href=&quot;#并行处理模型&quot; class=&quot;headerlink&quot; title=&quot;并行处理模型&quot;&gt;&lt;/a&gt;并行处理模型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Process per DBMS Worker&lt;ul&gt;
&lt;li&gt;使用一个进程处理一个请求&lt;/li&gt;
&lt;li&gt;使用共享内存对全局数据进行共享，如buffer pool，不用将相同的page加载两次&lt;/li&gt;
&lt;li&gt;单进程奔溃不会导致整个系统崩溃&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Process Pool&lt;ul&gt;
&lt;li&gt;使用进程池来处理请求&lt;/li&gt;
&lt;li&gt;对cpu缓存不友好&lt;/li&gt;
&lt;li&gt;减少了创建销毁进程开销&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Thread per DBMS Worker&lt;ul&gt;
&lt;li&gt;单进程多线程&lt;/li&gt;
&lt;li&gt;线程崩溃导致进程崩溃&lt;/li&gt;
&lt;li&gt;上下文切换开销很小&lt;/li&gt;
&lt;li&gt;不需要管理共享内存</summary>
    
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CMU-cs445:并发控制</title>
    <link href="http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <id>http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</id>
    <published>2022-09-24T17:40:36.324Z</published>
    <updated>2022-10-19T09:12:10.554Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul><li>A:原子性</li><li>C:如果事务是一致的，数据库是一致的，那么结束时也必须是一致的</li><li>I:隔离性</li><li>D:事务提交之后会持久化<span id="more"></span></li></ul><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul><li>Logging<br>记录所有动作到undo log</li><li>Shadow Paging<br>事务运行的时候，拷贝那些用到的page，然后在上面执行事务，当事务提交后，用这些page替换原来的page</li></ul><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><ul><li>数据库一致性</li><li>事务一致性<br><a href="https://www.zhihu.com/question/31346392">https://www.zhihu.com/question/31346392</a></li></ul><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>多个事务同时执行时，每个事务无法读到别的事务的中间结果。</p><ul><li>不可重复读</li><li>脏读</li><li>Overwriting Uncommited Data<br><img src="/images/db-31.png"></li></ul><p>如何判断两个事务存在冲突？</p><ul><li>依赖图</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li>锁的类型<ul><li>共享锁</li><li>排他锁</li></ul></li><li>锁控制协议：两阶段锁<ul><li>Growing（增长阶段）<br>每个事务被允许从锁管理器中获得锁。</li><li>Shrinking（收缩阶段）<br>事务只被允许释放前面获得的锁，不能申请新的锁。<br>两阶段锁可以消除序列化矛盾，但是会存在级联终止问题。如下图<br><img src="/images/db-32.png"><br>要解决上面这个问题，需要使用强严格两阶段锁，也就是说我们必须在事务提交的时候才能释放之前获得的锁，这样就能避main脏读和级联终止。<br>两阶段锁也会导致死锁，如下图：<br><img src="/images/db-33.png"><br>有两种方法解决死锁问题</li></ul></li><li>检测<br>锁管理器维护一个waits-for图，用来追踪每个事务等待要获取的锁，每个节点是一个事务，如果事务A正在等待事务B的锁，他们之间就有一个箭头，当存在环形结构就说明存在死锁。<br><img src="/images/db-34.png"><br>检测周期可以设置一个可容忍的系统值。</li><li>处理<br>选择一个事务，回滚，选择的标准可以是：<ul><li>时间戳</li><li>查询数</li><li>被锁住的item数量</li><li>需要回滚的事务数量</li></ul></li><li>预防<br>根据时间来确定优先级<ul><li>Wait-Die<br>如果请求锁的事务优先级高于持有锁的事务，那么等待持有锁的事务，否则终止。</li><li>Wound-Wait<br>如果请求锁的事务优先级高于持有锁的事务，那么持有锁的事务终止并且释放锁，否则请求锁的事务等待。<br><img src="/images/db-35.png"><br>当事务重启之后，其优先级（也就是时间戳）是它原本的时间戳，这有助于避免此事务饥饿。</li></ul></li><li>锁的层次<br><img src="/images/db-36.png"><br>数据库中有成千上万个tuple，我们不能直接管理这些，因此我们需要一些更高层次的抽象锁，让我们同一时间管理更少的锁。<ul><li>意向锁<ul><li>意向共享锁（IS）</li><li>意向排他锁（IX）</li><li>共享锁（S）</li><li>排他锁（X）</li><li>共享意向排他锁（SIX）<br><img src="/images/db-37.png"></li></ul></li></ul></li></ul><h3 id="基于时间戳顺序的控制"><a href="#基于时间戳顺序的控制" class="headerlink" title="基于时间戳顺序的控制"></a>基于时间戳顺序的控制</h3><p>基于两阶段锁是一种悲观锁，基于时间戳顺序是一种乐观锁。<br>我们需要向每个tuple添加两个时间戳：</p><ul><li>写时间戳：最近对tuple写的事务的时间戳</li><li>读时间戳：最近对tuple读的事务的时间戳<br>在读阶段，确保自己的时间戳不小于tuple的写时间戳，在写阶段，要确保事务的时间戳小于tuple的写时间戳和读时间戳。有一种优化叫做托马斯写入规则：<br><img src="/images/db-38.png"></li></ul><p>基于时间戳的并发控制是不可恢复的。如果事务大多时间很短并且不会发生冲突，那么可以考虑这种病发控制协议。</p><ul><li>乐观并发控制协议<br><a href="https://blog.csdn.net/BOBOyspa/article/details/121131474">偷懒，看下别人的总结</a></li></ul><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><ul><li>并发控制协议<ul><li>基于时间戳的控制</li><li>乐观并发控制</li><li>两阶段锁</li></ul></li><li>版本存储<br>通过版本链（version chain）存储，索引指向链表头，有三种方法：<ul><li>Append-Only<br><img src="/images/db-39.png"><br>每更新一次，作为一个新的tuple插入到表中，并更新链表指针。</li><li>Time-Traval<br><img src="/images/db-40.png"><br>每次更新将旧数据拷贝到time-travel表中，并更新指针。</li><li>Delta Storage<br><img src="/images/db-41.png"><br>每次更新不用将整个tuple拷贝，只需要拷贝delta值即可</li></ul></li><li>垃圾回收<ul><li>tuple级别的回收<ul><li>后台处理：后台线程对表进行定期扫描，查看开始时间戳和结束时间戳，不在活跃线程范围内就可以清除,一个优化是设置脏页面bitmap<br><img src="/images/db-42.png"></li><li>合作清理：当执行事务的线程在扫表的时候判断历史数据，只适用于从旧到新的版本数据存储方式</li></ul></li><li>事务级别的回收</li></ul></li><li>索引管理<ul><li>辅助索引的更新<ul><li>逻辑指针：每个tuple对应一个固定的id，这个id不变，我们去改变中间层，也就是将逻辑指针映射到物理指针的这一层，辅助索引保存的是主键索引的副本，每次去查找的时候实际上做两次操作，一次去查找主键，一次根据主键去查找这是的物理数据。</li><li>物理指针：直接修改物理指针去更新链表头</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;headerlink&quot; title=&quot;ACID&quot;&gt;&lt;/a&gt;ACID&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:原子性&lt;/li&gt;
&lt;li&gt;C:如果事务是一致的，数据库是一致的，那么结束时也必须是一致的&lt;/li&gt;
&lt;li&gt;I:隔离性&lt;/li&gt;
&lt;li&gt;D:事务提交之后会持久化</summary>
    
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CMU-cs445:并发访问</title>
    <link href="http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/"/>
    <id>http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/</id>
    <published>2022-09-24T17:40:36.324Z</published>
    <updated>2022-10-19T09:12:06.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="latch和lock"><a href="#latch和lock" class="headerlink" title="latch和lock"></a>latch和lock</h3><p><img src="/images/db-4.png"></p><span id="more"></span><h3 id="latch"><a href="#latch" class="headerlink" title="latch"></a>latch</h3><ul><li>种类<ul><li>Test-and-Set Spin Latch(TAS)</li><li>读写锁</li><li>乐观&#x2F;悲观锁</li></ul></li><li>粒度<ul><li>page latch：锁少，并行度不好</li><li>slot latch：锁多，并行度高</li></ul></li><li>latch crabbing&#x2F;coupling</li><li>B+树的死锁问题</li><li>B+树insert，父节点延迟更新</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;latch和lock&quot;&gt;&lt;a href=&quot;#latch和lock&quot; class=&quot;headerlink&quot; title=&quot;latch和lock&quot;&gt;&lt;/a&gt;latch和lock&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/db-4.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CMU-cs445:SQL基础</title>
    <link href="http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E9%AB%98%E7%BA%A7SQL/"/>
    <id>http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E9%AB%98%E7%BA%A7SQL/</id>
    <published>2022-09-24T17:40:36.324Z</published>
    <updated>2022-10-19T09:12:41.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础SQL"><a href="#基础SQL" class="headerlink" title="基础SQL"></a>基础SQL</h2><ul><li>聚合函数AVG，SUM，MIN，MAX等</li><li>GROUP BY</li><li>HAVING<span id="more"></span></li><li>UPPER</li><li>LIKE(%代替*，_代替?)</li><li>CONCAT</li><li>CREAT TABLE</li><li>ORDER BY</li><li>LIMIT</li><li>OFFSET</li></ul><h2 id="高级SQL"><a href="#高级SQL" class="headerlink" title="高级SQL"></a>高级SQL</h2><ul><li>嵌套查询</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基础SQL&quot;&gt;&lt;a href=&quot;#基础SQL&quot; class=&quot;headerlink&quot; title=&quot;基础SQL&quot;&gt;&lt;/a&gt;基础SQL&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;聚合函数AVG，SUM，MIN，MAX等&lt;/li&gt;
&lt;li&gt;GROUP BY&lt;/li&gt;
&lt;li&gt;HAVING</summary>
    
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CMU-cs445:buffer pool</title>
    <link href="http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9Abuffer%E6%B1%A0/"/>
    <id>http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9Abuffer%E6%B1%A0/</id>
    <published>2022-09-24T17:40:36.323Z</published>
    <updated>2022-10-19T09:12:54.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="buffer-pool-manager"><a href="#buffer-pool-manager" class="headerlink" title="buffer pool manager"></a>buffer pool manager</h2><pre><code>- buffer池组成    - frame：缓冲池由frame组成，每次我们需要一个page，就吧这个page替换进frame    - page table：用来记录page到buffer pool的映射关系    - 其他元信息：脏页面（页面是否被修改），引用计数（页面被线程正在访问的计数）- multiple buffer pools(多个缓冲池，每个池有其策略)    - 减少线程竞争    - 提供多种策略    - 如何实现？根据Object id映射或者哈希- pre-fetching(预取)    - 提前把一些顺序信息读入buffer pool中      - 可以完成一些操作系统不能完成的预读，如index分支跳转- scan sharing(扫描共享)    - 查询复用计算结果    - 允许多个查询附加到一个游标上- buffer pool bypass    - 给查询线程分配一小块内存，查询page的时候不经过缓存池，为了不污染缓存    - 查询量小的时候使用- O_DIRECT    - 避免操作系统文件缓存</code></pre><span id="more"></span><h2 id="replacement-policies"><a href="#replacement-policies" class="headerlink" title="replacement policies"></a>replacement policies</h2><pre><code>- LRU- Clock（LRU近似算法）- LRU-K：为了避免遍历对LRU的影响，K次才不会替换</code></pre><h2 id="脏页面"><a href="#脏页面" class="headerlink" title="脏页面"></a>脏页面</h2><pre><code>- 页面有一个标识位，记录某次查询是否更改页面记录- 后台写入（background writing）：定时将脏页面写回，避免缓存池中大量脏页面</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;buffer-pool-manager&quot;&gt;&lt;a href=&quot;#buffer-pool-manager&quot; class=&quot;headerlink&quot; title=&quot;buffer pool manager&quot;&gt;&lt;/a&gt;buffer pool manager&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- buffer池组成
    - frame：缓冲池由frame组成，每次我们需要一个page，就吧这个page替换进frame
    - page table：用来记录page到buffer pool的映射关系
    - 其他元信息：脏页面（页面是否被修改），引用计数（页面被线程正在访问的计数）
- multiple buffer pools(多个缓冲池，每个池有其策略)
    - 减少线程竞争
    - 提供多种策略
    - 如何实现？根据Object id映射或者哈希
- pre-fetching(预取)
    - 提前把一些顺序信息读入buffer pool中  
    - 可以完成一些操作系统不能完成的预读，如index分支跳转
- scan sharing(扫描共享)
    - 查询复用计算结果
    - 允许多个查询附加到一个游标上
- buffer pool bypass
    - 给查询线程分配一小块内存，查询page的时候不经过缓存池，为了不污染缓存
    - 查询量小的时候使用
- O_DIRECT
    - 避免操作系统文件缓存
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CMU-cs445:HashTable &amp;&amp; TableIndex</title>
    <link href="http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9AHashTable&amp;TableIndex/"/>
    <id>http://haoqinx.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9AHashTable&amp;TableIndex/</id>
    <published>2022-09-24T17:40:36.323Z</published>
    <updated>2022-10-19T09:12:59.310Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我们需要表示的数据"><a href="#我们需要表示的数据" class="headerlink" title="我们需要表示的数据"></a>我们需要表示的数据</h3><pre><code>- Internal Mata-data- Core data storage- Temporary Data Strutures- Table Indexs</code></pre><span id="more"></span><h3 id="hash-function"><a href="#hash-function" class="headerlink" title="hash function"></a>hash function</h3><pre><code>- XXHash- CityHash- FarmHash</code></pre><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><pre><code>- 开放地址法- robin 开放地址- cuckoo hashing- 链表法- extendible hashing（有些复杂）- Linear hashing（循环拆分，有点难以理解）</code></pre><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><pre><code>- 为什么叶子结点的key和value不放在一起？为了cpu缓存，能够快速定位key。</code></pre><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><pre><code>- 部分索引- 覆盖索引- 聚集索引- Include Columns：在建立索引的时候增加一些额外信息，能够加速查询。- 函数式/表达式索引- trie index- radix tree的垂直压缩- 倒排索引</code></pre>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;我们需要表示的数据&quot;&gt;&lt;a href=&quot;#我们需要表示的数据&quot; class=&quot;headerlink&quot; title=&quot;我们需要表示的数据&quot;&gt;&lt;/a&gt;我们需要表示的数据&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- Internal Mata-data
- Core data storage
- Temporary Data Strutures
- Table Indexs
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://haoqinx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>k8s系列：pod</title>
    <link href="http://haoqinx.github.io/2022/02/17/k8s%E7%B3%BB%E5%88%97%EF%BC%9Apod%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <id>http://haoqinx.github.io/2022/02/17/k8s%E7%B3%BB%E5%88%97%EF%BC%9Apod%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8/</id>
    <published>2022-02-16T16:00:00.000Z</published>
    <updated>2022-10-20T06:19:14.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><ul><li>概念：多个docker的集合，有一个pause容器，其他容器共享这个容器的网络栈和存储，这样多个应用可以实现本地访问其他应用。</li><li>分类<ul><li>自主式pod（不是被控制器管理的pod）</li><li>控制器管理的pod<span id="more"></span></li></ul></li></ul><h3 id="Pod控制器"><a href="#Pod控制器" class="headerlink" title="Pod控制器"></a>Pod控制器</h3><ul><li>Replication Controller&#x2F; ReplicaSet &#x2F; Deployment</li></ul><p>RC保证容器应用的副本始终保持在用户定义的副本数，如果容器异常，自动创建新的pod替代，异常多出来的容器也会自动回收。  </p><p>RS相比RC多了集合式的selector。  </p><p>Deployment支持滚动更新。</p><ul><li>StatefullSet<br><img src="/images/k8s-5.png"></li><li>DaemonSet<br><img src="/images/k8s-6.png"></li></ul><h3 id="pod网络通讯模式"><a href="#pod网络通讯模式" class="headerlink" title="pod网络通讯模式"></a>pod网络通讯模式</h3><ul><li>同个pod多个容器之间：同过共享pause容器，使用lo回环网卡即可。</li><li>pod之间：overlay network。</li><li>pod与service之间：节点之间的iptable规则。</li></ul><p>下图展示了利用flann eld组件进行转发的原理图，flanneld可以使整个网络扁平化：<br><img src="/images/k8s-7.png"></p><ol><li>假如webapp2想要访问backend，怎么同过内网ip进行通信？</li></ol><ul><li>首先webApp2发送数据到docker0</li><li>docker0数据经过flannel0网桥转发</li><li>flanneld存放有etcd的数据信息，会对数据包进行封装，如右图所示，首先写入目标主机mac地址，然后写入目标主机和本机的内网ip，通过udp协议传输到目标主机。</li><li>目标flanneld接受到数据包，进行逆向解封</li></ul><p>Q：etcd想flannel提供了什么数据？<br>A：1.存储管理flannel可分配的ip地址段资源。2.flannel监控每个pod的实际地址，在内存中建立维护pod节点路由表。</p><ol start="2"><li><p>pod到Service的网络<br>目前基于性能考虑。全部为LVS维护和转发。</p></li><li><p>pod到外网</p></li></ol><p>pod向外网发送请求，查找路由表，转发数据包到宿主机网卡，宿主机网卡完成路由选择后，iptables执行masquerade，把源ip更改为宿主网卡的ip，然后向往往服务器发送请求。</p><ol start="4"><li>外网访问pod：通过Service</li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Pod&quot;&gt;&lt;a href=&quot;#Pod&quot; class=&quot;headerlink&quot; title=&quot;Pod&quot;&gt;&lt;/a&gt;Pod&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;概念：多个docker的集合，有一个pause容器，其他容器共享这个容器的网络栈和存储，这样多个应用可以实现本地访问其他应用。&lt;/li&gt;
&lt;li&gt;分类&lt;ul&gt;
&lt;li&gt;自主式pod（不是被控制器管理的pod）&lt;/li&gt;
&lt;li&gt;控制器管理的pod</summary>
    
    
    
    <category term="K8S" scheme="http://haoqinx.github.io/categories/K8S/"/>
    
    
    <category term="K8S" scheme="http://haoqinx.github.io/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>k8s系列：资源和声明周期</title>
    <link href="http://haoqinx.github.io/2022/02/17/k8s%E7%B3%BB%E5%88%97%EF%BC%9A%E8%B5%84%E6%BA%90%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://haoqinx.github.io/2022/02/17/k8s%E7%B3%BB%E5%88%97%EF%BC%9A%E8%B5%84%E6%BA%90%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-02-16T16:00:00.000Z</published>
    <updated>2022-10-20T06:19:05.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集群资源分类"><a href="#集群资源分类" class="headerlink" title="集群资源分类"></a>集群资源分类</h3><ol><li>名称空间级别：默认为default</li><li>集群级别：role</li><li>元数据<span id="more"></span></li></ol><h3 id="pod资源清单"><a href="#pod资源清单" class="headerlink" title="pod资源清单"></a>pod资源清单</h3><p>定义一个pod需要下面这些信息：<br><img src="/images/k8s-8.png"></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/images/k8s-8.png"></p><ol><li>初始化pause容器</li><li>init C 初始化容器，init容器总是运行到成功为止，并且后面的容器要等到前面的容器运行结束之后才运行。</li><li>进入容器，执行start操作。</li><li>readiness：就绪检测，如果服务就绪，可以暴露给外围。</li><li>liveness：生存检测，发现容器内部有假死（例如僵尸进程）时，进行重启或其他操作。</li><li>stop：结束时执行的一些操作。</li></ol><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>调度器负责管理pod的生命周期，在必要的时候重启pod，下图是deployment滚动更新的管理方式，称为命令式管理，在后台其实是通过管理RS来达到目的。<br><img src="/images/k8s-10.png"></p><p>这样存在一个问题，假如其中一个pod挂掉，RS重新启动一个pod替代，但是ip地址变了，那么其他pod访问不到怎么办？这个时候需要在pod和上层服务比如nginx中加入一个中间件SVC，SVC会自动进行服务发现，通过标签匹配策略自动获取其关联的pod的信息，然后同步给需要使用的pod。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;集群资源分类&quot;&gt;&lt;a href=&quot;#集群资源分类&quot; class=&quot;headerlink&quot; title=&quot;集群资源分类&quot;&gt;&lt;/a&gt;集群资源分类&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;名称空间级别：默认为default&lt;/li&gt;
&lt;li&gt;集群级别：role&lt;/li&gt;
&lt;li&gt;元数据</summary>
    
    
    
    <category term="K8S" scheme="http://haoqinx.github.io/categories/K8S/"/>
    
    
    <category term="K8S" scheme="http://haoqinx.github.io/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>k8s系列：基础概念</title>
    <link href="http://haoqinx.github.io/2022/02/17/k8s%E7%B3%BB%E5%88%97%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://haoqinx.github.io/2022/02/17/k8s%E7%B3%BB%E5%88%97%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2022-02-16T16:00:00.000Z</published>
    <updated>2022-10-20T06:18:57.917Z</updated>
    
    <content type="html"><![CDATA[<h3 id="borg系统"><a href="#borg系统" class="headerlink" title="borg系统"></a>borg系统</h3><p><img src="/images/k8s-1.png"></p><span id="more"></span><p>Master节点为奇数，scheduler向paxos写入数据，然后borglet监听到右自己的消息，就会执行命令。</p><h3 id="k8s架构"><a href="#k8s架构" class="headerlink" title="k8s架构"></a>k8s架构</h3><p><img src="/images/k8s-2.png"></p><p>和borg一样，但是中间加了一个apiserver层，etcd约等于paxos。</p><ul><li>scheduler：负责接收任务，选择合适的节点进行分配任务.</li><li>replication controller：负责控制node的副本数量，也就是删除或者创建pod.</li><li>apiserver：所有外界输入的入口，包括kubelet、kube proxy、replication controller、scheduler.</li><li>etcd：可信赖的分布式键值对数据库，存储k8s集群的所有重要信息，其内部结构如下图所示：<br><img src="/images/k8s-3.png"></li></ul><p>etcd使用http协议的c&#x2F;s架构，WAL是一种持久化策略，简单来说就是增量+完整备份，每一小段时间进行一个增量备份，每隔一大段时间进行完整备份，数据写入store中.</p><ul><li>kubelet：(CRI：container runtime interface)，操作docker，维护Pod的生命周期（pod运行在docker中）.</li><li>kube proxy：负责写入ipvs和iptables，执行负载均衡，实现pod和pod之间的通信.</li></ul><h3 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h3><ul><li>coreDNS：为集群中的SVC创建一个域名IP的对应关系解析。</li><li>dashboard：给k8s集群提供的B&#x2F;S访问体系。</li><li>ingress controller：官方只实现四层代理，ingress实现七层代理。</li><li>federation：提供一个可以跨集群中心多k8s统一管理功能。</li><li>prometheus：提供k8s集群的监控能力。</li><li>ELK：提供k8s日志统一管理平台。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;borg系统&quot;&gt;&lt;a href=&quot;#borg系统&quot; class=&quot;headerlink&quot; title=&quot;borg系统&quot;&gt;&lt;/a&gt;borg系统&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/k8s-1.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="K8S" scheme="http://haoqinx.github.io/categories/K8S/"/>
    
    
    <category term="K8S" scheme="http://haoqinx.github.io/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>海量数据问题</title>
    <link href="http://haoqinx.github.io/2022/02/03/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://haoqinx.github.io/2022/02/03/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-02-02T16:00:00.000Z</published>
    <updated>2022-10-19T09:10:06.151Z</updated>
    
    <content type="html"><![CDATA[<p>海量数据问题</p><h2 id="海量日志找出现次数最多的记录"><a href="#海量日志找出现次数最多的记录" class="headerlink" title="海量日志找出现次数最多的记录"></a>海量日志找出现次数最多的记录</h2><ul><li>问题主要是记录不能全部载入到内存</li></ul><ol><li>先把整个文件分割成若干个小文件，比如1000个小文件</li><li>找出每个文件中出现次数最多的记录（输出1000个记录+频次）</li><li>从每个文件出现最多的记录找出全局出现次数最多的记录（合并记录，找出最多的频次）<span id="more"></span></li></ol><h2 id="统计topk个热门记录"><a href="#统计topk个热门记录" class="headerlink" title="统计topk个热门记录"></a>统计topk个热门记录</h2><ol><li>依次遍历这些文件，通过hash映射，将每个文件的每条数据映射到新构造的多个小文件中（设生成了nn个小文件）；</li><li>依次统计每个小文件中出现次数最多的kk条数据，构成hash表，hash表中每个键值对的形式为 dataItem: count；</li><li>利用堆排序，依次遍历这些hash表，在n∗kn∗k条数据中，找出count值最大的kk个；</li></ol><h2 id="海量数据查重"><a href="#海量数据查重" class="headerlink" title="海量数据查重"></a>海量数据查重</h2><ol><li>遍历A中的所有数据，通过hash映射将他们分布存储在n个小文件中，记为{a1,a2,…,an}；</li><li>遍历B中的所有数据，通过hash映射将他们分布存储在n个小文件中，记为{b1,b2,…,bn}；</li><li>根据hash函数性质可知，A和B中的相同数据一定被映射到序号相同的小文件，所以我们依次比较{ai,bi}即可；</li><li>如果问题更进一步，要求返回重复次数最多的k条数据，则可以将对比小文件找到的数据存入hash表，键为数据，值为该数据出现的次数。再用大小为k的堆，排序找出即可。</li></ol><h2 id="海量数据频率排序"><a href="#海量数据频率排序" class="headerlink" title="海量数据频率排序"></a>海量数据频率排序</h2><ol><li>顺序读文件，利用hash将相同的记录输出到相同的文件里。</li><li>每个小文件统计频率， 排序</li><li>归并排序(外部排序)<br><a href="https://www.cnblogs.com/codeMedita/p/7425291.html">外部排序参考</a></li></ol><h2 id="int数字重复数据查找（BitMap）"><a href="#int数字重复数据查找（BitMap）" class="headerlink" title="int数字重复数据查找（BitMap）"></a>int数字重复数据查找（BitMap）</h2><ul><li>例如：在2.5亿个整数里找不重复的整数</li></ul><ol><li>使用2bitmap算法， 00 代表没有出现，01表示出现一次，10表示出现多次。</li><li>计算下：整数4B，最多表示2^32个数，每个数用2个bit表示，就是2^32 * 2 &#x2F; 2^30 &#x2F; 8 &#x3D; 1G，注意那个8是B转bit。</li><li>然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</li></ol><ul><li>再例如：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？<br>原理和上面一样，使用1bitmap就可以了</li></ul><h2 id="超大文件求交集"><a href="#超大文件求交集" class="headerlink" title="超大文件求交集"></a>超大文件求交集</h2><ul><li>现有两个各有20亿行的文件，每一行都只有一个数字，求这两个文件的交集。</li></ul><ol><li>开辟128M的int数组。<ul><li>int最大表示4G，也就是需要2^32bit位， 一个int是4B，也就是32bit，因此需要2^32&#x2F;2^5&#x3D;2^27bit。</li></ul></li><li>对于每个数，先 &#x2F;32，确定在数组哪个位置，然后%32，确定在该int的哪一位，然后对这个数组取并集即可统计</li><li>如果存在正负数的话，设置正负两个bitmap然后分别求交集即可</li></ol><h2 id="超大文件字符串重复"><a href="#超大文件字符串重复" class="headerlink" title="超大文件字符串重复"></a>超大文件字符串重复</h2><ul><li>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url</li></ul><ol><li><p>分文件： </p><ul><li><p>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。 </p></li><li><p>遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</p></li></ul></li><li><p>逐个找重复：</p></li></ol><ul><li>求每对小文件中相同的url： 把其中一个小文件的url存储到hash_set中，然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</li></ul><h2 id="海量数据中位数（计数排序）"><a href="#海量数据中位数（计数排序）" class="headerlink" title="海量数据中位数（计数排序）"></a>海量数据中位数（计数排序）</h2><ul><li><p>只有2G内存的pc机，在一个存有10G个整数的文件，从中找到中位数，写一个算法。</p></li><li><p>分析：<br>  明显是一道工程性很强的题目，和一般的查找中位数的题目有几点不同。</p></li></ul><ol><li><p>原数据不能读进内存，不然可以用快速选择，如果数的范围合适的话还可以考虑桶排序或者计数排序，但这里假设是32位整数，仍有4G种取值，需要一个16G大小的数组来计数。</p></li><li><p>若看成从N个数中找出第K大的数，如果K个数可以读进内存，可以利用最小或最大堆，但这里K&#x3D;N&#x2F;2,有5G个数，仍然不能读进内存。</p></li></ol><ul><li>解法一：桶排序</li></ul><ol><li><p>读一遍10G个整数，把整数映射到256M个区段中，用一个64位无符号整数给每个相应区段记数。</p></li><li><p>从前到后对每一段的计数累加，当累加的和超过5G时停止，找出这个区段（即累加停止时达到的区段，也是中位数所在的区段）的数值范围，设为[a，a+15]，同时记录累加到前一个区段的总数，设为m。然后，释放除这个区段占用的内存。</p></li><li><p>再读一遍10G个整数，把在[a，a+15]内的每个值计数，即有16个计数。</p></li><li><p>对新的计数依次累加，每次的和设为n，当m+n的值超过5G时停止，此时的这个计数所对应的数就是中位数。</p></li></ol><ul><li><p>解法二：二进制分文件</p><p>  假设10亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制：1GB)，将每个数字用二进制表示，比较二进制的最高位(第32位)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。【这里的最高位类似于快速排序中的枢轴元素】</p><p>  从而将10亿个数字分成了两个文件（几乎是二分的），假设 file_0文件中有 6亿 个数字，file_1文件中有 4亿 个数字。那么中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 1亿 个数字。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;海量数据问题&lt;/p&gt;
&lt;h2 id=&quot;海量日志找出现次数最多的记录&quot;&gt;&lt;a href=&quot;#海量日志找出现次数最多的记录&quot; class=&quot;headerlink&quot; title=&quot;海量日志找出现次数最多的记录&quot;&gt;&lt;/a&gt;海量日志找出现次数最多的记录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;问题主要是记录不能全部载入到内存&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;先把整个文件分割成若干个小文件，比如1000个小文件&lt;/li&gt;
&lt;li&gt;找出每个文件中出现次数最多的记录（输出1000个记录+频次）&lt;/li&gt;
&lt;li&gt;从每个文件出现最多的记录找出全局出现次数最多的记录（合并记录，找出最多的频次）</summary>
    
    
    
    <category term="场景设计" scheme="http://haoqinx.github.io/categories/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="场景设计" scheme="http://haoqinx.github.io/tags/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
