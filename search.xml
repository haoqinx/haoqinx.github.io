<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++协程：x86_64寄存器</title>
    <url>/2021/11/08/C++%E5%8D%8F%E7%A8%8B%EF%BC%9A%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="X86-64-寄存器"><a href="#X86-64-寄存器" class="headerlink" title="X86_64 寄存器"></a>X86_64 寄存器</h3><ul>
<li>rax:函数返回值</li>
<li>rsp:栈指针寄存器，指向栈顶</li>
<li>rdi:函数第一参数</li>
<li>rsi:函数第二参数</li>
<li>rdx:函数第三参数、I&#x2F;O操作时提供外部设备接口的端口地址</li>
<li>rcx:函数第四参数、循环操作和字串处理的计数控制</li>
<li>r8:函数第五参数</li>
<li>r9:函数第六参数</li>
</ul>
<p><font color = orange>注意一点：对于x86-64，当参数个数超过６时，前６个参数可以通过寄存器传递，而第７～n个参数则会通过栈传递，并且数据大小都向８的倍数对齐。也就是说，对于７～ｎ个参数，依然满足从右往左入栈，只是对于前６个参数，它们是通过寄存器来传递的。另外，寄存器的访问速度相对于内存来说要快得多，因此为了提高空间和时间效率，实际中其实不建议参数超过6个。</font></p>
<ul>
<li>rbx:基址寄存器，被调用者保护。</li>
<li>rbp：基址指针寄存器，用于提供堆栈内某个单元的偏移地址，与rss段寄存器联用，可以访问堆栈中的任一个存储单元，被调用者保存</li>
<li>r10, r11, r12, r13, r14, r15:用作数据存储，被调用者保护。</li>
<li>rip:指令指针寄存器，存放代码段中指令的偏移地址.</li>
<li>FR:(Flags Register)标志寄存器，用于存放反映处理器和运行程序执行结果状态的控制标志和条件码标志。</li>
</ul>
<p>所谓<strong>调用者保存</strong>和<strong>被调用者保存</strong>：</p>
<ul>
<li>调用者保存：<br>也叫易失性寄存器，在程序调用的过程中，这些寄存器中的值不需要被保存（即压入到栈中再从栈中取出），如果某一个程序需要保存这个寄存器的值，需要调用者自己压入栈。</li>
<li>被调用者保存：<br>也叫非易失性寄存器，在程序调用过程中，这些寄存器中的值需要被保存，不能被覆盖；当某个程序调用这些寄存器，被调用寄存器会先保存这些值然后再进行调用，且在调用结束后恢复被调用之前的值。</li>
</ul>
]]></content>
      <categories>
        <category>协程</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>基于ucontext的C++协程</title>
    <url>/2021/11/06/C++%E5%8D%8F%E7%A8%8B%EF%BC%9A%E5%9F%BA%E4%BA%8Eucontext/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="基于ucontext的协程"><a href="#基于ucontext的协程" class="headerlink" title="基于ucontext的协程"></a>基于ucontext的协程</h3><p>ucontext是glibc下的组件，用来管理程序执行的上下文，重点是四个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getcontext</span><span class="params">(<span class="type">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setcontext</span><span class="params">(<span class="type">const</span> <span class="type">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makecontext</span><span class="params">(<span class="type">ucontext_t</span> *ucp, <span class="type">void</span> (*func)(),<span class="type">int</span> argc, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swapcontext</span><span class="params">(<span class="type">ucontext_t</span> *oucp, <span class="type">const</span> <span class="type">ucontext_t</span> *ucp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在使用ucontext封装c++风格的轻量级协程的过程中，主要是干下面几件事：</p>
<ol>
<li>对调度器、协程的资源初始化。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coroutine</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Coroutine</span>(coroutineFunc func, <span class="type">void</span>* args, CoScheduler* sche);</span><br><span class="line">    ~<span class="built_in">Coroutine</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">saveStack</span><span class="params">(<span class="type">char</span>* top)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dofunc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getStatus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">        id_ = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    coroutineFunc func_;</span><br><span class="line">    <span class="type">void</span>* args_;</span><br><span class="line">    CoScheduler* sehcduler_;</span><br><span class="line">    <span class="type">ptrdiff_t</span> capacity_;</span><br><span class="line">    <span class="type">ptrdiff_t</span> curSize_;</span><br><span class="line">    <span class="type">ucontext_t</span> ctx_;</span><br><span class="line">    CoStatus status_;</span><br><span class="line">    <span class="type">char</span>* stack_;</span><br><span class="line">    <span class="type">int</span> id_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoScheduler</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CoScheduler</span>();</span><br><span class="line">    ~<span class="built_in">CoScheduler</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">createCoroutine</span><span class="params">(coroutineFunc func, <span class="type">void</span>* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteCoroutine</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">currentCo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runningCo_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getStatus</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(id&gt;=<span class="number">0</span> &amp;&amp; id &lt; capacity_);</span><br><span class="line">        <span class="keyword">if</span> (coroutines_[id] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> COURTINUE_DEAD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coroutines_[id] -&gt; status_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CoScheduler</span>(<span class="type">const</span> CoScheduler&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CoScheduler&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CoScheduler&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">char</span> stack_[STACK_SIZE];</span><br><span class="line">    <span class="type">ucontext_t</span> mainCtx_;</span><br><span class="line">    <span class="type">int</span> numCoroutines_;</span><br><span class="line">    <span class="type">int</span> capacity_;</span><br><span class="line">    <span class="type">int</span> runningCo_;</span><br><span class="line">    std::vector&lt;Coroutine*&gt; coroutines_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>对调度器调度方式实现。</li>
</ol>
<p>这里主要有对称和非对称之别，主要区别:</p>
<ul>
<li>非对称:类似于函数调用，某个协程切换到另一个协程，最终是要返回到本协程调用处的。在实现基于ucontext的协程的过程中，采用的是非对称方式，主要是因为非对称的方式比较好控制。</li>
<li>对称则不存在这种关系，程序执行权在协程之间任意切换。例如go的协程。</li>
</ul>
<ol start="3">
<li>协程堆栈的封装</li>
</ol>
<p>在有栈协程里，对协程堆栈的实现也分为两种，一种是共享堆栈，一种是独立栈。</p>
<ul>
<li>独立栈：每个协程都有自己的堆栈数据，每次执行之后保存，优点是切换速度快，缺点是需要分配足够大的内存，否则运行过程会导致栈溢出。</li>
<li>共享栈：在主协程分配足够大的栈空间，每次执行将协程堆栈拷贝到此空间，缺点是拷贝耗时，优点是省空间。</li>
</ul>
<p>除此之外，由于ucontext有浮点数上下文和sigmask(信号屏蔽掩码)的保存，因此切换的效率并不高，在一些工业级的应用场景下，常常自定义汇编代码进行上下文切换，如libco，接下来我会参考libco来使用x86汇编实现一个小型协程库。</p>
]]></content>
      <categories>
        <category>协程</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对象模型：函数和继承</title>
    <url>/2020/10/24/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<span id="more"></span>
<ol>
<li>member function类型</li>
</ol>
<ul>
<li><p>static member function</p>
</li>
<li><p>nonstatic member function</p>
<p>  nonstatic member function 设计原则是和 nonmember效率相同，方法就是隐藏传入一个this指针，重写为外部函数时，函数签名带标识保证全局唯一。</p>
</li>
<li><p>virtual function</p>
<p>  虚函数调用时会到虚表找到相关的函数地址，然后传入this指针。例如调用：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ptr -&gt; <span class="built_in">func</span>();</span><br></pre></td></tr></table></figure>
<p>  在编译器中会生成：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(*ptr -&gt; vptr[<span class="number">1</span>])(ptr);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>thunk机制</li>
</ol>
<p>在多重继承和虚拟继承下，this指针的调整不能在编译器确定，因此计算偏移量需要引入thunk块。<br>thunk是一小段汇编代码，做两件事：</p>
<ul>
<li>以适当的值调整this指针。</li>
<li>调到相应的virtual function处。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对象模型：构造、析构</title>
    <url>/2020/10/24/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%9A%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ol>
<li>无继承</li>
</ol>
<ul>
<li><p>Plain Old Data(纯data)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;Point;</span><br></pre></td></tr></table></figure>
<p>直接逐bit拷贝，编译器甚至没有生成默认构造和析构函数。</p>
</li>
<li><p>抽象数据</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x = <span class="number">0.0</span>, <span class="type">double</span> y = <span class="number">0.0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认的bitwise copy已经足够。</p>
<ul>
<li>带有虚函数</li>
</ul>
<p>在执行构造函数的时候扩充代码，主要是对虚表进行初始化。<br>包括拷贝构造和拷贝赋值的时候，都会对虚表进行初始化。</p>
<ol start="2">
<li>继承</li>
</ol>
<p>继承情况下会增加大量的隐藏代码：</p>
<ul>
<li>记录初始化列表初始化操作并按照变量声明顺序进行初始化，这些初始化操作代码会放到构造函数内（但对于member object会少一次拷贝构造）。</li>
<li>对于没有在初始化列表中的成员变量，执行默认构造。</li>
<li>再此之前，先初始化虚表指针。</li>
<li>在此之前，调用基类的构造函数，以声明顺序为准。<ul>
<li>如果基类在初始化列表中，把参数固定为初始化列表中的参数。</li>
<li>若没有在初始化列表，调用默认构造。</li>
<li>若为多重继承第二个之后的class，调整this指针。</li>
</ul>
</li>
<li>在此之前，调用虚基类的构造函数，从左到右，从浅到深。<ul>
<li>若在初始化列表，传入参数然后构造，若没有在列表，调用默认构造。</li>
<li>virtual base class object偏移量在执行器必须可存取。<br>具体例子见《深度探索c++对象模型》P207</li>
</ul>
</li>
</ul>
<ol start="3">
<li>虚拟继承</li>
</ol>
<ul>
<li>共同父类怎么初始化？</li>
</ul>
<p>在虚继承的时候，由于有共同父类的原因，对于子类的构造函数中的代码扩充，需要引入判断当前类是否为most_derived，即最后一个继承的子类。<br>在最后继承子类的构造函数中，对于父类的构造函数传递most_derived &#x3D; false;从而来抑制父类对于共同父类的构造。</p>
<ul>
<li>构造函数调用共同虚函数怎么初始化？</li>
</ul>
<p>如果父类和子类的虚函数存在同名函数，那应该怎么初始化？是调用本体的虚函数还是全部调用继承类的虚函数？<br>C++规则是在类内调用的话全都应该是本体的虚函数。调用虚函数就需要虚函数表，那么应该怎么初始化？</p>
<ul>
<li>在base class constructors调用之后，在初始化列表和user code之前。</li>
</ul>
<p>因此可以这么理解，在虚继承机制下，一个子类首先变成共同父类，然后依次变成父类，最后构造本体，因此它的构造过程是：</p>
<ul>
<li>在子类的构造函数中，调用共同父类和父类的构造函数。</li>
<li>初始化对象的虚表指针，指向相关的虚表。</li>
<li>在构造函数体内展开初始化列表。</li>
<li>执行user code。</li>
</ul>
<ol start="4">
<li>对象复制</li>
</ol>
<p>拷贝赋值什么时候会展现不会展现bitwise语义？</p>
<ul>
<li>class内部的某个成员对象有拷贝赋值。</li>
<li>基类有拷贝赋值。</li>
<li>存在虚函数。</li>
<li>存在虚父类。</li>
</ul>
<p>一旦展现出bitwise语义，编译器就不为我们合成相关的函数。</p>
<ol start="5">
<li>析构</li>
</ol>
<p>析构函数什么时候会被合成？<br>class内部的member object含有析构函数。<br>析构函数调用顺序和构造函数相反。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对象模型：构造函数</title>
    <url>/2020/10/26/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="编译器何时生成默认构造函数？"><a href="#编译器何时生成默认构造函数？" class="headerlink" title="编译器何时生成默认构造函数？"></a>编译器何时生成默认构造函数？</h3><p><font color = orange>编译器生成的构造函数只适用于编译器的正确性，类内的数据初始化不由编译器负责!</font></p>
<ol>
<li>如果一个class内部含有一个成员对象，并且这个对象有默认构造函数，那么编译器就会为这个class生成默认构造函数。</li>
<li>此class继承自一个含有默认构造函数的基类。</li>
<li>带有virtual function的Class或者继承了一个含有virtual fuction的父类。</li>
<li>使用了虚继承的类。<br>存在两个误解：  </li>
<li>任何class如果没有定义默认构造，编译器会生成。（错，编译器只会在需要的时候生成）</li>
<li>编译器生成的默认构造会明确初始化。（错，编译器不会初始化成员变量，这是程序设计者的活！)</li>
</ol>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ol>
<li><p>何时会用到拷贝构造？</p>
<ul>
<li>明确初始化</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;&#125;;</span><br><span class="line">X xx;</span><br><span class="line">X xxx = xx; <span class="comment">// 拷贝构造</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数值传递</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X xx;</span><br><span class="line"><span class="built_in">func</span>(xx); <span class="comment">// 函数内部拷贝副本</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数内对象返回(此处在g++7.5版本中没有调用拷贝构造，直接返回了对象，属于编译优化)</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">const</span> X&amp; x)&#123;</span><br><span class="line">        i = x.i;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    xx.i = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span> *)&amp;xx &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X x = <span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span> *)&amp;x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0x7ffffe3b1284</span></span><br><span class="line"><span class="comment">//0x7ffffe3b1284</span></span><br></pre></td></tr></table></figure></li>
<li><p>编译器什么时候为我们生成拷贝构造？<br><font color = orange> 决定一个拷贝构造是否被合成取决于class是否展现 bitwise copy semantics. 当展现了bitwise copy semantics，编译器不会合成默认拷贝构造。</font></p>
</li>
</ol>
<ul>
<li><p>什么时候不展现所谓逐位拷贝？</p>
<ul>
<li>class内部的member object有拷贝构造。</li>
<li>class继承自一个具有拷贝构造的父类。</li>
<li>class含有虚函数。</li>
<li>class的继承链上有基类含有虚函数。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>初始化列表</li>
</ol>
<ul>
<li>使用初始化列表可以避免一次不必要的赋值拷贝</li>
<li>记住初始化列表的初始化顺序是按照类内声明顺序就可以了，在初始化列表里如果某变量初始化依赖其他变量，在定义的时候记得调整先后顺序。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言系列：GMP模型</title>
    <url>/2021/09/02/Go%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97%EF%BC%9AGMP%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言系列：协程</title>
    <url>/2021/09/02/Go%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97%EF%BC%9A%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言系列：管道、通信</title>
    <url>/2021/09/02/Go%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97%EF%BC%9A%E7%AE%A1%E9%81%93%E3%80%81%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP1.0/1.1/2.0/3.0本质对比</title>
    <url>/2021/11/06/HTTP3.0/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="HTTP1-0-x2F-1-1-x2F-2-0"><a href="#HTTP1-0-x2F-1-1-x2F-2-0" class="headerlink" title="HTTP1.0&#x2F;1.1&#x2F;2.0"></a>HTTP1.0&#x2F;1.1&#x2F;2.0</h3><ol>
<li>HTTP1.0<br>主要问题就是HTTP请求需要一个一个发，每次三次握手。并且不支持断点续传。</li>
<li>HTTP1.1<br>引入长连接，多个请求可以用一个TCP连接，但是会引起HTTP队头阻塞，也就是前一个请求没有被应答的话后面的请求也无法获得。管线化（同时发若干个请求）也无法避免队头阻塞。</li>
<li>HTTP2.0<br>基于二进制帧的传输，可以实现多路复用。若干个帧组成一个HTTP消息，若干个消息组成一个流。解决了<strong>HTTP队头阻塞</strong>的问题，but基于TCP的HTTP&#x2F;2，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输方面，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，则同样会阻塞在它之后传输的流数据传输</li>
<li>HTTP3.0<br>基于TLS1.3实现1RTT的握手，实现了TCP的流量控制和可靠传输，实现了HTTP2.0的多路复用，不同点是QUIC实现了同一个物理连接有多个独立的逻辑数据流，解决了<strong>TCP队头阻塞</strong>的问题。</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB 入门</title>
    <url>/2021/09/02/LevelDB%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在实习过程中遇到使用leveldb的场景，在大量写少量读的场景下leveldb算是不二之选，但是其原理如何？下面列举看过的资料，受益颇深。</p>
<p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.2782&rep=rep1&type=pdf">LSM tree 论文</a><br><a href="https://www.cnblogs.com/zhihaowu/p/7884424.html">十个levelDB技术内幕</a></p>
]]></content>
      <categories>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：GDT/LDT</title>
    <url>/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9AGDT%EF%BC%8CLDT/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h3><p>现代的内存寻址方式一般采用保护模式。    </p>
<p>Q:什么是保护模式？   </p>
<p>A:保护模式是相对于实模式来说的，以前的内存寻址是直接由cpu段寄存器+偏移量去实存里面找物理地址，例如在8086的时候，也就是16位cpu的时候，CPU配备了4个16位段寄存器（CS代码段寄存器、DS数据段寄存器、SS堆栈段寄存器和ES附加寄存器），这种方式非常粗暴并且很容易出错，一旦用户修改段寄存的值，就可以随意访问所有内存，到了80296芯片，大家意识到直接访问实地址的危害，intel将寻址方式改为保护模式，保护模式下段寄存器不在指向一个真实地址，而是变成指向一个数据结构的指针，这个数据结构就是<font color = orange>Segment Descripter Table</font>，又根据这个段描述符表里存的是全局共同的，还是进程私有的，分成了全局段描述符表（GDT）和局部段描述符表（LDT）。  </p>
<p>需要了解的：</p>
<ol>
<li>GDT里面具体存的是什么？  <ul>
<li>段描述符，8字节，包括系统级段描述符和LDT段描述符</li>
</ul>
</li>
<li>我们访问内存的具体步骤是什么？<ul>
<li>从GDTR中拿到GDT在内存中的基地址，得到段描述符表；</li>
<li>从段选择子中的前13位得到我们要访问的段的描述符在段描述符表中的索引（需要考虑TI和RPL）；</li>
<li>从段描述符表中得到要访问的段的描述符，得到其基地址；</li>
<li>基地址加上偏移地址就是我们要访问的内存地址（当然这里是虚拟地址，接下来是分页机制的功能将虚地址转换为物理地址，不做讨论。）</li>
</ul>
</li>
</ol>
<p>具体参考<a href="https://www.cnblogs.com/chenwb89/p/operating_system_003.html">这篇文章</a>，<a href="http://www.techbulo.com/708.html">这篇文章</a></p>
<h3 id="LDT"><a href="#LDT" class="headerlink" title="LDT"></a>LDT</h3><p>LDT和GDT差不多，区别有：</p>
<ol>
<li>LDT是局部段描述符表，GDT是全局段描述符表</li>
<li>LDT可以有多个，GDT只能有一个</li>
<li>LDT本身是个段，需要在GDT中保存其自身描述符</li>
<li>GDT用来描述系统的分段，LDT用来描述某个任务的分段情况，由于每个进程都有自己的一套程序段、数据段、堆栈段，有了局部描述符表则可以将每个进程的程序段、数据段、堆栈段封装在一起，只要改变LDTR就可以实现对不同进程的段进行访问。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>分段分页</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：ELF文件格式</title>
    <url>/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9AELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="ELF（Executable-Linkable-Format）分类"><a href="#ELF（Executable-Linkable-Format）分类" class="headerlink" title="ELF（Executable Linkable Format）分类"></a>ELF（Executable Linkable Format）分类</h3><ul>
<li>可重定位文件：包含代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类。</li>
<li>可执行文件：包含可以执行的程序，代表ELF可执行文件，没有扩展名。</li>
<li>共享目标文件：包含代码和数据，可以在两种情况下使用<ul>
<li>链接器可以使用这种文件跟其他可重定位文件和共享目标文件链接，生成新的目标文件。</li>
<li>动态链接器将几个共享目标文件与可执行文件结合，作为进程映像的一部分来运行。</li>
</ul>
</li>
<li>核心转储文件（core dump）：进程意外终止，系统可以为该进程地址空间的内存及终止是的一些其他信息转储到核心转储文件。</li>
</ul>
<h3 id="目标文件组成"><a href="#目标文件组成" class="headerlink" title="目标文件组成"></a>目标文件组成</h3><p><img src="/images/elf-1.png"></p>
<p>目标文件不仅包含编译后的代码，数据，还有链接时所需要的一些信息，比如符号表，调试信息，字符串等。目标文件将这些信息按不同的属性，以section（节）的形式存储，有时候也叫segment（段），在一般情况下，它们表示一个一定长度的区域，基本不加以区别。</p>
<ul>
<li>源代码的机器指令放在代码段.text.</li>
<li>初始化的全局变量和局部静态变量放在.data段。</li>
<li>未初始化的全局变量和局部静态变量放在.bss段。</li>
<li>ELF文件开头是一个文件头，用来母爱书整个文件的文件属性，文件是否可执行，静态或动态链接等等。</li>
<li>文件头包含一个段表，段表是一个描述文件中各个段的数组，包括文件中各个段在文件中的偏移位置和段的属性等等。</li>
<li><font color=orange>bss段只是为未初始化的全局变量和局部静态变量预留位置而已，并没有内容，也不占据空间.</font></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用objdump -h main main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">main:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .interp       <span class="number">0000001</span>c  <span class="number">0000000000400238</span>  <span class="number">0000000000400238</span>  <span class="number">00000238</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">1</span> .note.ABI-tag <span class="number">00000020</span>  <span class="number">0000000000400254</span>  <span class="number">0000000000400254</span>  <span class="number">00000254</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">2</span> .note.gnu.build-id <span class="number">00000024</span>  <span class="number">0000000000400274</span>  <span class="number">0000000000400274</span>  <span class="number">00000274</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">3</span> .gnu.hash     <span class="number">00000030</span>  <span class="number">0000000000400298</span>  <span class="number">0000000000400298</span>  <span class="number">00000298</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">4</span> .dynsym       <span class="number">00000138</span>  <span class="number">00000000004002</span>c8  <span class="number">00000000004002</span>c8  <span class="number">000002</span>c8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">5</span> .dynstr       <span class="number">00000168</span>  <span class="number">0000000000400400</span>  <span class="number">0000000000400400</span>  <span class="number">00000400</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">6</span> .gnu.version  <span class="number">0000001</span>a  <span class="number">0000000000400568</span>  <span class="number">0000000000400568</span>  <span class="number">00000568</span>  <span class="number">2</span>**<span class="number">1</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">7</span> .gnu.version_r <span class="number">00000040</span>  <span class="number">0000000000400588</span>  <span class="number">0000000000400588</span>  <span class="number">00000588</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">8</span> .rela.dyn     <span class="number">00000030</span>  <span class="number">00000000004005</span>c8  <span class="number">00000000004005</span>c8  <span class="number">000005</span>c8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">9</span> .rela.plt     <span class="number">000000</span>a8  <span class="number">00000000004005f</span>8  <span class="number">00000000004005f</span>8  <span class="number">000005f</span>8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> <span class="number">10</span> .init         <span class="number">0000001</span>a  <span class="number">00000000004006</span>a0  <span class="number">00000000004006</span>a0  <span class="number">000006</span>a0  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> <span class="number">11</span> .plt          <span class="number">00000080</span>  <span class="number">00000000004006</span>c0  <span class="number">00000000004006</span>c0  <span class="number">000006</span>c0  <span class="number">2</span>**<span class="number">4</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> <span class="number">12</span> .plt.got      <span class="number">00000008</span>  <span class="number">0000000000400740</span>  <span class="number">0000000000400740</span>  <span class="number">00000740</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> <span class="number">13</span> .text         <span class="number">000001f</span>2  <span class="number">0000000000400750</span>  <span class="number">0000000000400750</span>  <span class="number">00000750</span>  <span class="number">2</span>**<span class="number">4</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> <span class="number">14</span> .fini         <span class="number">00000009</span>  <span class="number">0000000000400944</span>  <span class="number">0000000000400944</span>  <span class="number">00000944</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> <span class="number">15</span> .rodata       <span class="number">00000008</span>  <span class="number">0000000000400950</span>  <span class="number">0000000000400950</span>  <span class="number">00000950</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> <span class="number">16</span> .eh_frame_hdr <span class="number">0000004</span>c  <span class="number">0000000000400958</span>  <span class="number">0000000000400958</span>  <span class="number">00000958</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> <span class="number">17</span> .eh_frame     <span class="number">00000154</span>  <span class="number">00000000004009</span>a8  <span class="number">00000000004009</span>a8  <span class="number">000009</span>a8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> <span class="number">18</span> .init_array   <span class="number">00000010</span>  <span class="number">0000000000600</span>df8  <span class="number">0000000000600</span>df8  <span class="number">00000</span>df8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> <span class="number">19</span> .fini_array   <span class="number">00000008</span>  <span class="number">0000000000600e08</span>  <span class="number">0000000000600e08</span>  <span class="number">00000e08</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> <span class="number">20</span> .jcr          <span class="number">00000008</span>  <span class="number">0000000000600e10</span>  <span class="number">0000000000600e10</span>  <span class="number">00000e10</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> <span class="number">21</span> .dynamic      <span class="number">000001e0</span>  <span class="number">0000000000600e18</span>  <span class="number">0000000000600e18</span>  <span class="number">00000e18</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> <span class="number">22</span> .got          <span class="number">00000008</span>  <span class="number">0000000000600f</span>f8  <span class="number">0000000000600f</span>f8  <span class="number">00000f</span>f8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> <span class="number">23</span> .got.plt      <span class="number">00000050</span>  <span class="number">0000000000601000</span>  <span class="number">0000000000601000</span>  <span class="number">00001000</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> <span class="number">24</span> .data         <span class="number">00000010</span>  <span class="number">0000000000601050</span>  <span class="number">0000000000601050</span>  <span class="number">00001050</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> <span class="number">25</span> .bss          <span class="number">00000118</span>  <span class="number">0000000000601060</span>  <span class="number">0000000000601060</span>  <span class="number">00001060</span>  <span class="number">2</span>**<span class="number">5</span></span><br><span class="line">                  ALLOC</span><br><span class="line"> <span class="number">26</span> .comment      <span class="number">00000035</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00001060</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>
<p>其中CONTENT表示该段在文件中存在。比较重要的是.text,.data, .rodata和 .comment段。<br>其他段见下表，摘自《程序员的自我修养》<br><img src="/images/elf-2.png"></p>
<ul>
<li>自定义段：GCC提供了扩展机制，可以指定变量所处的段。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__attribute__((<span class="built_in">section</span>(<span class="string">&quot;foo&quot;</span>))) <span class="type">int</span> a = <span class="number">29</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .interp       0000001c  0000000000400238  0000000000400238  00000238  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  1 .note.ABI-tag 00000020  0000000000400254  0000000000400254  00000254  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .note.gnu.build-id 00000024  0000000000400274  0000000000400274  00000274  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .gnu.hash     0000001c  0000000000400298  0000000000400298  00000298  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .dynsym       00000048  00000000004002b8  00000000004002b8  000002b8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  5 .dynstr       00000038  0000000000400300  0000000000400300  00000300  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  6 .gnu.version  00000006  0000000000400338  0000000000400338  00000338  2**1</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  7 .gnu.version_r 00000020  0000000000400340  0000000000400340  00000340  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  8 .rela.dyn     00000018  0000000000400360  0000000000400360  00000360  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  9 .rela.plt     00000018  0000000000400378  0000000000400378  00000378  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> 10 .init         0000001a  0000000000400390  0000000000400390  00000390  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 11 .plt          00000020  00000000004003b0  00000000004003b0  000003b0  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 12 .plt.got      00000008  00000000004003d0  00000000004003d0  000003d0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 13 .text         000001a2  00000000004003e0  00000000004003e0  000003e0  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 14 .fini         00000009  0000000000400584  0000000000400584  00000584  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 15 .rodata       00000004  0000000000400590  0000000000400590  00000590  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> 16 .eh_frame_hdr 0000003c  0000000000400594  0000000000400594  00000594  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> 17 .eh_frame     00000114  00000000004005d0  00000000004005d0  000005d0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> 18 .init_array   00000008  0000000000600e10  0000000000600e10  00000e10  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 19 .fini_array   00000008  0000000000600e18  0000000000600e18  00000e18  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 20 .jcr          00000008  0000000000600e20  0000000000600e20  00000e20  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 21 .dynamic      000001d0  0000000000600e28  0000000000600e28  00000e28  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 22 .got          00000008  0000000000600ff8  0000000000600ff8  00000ff8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 23 .got.plt      00000020  0000000000601000  0000000000601000  00001000  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 24 .data         00000010  0000000000601020  0000000000601020  00001020  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 25 foo           00000004  0000000000601030  0000000000601030  00001030  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 26 .bss          00000004  0000000000601034  0000000000601034  00001034  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line"> 27 .comment      00000035  0000000000000000  0000000000000000  00001034  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>
<p>使用readelf -h main</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x4003e0</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          6664 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         32</span><br><span class="line">  Section header string table index: 29</span><br></pre></td></tr></table></figure>
<p>上述为ELF文件头存储的信息。</p>
<ul>
<li><p>magic：魔数，用来确定文件类型，操作系统在加载可执行文件的时候会确定魔数是否正确。<br>使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">readelf -S main</span><br></pre></td></tr></table></figure>
<p>查看文件段表的内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">There are 32 section headers, starting at offset 0x1a08:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000400238  00000238</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE             0000000000400254  00000254</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE             0000000000400274  00000274</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH         0000000000400298  00000298</span><br><span class="line">       000000000000001c  0000000000000000   A       5     0     8</span><br><span class="line">  [ 5] .dynsym           DYNSYM           00000000004002b8  000002b8</span><br><span class="line">       0000000000000048  0000000000000018   A       6     1     8</span><br><span class="line">  [ 6] .dynstr           STRTAB           0000000000400300  00000300</span><br><span class="line">       0000000000000038  0000000000000000   A       0     0     1</span><br><span class="line">  [ 7] .gnu.version      VERSYM           0000000000400338  00000338</span><br><span class="line">       0000000000000006  0000000000000002   A       5     0     2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED          0000000000400340  00000340</span><br><span class="line">       0000000000000020  0000000000000000   A       6     1     8</span><br><span class="line">  [ 9] .rela.dyn         RELA             0000000000400360  00000360</span><br><span class="line">       0000000000000018  0000000000000018   A       5     0     8</span><br><span class="line">  [10] .rela.plt         RELA             0000000000400378  00000378</span><br><span class="line">       0000000000000018  0000000000000018  AI       5    24     8</span><br><span class="line">  [11] .init             PROGBITS         0000000000400390  00000390</span><br><span class="line">       000000000000001a  0000000000000000  AX       0     0     4</span><br><span class="line">  [12] .plt              PROGBITS         00000000004003b0  000003b0</span><br><span class="line">       0000000000000020  0000000000000010  AX       0     0     16</span><br><span class="line">  [13] .plt.got          PROGBITS         00000000004003d0  000003d0</span><br><span class="line">       0000000000000008  0000000000000000  AX       0     0     8</span><br><span class="line">  [14] .text             PROGBITS         00000000004003e0  000003e0</span><br><span class="line">       00000000000001a2  0000000000000000  AX       0     0     16</span><br><span class="line">  [15] .fini             PROGBITS         0000000000400584  00000584</span><br><span class="line">       0000000000000009  0000000000000000  AX       0     0     4</span><br><span class="line">  [16] .rodata           PROGBITS         0000000000400590  00000590</span><br><span class="line">       0000000000000004  0000000000000004  AM       0     0     4</span><br><span class="line">  [17] .eh_frame_hdr     PROGBITS         0000000000400594  00000594</span><br><span class="line">       000000000000003c  0000000000000000   A       0     0     4</span><br><span class="line">  [18] .eh_frame         PROGBITS         00000000004005d0  000005d0</span><br><span class="line">       0000000000000114  0000000000000000   A       0     0     8</span><br><span class="line">  [19] .init_array       INIT_ARRAY       0000000000600e10  00000e10</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [20] .fini_array       FINI_ARRAY       0000000000600e18  00000e18</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [21] .jcr              PROGBITS         0000000000600e20  00000e20</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [22] .dynamic          DYNAMIC          0000000000600e28  00000e28</span><br><span class="line">       00000000000001d0  0000000000000010  WA       6     0     8</span><br><span class="line">  [23] .got              PROGBITS         0000000000600ff8  00000ff8</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [24] .got.plt          PROGBITS         0000000000601000  00001000</span><br><span class="line">       0000000000000020  0000000000000008  WA       0     0     8</span><br><span class="line">  [25] .data             PROGBITS         0000000000601020  00001020</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [26] foo               PROGBITS         0000000000601030  00001030</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [27] .bss              NOBITS           0000000000601034  00001034</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     1</span><br><span class="line">  [28] .comment          PROGBITS         0000000000000000  00001034</span><br><span class="line">       0000000000000035  0000000000000001  MS       0     0     1</span><br><span class="line">  [29] .shstrtab         STRTAB           0000000000000000  000018f5</span><br><span class="line">       0000000000000110  0000000000000000           0     0     1</span><br><span class="line">  [30] .symtab           SYMTAB           0000000000000000  00001070</span><br><span class="line">       0000000000000678  0000000000000018          31    48     8</span><br><span class="line">  [31] .strtab           STRTAB           0000000000000000  000016e8</span><br><span class="line">       000000000000020d  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure>
<p>其中比较重要的是.rela.dyn（重定向表）.rela.plt（重定向表的信息）。</p>
</li>
<li><p>字符串表：集中存放然后使用偏移量来引用。<br><img src="/images/elf-3.png"><br><img src="/images/elf-4.png"></p>
</li>
<li><p>符号：链接的接口，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。使用nm查看符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000601030 D a</span><br><span class="line">0000000000601034 B __bss_start</span><br><span class="line">0000000000601034 b completed.7594</span><br><span class="line">0000000000601020 D __data_start</span><br><span class="line">0000000000601020 W data_start</span><br><span class="line">0000000000400410 t deregister_tm_clones</span><br><span class="line">0000000000400490 t __do_global_dtors_aux</span><br><span class="line">0000000000600e18 t __do_global_dtors_aux_fini_array_entry</span><br><span class="line">0000000000601028 D __dso_handle</span><br><span class="line">0000000000600e28 d _DYNAMIC</span><br><span class="line">0000000000601034 D _edata</span><br><span class="line">0000000000601038 B _end</span><br><span class="line">0000000000400584 T _fini</span><br><span class="line">00000000004004b0 t frame_dummy</span><br><span class="line">0000000000600e10 t __frame_dummy_init_array_entry</span><br><span class="line">00000000004006e0 r __FRAME_END__</span><br><span class="line">0000000000601000 d _GLOBAL_OFFSET_TABLE_</span><br><span class="line">                 w __gmon_start__</span><br><span class="line">0000000000400594 r __GNU_EH_FRAME_HDR</span><br><span class="line">0000000000400390 T _init</span><br><span class="line">0000000000600e18 t __init_array_end</span><br><span class="line">0000000000600e10 t __init_array_start</span><br><span class="line">0000000000400590 R _IO_stdin_used</span><br><span class="line">                 w _ITM_deregisterTMCloneTable</span><br><span class="line">                 w _ITM_registerTMCloneTable</span><br><span class="line">0000000000600e20 d __JCR_END__</span><br><span class="line">0000000000600e20 d __JCR_LIST__</span><br><span class="line">                 w _Jv_RegisterClasses</span><br><span class="line">0000000000400580 T __libc_csu_fini</span><br><span class="line">0000000000400510 T __libc_csu_init</span><br><span class="line">                 U __libc_start_main@@GLIBC_2.2.5</span><br><span class="line">00000000004004ea T main</span><br><span class="line">0000000000400450 t register_tm_clones</span><br><span class="line">00000000004003e0 T _start</span><br><span class="line">0000000000601030 D __TMC_END__</span><br><span class="line">00000000004004d6 T _Z4funcii</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="强符号和弱符号"><a href="#强符号和弱符号" class="headerlink" title="强符号和弱符号"></a>强符号和弱符号</h3><ul>
<li>强符号:函数和初始化的全局变量</li>
<li>弱符号：未初始化的全局变量，也可以通过GCC的 __attribute ((weak)) 来定义一个强符号为弱符号。</li>
</ul>
<h3 id="程序指令和数据为什么分开放"><a href="#程序指令和数据为什么分开放" class="headerlink" title="程序指令和数据为什么分开放"></a>程序指令和数据为什么分开放</h3><ul>
<li>程序被装载之后，数据和指令分别被映射到两个虚存区域，数据区可读可写，指令区只读。</li>
<li>指令区和数据区的分离有利于提高程序的局部性，提高缓存命中率。</li>
<li><font color=orange>系统中运行多个程序的副本时，指令都相同，内存中需要保存一份该程序的指令部分。</font></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言系列：GC算法</title>
    <url>/2021/09/02/Go%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97%EF%BC%9AGC%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>c++内存管理系列：mmap原理</title>
    <url>/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Ammap%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>内存映射，简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间&lt;—-&gt;用户空间两者之间需要大量数据传输等操作的话效率是非常高的。</p>
<h3 id="传统的读写文件"><a href="#传统的读写文件" class="headerlink" title="传统的读写文件"></a>传统的读写文件</h3><p>一般来说，修改一个文件的内容需要如下3个步骤：</p>
<ul>
<li>把文件内容读入到内存中。</li>
<li>修改内存中的内容。</li>
<li>把内存的数据写入到文件中。</li>
</ul>
<p><img src="/images/mmap-1.png"><br>从图中可以看出，页缓存(page cache) 是读写文件时的中间层，内核使用<font color=orange>页缓存</font>与文件的数据块关联起来。所以应用程序读写文件时，实际操作的是页缓存。</p>
<h3 id="mmap读写文件"><a href="#mmap读写文件" class="headerlink" title="mmap读写文件"></a>mmap读写文件</h3><p>mmap并不分配空间, 只是将文件映射到调用进程的地址空间里（但是会占掉你的 virutal memory）, 然后你就可以用memcpy等操作写文件, 而不用write()了.写完后，内存中的内容并不会立即更新到文件中，而是有一段时间的延迟，你可以调用msync()来显式同步一下, 这样你所写的内容就能立即保存到文件里了.这点应该和驱动相关。 不过通过mmap来写文件这种方式没办法增加文件的长度, 因为要映射的长度在调用mmap()的时候就决定了.如果想取消内存映射，可以调用munmap()来取消内存映射。</p>
<p>函数调用的格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">//返回:若成功则为被映射区的起始地址，若出错则为MAP_FAILED</span></span><br></pre></td></tr></table></figure>
<p>其中addr可以指定描述符fd应该被映射到的进程内空间的起始地址。它通常被指定为一个空指针，这样告诉内核自己去选择起始地址。无论哪种情况下，该函数的返回值都是描述符fd所映射到内存的起始地址。</p>
<p>len是映射到调用进程地址空间中的字节数，它从被映射文件开头起第offset个字节处开始算。offset通常设置为0。</p>
<p>内存映射区的保护由prot参数指定，该参数的常见值是代表读写访问的PROT_READ|PROT_WRITE</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prot          说明</span><br><span class="line">PROT_READ    数据可读</span><br><span class="line">PROT_WRITE   数据可写</span><br><span class="line">PROT_EXEC    数据可执行</span><br><span class="line">PROT_NONE    数据不可访问</span><br></pre></td></tr></table></figure>

<p>从传统读写文件的过程中，我们可以发现有个地方可以优化：如果可以直接在用户空间读写 页缓存，那么就可以免去将 页缓存 的数据复制到用户空间缓冲区的过程。<br>那么，有没有这样的技术能实现上面所说的方式呢？答案是肯定的，就是 mmap。<br>使用 mmap 系统调用可以将用户空间的虚拟内存地址与文件进行映射（绑定），对映射后的虚拟内存地址进行读写操作就如同对文件进行读写操作一样。原理如图所示：</p>
<p><img src="/images/mmap-2.png"></p>
<p>前面我们介绍过，读写文件都需要经过 页缓存，所以 mmap 映射的正是文件的 页缓存，而非磁盘中的文件本身。由于 mmap 映射的是文件的 页缓存，所以就涉及到同步的问题，即 页缓存 会在什么时候把数据同步到磁盘。<br>Linux 内核并不会主动把 mmap 映射的 页缓存 同步到磁盘，而是需要用户主动触发。同步 mmap 映射的内存到磁盘有 4 个时机：</p>
<ul>
<li>调用 msync 函数主动进行数据同步（主动）。</li>
<li>调用 munmap 函数对文件进行解除映射关系时（主动）。</li>
<li>进程退出时（被动）。</li>
<li>系统关机时（被动）。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p>
<ul>
<li><p>进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</p>
<ul>
<li><p>进程在用户空间调用库函数mmap;</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址;</p>
</li>
<li><p>为此虚拟区分配一个vmareastruct结构，接着对这个结构的各个域进行了初始化;</p>
</li>
<li><p>将新建的虚拟区结构（vmareastruct）插入进程的虚拟地址区域链表或树中</p>
</li>
</ul>
</li>
<li><p>调用内核空间的系统调用函数 mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</p>
<ul>
<li>为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</li>
<li>通过该文件的文件结构体，链接到 file_operations 模块，调用内核函数mmap ：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br></pre></td></tr></table></figure>
  不同于用户空间库函数。</li>
<li>内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</li>
<li>通过remappfnrange函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。</li>
</ul>
</li>
<li><p>进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝</p>
<ul>
<li>进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</li>
<li>缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</li>
<li>调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</li>
<li>之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</li>
</ul>
</li>
<li><p>注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：malloc底层原理(ptmalloc)</title>
    <url>/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Aptmalloc/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="linux进程地址空间"><a href="#linux进程地址空间" class="headerlink" title="linux进程地址空间"></a>linux进程地址空间</h3><p><img src="/images/malloc-1.png"></p>
<p>如上图所示在一个32位系统中，可寻址的空间大小是4G，linux系统下0-3G是用户模式，3-4G是内核模式。而在用户模式下又分为代码段、数据段、.bss段、堆、栈。其中代码段主要存放进程的可执行二进制代码，字符串字面值和只读变量。数据段存放已经初始化且初始值非0的全局变量和局部静态变量。bss段则存放未初始化或初始值为0的全局变量和局部静态变量。而堆段则是存放由用户动态分配内存存储的变量。栈段则主要存储局部变量、函数参数、返回地址等。</p>
<p>bss段、数据段和代码段是可执行程序编译时的分段，运行时还需要栈和堆。将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和bss段的加载，并在内存中为这些段分配空间。栈也由操作系统分配和管理而堆则是由程序员自己管理。</p>
<h3 id="malloc内存单元"><a href="#malloc内存单元" class="headerlink" title="malloc内存单元"></a>malloc内存单元</h3><p>chunk结构体<br>        <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<!--more-->

<ul>
<li><p>源码注释写到：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Chunks of memory are maintained using a `boundary tag&#x27; method as</span></span><br><span class="line"><span class="comment">described in e.g., Knuth or Standish.  (See the paper by Paul</span></span><br><span class="line"><span class="comment">Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span></span><br><span class="line"><span class="comment">survey of such techniques.)  Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">in the front of each chunk and at the end.  This makes</span></span><br><span class="line"><span class="comment">consolidating fragmented chunks into bigger chunks very fast.  The</span></span><br><span class="line"><span class="comment">size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">in use.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             Size of previous chunk, if allocated            | |</span></span><br><span class="line"><span class="comment">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             Size of chunk, in bytes                       |M|P|</span></span><br><span class="line"><span class="comment">    mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             User data starts here...                          .</span></span><br><span class="line"><span class="comment">        .                                                               .</span></span><br><span class="line"><span class="comment">        .             (malloc_usable_size() bytes)                      .</span></span><br><span class="line"><span class="comment">        .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             Size of chunk                                     |</span></span><br><span class="line"><span class="comment">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>大概意思就是使用了boundary tag技术，也就是free block上下两端加cookie，还记得vc6和STL的allocator章节的图，就像下面这样。</p>
<p>  <img src="/images/cookie.png"></p>
</li>
<li><p>注释中继续描述了chunk的组织方式——双向链表.</p>
<pre><code>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             Size of previous chunk                            |</span></span><br><span class="line"><span class="comment">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `head:&#x27; |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="comment">    mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="comment">        .                                                               .</span></span><br><span class="line"><span class="comment">        .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `foot:&#x27; |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="comment">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        */</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>我们看一下结构体中的变量。</p>
<ul>
<li>prev_size：如果前一个chunk是空闲的，该域表示前一个chunk的大小，如果前一个chunk不空闲，该域无意义。注意：这里的前一个指的是存储物理相邻地址较低的那一个chunk。</li>
<li>size：该 chunk 的大小，大小必须是 2 SIZE_SZ 的整数倍。如果申请的内存大小不是 2 SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示：<ul>
<li>A: NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程（分配区&#x2F;arena），1表示不属于，0表示属于。</li>
<li>M: IS_MAPPED，他表示当前chunk是从哪个内存区域获得的虚拟内存。M为1表示该chunk是从mmap映射区域分配的，否则是从heap区域分配的。</li>
<li>P: PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的P位都会被设置为1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲chunk之间的合并。</li>
</ul>
</li>
<li>fd，bk： chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
</ul>
</li>
<li>fd_nextsize， bk_nextsize：也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul>
<li>fd_nextsize指向下一个比当前chunk size小的第一个空闲chunk，不包含 bin 的头指针。</li>
<li>bk_nextszie指向上一个比当前chunk size大的第一个空闲chunk，不包含 bin 的头指针。</li>
<li>large bins中的空闲chunk是按照大小排序的。这样做可以避免在寻找合适chunk 时挨个遍历。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/malloc-4.png"></p>
<p>上图展示了chunk分配前后的变化，利用了嵌入式指针技术，这个技术在VC6和STL allocator中应用也很多。</p>
<h3 id="linux内存分配"><a href="#linux内存分配" class="headerlink" title="linux内存分配"></a>linux内存分配</h3><p>linux下可以使用系统调用</p>
<ul>
<li><p>mmap：内核将硬盘文件的内容直接映射到内存，任何应用程序都可通过 Linux 的 mmap() 系统调用请求这种映射。</p>
<ul>
<li>内存映射是一种方便高效的文件 I&#x2F;O 方式， 因而被用于装载动态共享库。</li>
<li>用户也可创建匿名内存映射，该映射没有对应的文件，可用于存放程序数据。<ul>
<li>在 Linux 中，若通过 malloc() 请求一大块内存，C 运行库将创建一个匿名内存映射，而不使用堆内存。“大块”意味着比阈值MMAP_THRESHOLD还大，缺省为 128KB，可通过 mallopt() 调整。</li>
</ul>
</li>
<li>mmap 映射区向下扩展，堆向上扩展，两者相对扩展，直到耗尽虚拟地址空间中的剩余区域。</li>
</ul>
</li>
<li><p>sbrk() 或brk()：start_brk和brk分别是堆的起始和终止地址，我们使用malloc动态分配的内存就在这之间。我们可以使用系统调用sbrk() 或brk()增加brk的值，达到增大堆空间的效果，但是系统调用代价太大，涉及到用户态和内核态的相互转换。所以，实际中系统分配较大的堆空间，进程通过malloc()库函数在堆上进行空间动态分配，堆如果不够用malloc可以进行系统调用，增大brk的值。</p>
<ul>
<li>两个系统调用的源码为：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">brk</span><span class="params">(<span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>;</span><br></pre></td></tr></table></figure>
  brk函数将break指针直接设置为某个地址，而sbrk将break指针从当前位置移动increment所指定的增量。brk在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break指针移动之前所指向的地址，否则返回(void *)-1。<br>  <font color=orange>如果将increment设置为0，则可以获得当前break的地址。另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有一小块可用内存地址）。</font></li>
</ul>
</li>
</ul>
<h3 id="malloc实现"><a href="#malloc实现" class="headerlink" title="malloc实现"></a>malloc实现</h3><p>linux下malloc源码分析具体可见《glibc内存管理ptmalloc源代码分析》一书.下面对其思想进行概括，主要掌握其思想，细节实现不在此讨论。</p>
<p>由于brk&#x2F;sbrk&#x2F;mmap属于系统调用，如果每次申请内存，都调用这三个函数中的一个，那么每次都要产生系统调用开销（即cpu从用户态切换到内核态的上下文切换，这里要保存用户态数据，等会还要切换回用户态），这是非常影响性能的；其次，这样申请的内存容易产生碎片，因为堆是从低地址到高地址，如果低地址的内存没有被释放，高地址的内存就不能被回收。鉴于此，malloc采用的是内存池的实现方式，malloc内存池实现方式更类似于STL分配器和memcached的内存池，先申请一大块内存，然后将内存分成不同大小的内存块，然后用户申请内存时，直接从内存池中选择一块相近的内存块即可。<br><img src="/images/malloc-3.png"></p>
<p>源码注释对bin的大小描述为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what&#x27;s left</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>内存池保存在bins这个长128的数组中，每个元素都是一双向个链表。</p>
<ul>
<li>bins[0]目前没有使用</li>
<li>bins[1]的链表称为unsorted_list，用于维护free释放的chunk。</li>
<li>bins[2,63)的区间称为small_bins，用于维护＜512字节的内存块，其中每个元素对应的链表中的chunk大小相同，均为<font color=orange>index*8</font>。</li>
<li>bins[64,127)称为large_bins，用于维护&gt;512字节的内存块，每个元素对应的链表中的chunk大小不同，index越大，链表中chunk的内存大小相差越大，例如: 下标为64的chunk大小介于[512, 512+64)，下标为95的chunk大小介于[2k+1,2k+512)。同一条链表上的chunk，按照从小到大的顺序排列。<br>malloc将内存分成了大小不同的chunk，然后通过bins来组织起来。</li>
<li>malloc将相似大小的chunk（图中可以看出同一链表上的chunk大小差不多）用双向链表链接起来，这样一个链表被称为一个bin。malloc一共维护了128个bin，并使用一个数组来存储这些bin。</li>
</ul>
<p>数组中第一个为<font color=orange>unsorted bin</font>，数组编号前2到前64的bin为<font color=orange>small bin</font>，同一个small bin中的chunk具有相同的大小，两个相邻的small bin中的chunk大小相差8bytes。small bins后面的bin被称作<font color=orange>large bin</font>。large bins中的每一个bin分别包含了一个给定范围内的chunk，其中的chunk按大小序排列。large bin的每个bin相差64字节。</p>
<p>malloc除了有unsorted bin，small bin，large bin三个bin之外，还有一个<font color=orange>fast bin</font>。一般的情况是，程序在运行时会经常需要申请和释放一些较小的内存空间。当分配器合并了相邻的几个小的 chunk 之后，也许马上就会有另一个小块内存的请求，这样分配器又需要从大的空闲内存中切分出一块，这样无疑是比较低效的，故而，malloc 中在分配过程中引入了 fast bins，不大于 max_fast(默认值为 64B)的 chunk 被释放后，首先会被放到 fast bins中，fast bins 中的 chunk 并不改变它的使用标志 P。这样也就无法将它们合并，当需要给用户分配的 chunk 小于或等于 max_fast 时，malloc 首先会在 fast bins 中查找相应的空闲块，然后才会去查找 bins 中的空闲 chunk。在某个特定的时候，malloc 会遍历 fast bins 中的 chunk，将相邻的空闲 chunk 进行合并，并将合并后的 chunk 加入 unsorted bin 中，然后再将 unsorted bin 里的 chunk 加入 bins 中。</p>
<p>unsorted bin 的队列使用 bins 数组的第一个，如果被用户释放的 chunk 大于 max_fast，或者 fast bins 中的空闲 chunk 合并后，这些 chunk 首先会被放到 unsorted bin 队列中，在进行 malloc 操作的时候，如果在 fast bins 中没有找到合适的 chunk，则malloc 会先在 unsorted bin 中查找合适的空闲 chunk，然后才查找 bins。如果 unsorted bin 不能满足分配要求。 malloc便会将 unsorted bin 中的 chunk 加入 bins 中。然后再从 bins 中继续进行查找和分配过程。从这个过程可以看出来，unsorted bin 可以看做是 bins 的一个缓冲区，增加它只是为了加快分配的速度。（其实感觉在这里还利用了局部性原理，常用的内存块大小差不多，从unsorted bin这里取就行了，这个和TLB之类的都是异曲同工之妙啊！）</p>
<p>除了上述四种bins之外，malloc还有三种内存区。</p>
<ul>
<li>当fast bin和bins都不能满足内存需求时，malloc会设法在top chunk中分配一块内存给用户；top chunk为在mmap区域分配一块较大的空闲内存模拟sub-heap。（比较大的时候） &gt;top chunk是堆顶的chunk，堆顶指针brk位于top chunk的顶部。移动brk指针，即可扩充top chunk的大小。当top chunk大小超过128k(可配置)时，会触发malloc_trim操作，调用sbrk(-size)将内存归还操作系统。</li>
<li>当chunk足够大，fast bin和bins都不能满足要求，甚至top chunk都不能满足时，malloc会从mmap来直接使用内存映射来将页映射到进程空间，这样的chunk释放时，直接解除映射，归还给操作系统。（极限大的时候）</li>
<li>Last remainder是另外一种特殊的chunk，就像top chunk和mmaped chunk一样，不会在任何bins中找到这种chunk。当需要分配一个small chunk,但在small bins中找不到合适的chunk，如果last remainder chunk的大小大于所需要的small chunk大小，last remainder chunk被分裂成两个chunk，其中一个chunk返回给用户，另一个chunk变成新的last remainder chunk。（这个应该是fast bins中也找不到合适的时候，用于极限小的）<br>我们再来看这个分配前后的图：<br><img src="/images/malloc-4.png"></li>
</ul>
<p>由之前的分析可知malloc利用chunk结构来管理内存块，malloc就是由不同大小的chunk链表组成的。malloc会给用户分配的空间的前后加上一些控制信息，用这样的方法来记录分配的信息，以便完成分配和释放工作。chunk指针指向chunk开始的地方,图中的mem指针才是真正返回给用户的内存指针。</p>
<ul>
<li>chunk 的第二个域的最低一位为P，它表示前一个块是否在使用中，P 为 0 则表示前一个 chunk 为空闲，这时chunk的第一个域 prev_size 才有效，prev_size 表示前一个 chunk 的 size，程序可以使用这个值来找到前一个 chunk 的开始地址。当 P 为 1 时，表示前一个 chunk 正在使用中，prev_size程序也就不可以得到前一个 chunk 的大小。不能对前一个 chunk 进行任何操作。malloc分配的第一个块总是将 P 设为 1，以防止程序引用到不存在的区域。</li>
<li>Chunk 的第二个域的倒数第二个位为M，他表示当前 chunk 是从哪个内存区域获得的虚拟内存。M 为 1 表示该 chunk 是从 mmap 映射区域分配的，否则是从 heap 区域分配的。</li>
<li>Chunk 的第二个域倒数第三个位为 A，表示该 chunk 属于主分配区或者非主分配区，如果属于非主分配区，将该位置为 1，否则置为 0。<br>当chunk空闲时，其M状态是不存在的，只有AP状态，原本是用户数据区的地方存储了四个指针，指针fd指向后一个空闲的chunk,而bk指向前一个空闲的chunk，malloc通过这两个指针将大小相近的chunk连成一个双向链表。在large bin中的空闲chunk，还有两个指针，fd_nextsize和bk_nextsize，用于加快在large bin中查找最近匹配的空闲chunk。不同的chunk链表又是通过bins或者fastbins来组织的。</li>
</ul>
<h3 id="malloc步骤"><a href="#malloc步骤" class="headerlink" title="malloc步骤"></a>malloc步骤</h3><p>malloc 内存分配流程</p>
<ol>
<li>如果分配内存&lt;512字节，则通过内存大小定位到smallbins对应的index上(floor(size&#x2F;8)).<ul>
<li>如果smallbins[index]为空，进入步骤3.</li>
<li>如果smallbins[index]非空，直接返回第一个chunk.</li>
</ul>
</li>
<li>如果分配内存&gt;512字节，则定位到largebins对应的index上.<ul>
<li>如果largebins[index]为空，进入步骤3.</li>
<li>如果largebins[index]非空，扫描链表，找到第一个大小最合适的chunk，如size&#x3D;12.5K，则使用chunk B，剩下的0.5k放入unsorted_list中</li>
</ul>
</li>
<li>遍历unsorted_list，查找合适size的chunk，如果找到则返回；否则，将这些chunk都归类放到smallbins和largebins里面.</li>
<li>index++从更大的链表中查找，直到找到合适大小的chunk为止，找到后将chunk拆分，并将剩余的加入到unsorted_list中.</li>
<li>如果还没有找到，那么使用top chunk.</li>
<li>内存&lt;128k，使用brk；内存&gt;128k，使用mmap获取新内存.</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。</li>
<li>虚拟内存并不是每次malloc后都增长，是与上一节说的堆顶没发生变化有关，因为可重用堆顶内剩余的空间，这样的malloc是很轻量快速的。</li>
<li>如果虚拟内存发生变化，基本与分配内存量相当，因为虚拟内存是计算虚拟地址空间总大小。</li>
<li>物理内存的增量很少，是因为malloc分配的内存并不就马上分配实际存储空间，只有第一次使用，如第一次memset后才会分配。</li>
<li>由于每个物理内存页面大小是4k，不管memset其中的1k还是5k、7k，实际占用物理内存总是4k的倍数。所以物理内存的增量总是4k的倍数。</li>
</ul>
<p><font color=red>因此，不是malloc后就马上占用实际内存，而是第一次使用时发现虚存对应的物理页面未分配，产生缺页中断，才真正分配物理页面，同时更新进程页面的映射关系。这也是Linux虚拟内存管理的核心概念之一。</font></p>
<h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><p>free释放内存时，有两种情况：</p>
<ol>
<li>chunk和top chunk相邻，则和top chunk合并</li>
<li>chunk和top chunk不相邻，则直接插入到unsorted_list中<br><img src="/images/malloc-5.png"></li>
</ol>
<p>如上图示: top chunk是堆顶的chunk，堆顶指针brk位于top chunk的顶部。移动brk指针，即可扩充top chunk的大小。<font color=red>当top chunk大小超过128k(可配置)时，会触发malloc_trim操作，调用sbrk(-size)将内存归还操作系统。</font></p>
<p>以上图chunk分布图为例，按照glibc的内存分配策略，我们考虑下如下场景(假设brk其实地址是512k)：</p>
<p>malloc 40k内存，即chunkA，brk &#x3D; 512k + 40k &#x3D; 552k malloc 50k内存，即chunkB，brk &#x3D; 552k + 50k &#x3D; 602k malloc 60k内存，即chunkC，brk &#x3D; 602k + 60k &#x3D; 662k free chunkA。</p>
<p>此时，由于brk &#x3D; 662k，而释放的内存是位于[512k, 552k]之间，无法通过移动brk指针，将区域内内存交还操作系统，因此，在[512k, 552k]的区域内便形成了一个内存空洞即内存碎片。 按照glibc的策略，free后的chunkA区域由于不和top chunk相邻，因此，无法和top chunk 合并，应该挂在unsorted_list链表上。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>后分配的内存先释放,因为 ptmalloc 收缩内存是从 top chunk 开始,如果与 top chunk 相邻的 chunk 不能释放, top chunk 以下的 chunk 都无法释放。</li>
<li>多线程锁开销大， 需要避免多线程频繁分配释放。</li>
<li>内存从thread的areana中分配， 内存不能从一个arena移动到另一个arena， 就是说如果多线程使用内存不均衡，容易导致内存的浪费。 比如说线程1使用了300M内存，完成任务后glibc没有释放给操作系统，线程2开始创建了一个新的arena， 但是线程1的300M却不能用了。</li>
<li>每个chunk至少8字节的开销很大</li>
<li>不定期分配长生命周期的内存容易造成内存碎片，不利于回收。 64位系统最好分配32M以上内存，这是使用mmap的阈值。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：ptmalloc源码分析</title>
    <url>/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Aptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><ol>
<li>Main_arena</li>
</ol>
<p>在最开始实现的版本中只有一个main arena，每次分配内存都必须对主分配区加锁，分配完成后释放锁。 在多线程环境下由于锁的竞争效率低。<br>新版本增加了非主分配区。根据系统对分配区的争用情况非主分配区会增加，但不减少。</p>
<ul>
<li>主分配区访问heap和mmap区域（主分配区可以使用sbrk和mmap想操作系统申请虚拟内存），非主分配区只能访问mmap区域。</li>
<li>主分配区每次mmap向操作系统刚申请HEAP_MAX_SIZE（32位1MB,64位64MB）大小的虚拟内存。</li>
<li>当某一线程需要调用malloc()分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜索循环链表试图获得一个没有加锁的分配区。如果所有的分配区都已经加锁，那么malloc()会开辟一个新的分配区，把该分配区加入到全局分配区循环链表并加锁，然后使用该分配区进行分配内存操作。</li>
</ul>
<ol start="2">
<li>chunk<br>ptmalloc 在给用户分配的空间的前后加上了一些控制信息，用这样的方法来记录分配的信息，以便完成分配和释放工作。一个使用中的chunk（使用中，就是指还没有被free掉）在内存中的样子如图所示：<br><img src="/images/ptmalloc-1.png"></li>
</ol>
<ul>
<li>mem：返回给用户的内存指针</li>
<li>chunk控制位：P，它表示前一个块是否在使用中，M，他表示当前chunk是从哪个内存区域获得的虚拟内存（mmao&#x2F;brk）A，表示该chunk属于主分配区或者非主分配区。<br>下面展示了一个空闲chunk在内存中的状态<br><img src="/images/ptmalloc-2.png"></li>
</ul>
<ol start="3">
<li>bins</li>
</ol>
<p>ptmalloc将相似大小的chunk用双向链表链接起来，这样的一个链表被称为一个bin.ptmalloc一共维护了128个bin,并使用一个数组来存储这些bin.<br><img src="/images/ptmalloc-3.png"></p>
<ul>
<li><p>unsorted bins:bins数组的第一个</p>
</li>
<li><p>small bins:2<del>64的bin（chunk大小范围为16</del>512）</p>
</li>
<li><p>large bins:large bins中的每一个bin分别包含了一个给定范围内的chunk，其中的chunk按大小序排列。相同大小的chunk同样按照最近使用顺序排列。</p>
</li>
<li><p>fast bins:主要用来处理申请释放一些小的内存空间。后入先出。</p>
</li>
</ul>
<p>ptmalloc中在分配过程中引入了fast bins，不大于max_fast （默认值为64B）的chunk被释放后，首先会被放到fast bins 中，<font color = orange>fast bins中的chunk并不改变它的使用标志P。</font>这样也就无法将它们合并。当需要给用户分配的chunk小于或等于max_fast时，ptmalloc首先会在fast bins中查找相应的空闲块，然后才会去查找bins中的空闲chunk.</p>
<ul>
<li>Unsorted bin:bins的缓冲区</li>
</ul>
<p>如果被用户释放的chunk大于max_fast，或者fast bins中的空闲chunk合并后，这些chunk首先会被放到unsorted bin队列中,，在进行malloc操作的时候，如果在fast bins中没有找到合适的chunk，则ptmalloc会先在unsorted bin中查找合适的空闲chunk，然后才查找bins。</p>
<ol start="4">
<li>三种特殊的chunk</li>
</ol>
<ul>
<li>top chunk:fast bin和bin失效后的补救措施</li>
</ul>
<p><font color = orange>非主分配区</font>预先从mmap区域分配交大的空间内存模拟sub-heap。<br>Q1：什么时候分配？<br>A：第一次使用malloc时，主分配区在堆顶分配，子分配区mmap后在分配。</p>
<ul>
<li>mmaped chunk:top chunk不能分配的补救措施</li>
</ul>
<p>如果top chunk都不能分配，直接mmap一段内存到共享映射区。</p>
<ul>
<li>last reminder<br>当需要分配一个small chunk,但在small bins中找不到合适的chunk，如果last remainder chunk的大小大于所需要的small chunk大小，last remainder chunk被分裂成两个chunk，其中一个chunk返回给用户，另一个chunk变成新的last remainder chunk。<br><font color = orange>last remainder chunk主要通过提高内存分配的局部性来提高连续malloc（产生大量 small chunk）的效率。</font></li>
</ul>
<h3 id="brk和mmap注意事项"><a href="#brk和mmap注意事项" class="headerlink" title="brk和mmap注意事项"></a>brk和mmap注意事项</h3><ol>
<li>在使malloc之前，brk的值等于start_brk，也就是说heap大小为0.</li>
<li>ptmalloc在开始时，若请求的空间小于 mmap分配阈值（mmap threshold，默认值为128KB）时，主分配区会调用sbrk()增加一块大小为 (128 KB + chunk_size) align 4KB的空间作为heap。非主分配区会调用mmap映射一块大小为HEAP_MAX_SIZE（32位系统上默认为1MB，64位系统上默认为64MB）的空间作为sub-heap.</li>
<li>当用户请求内存分配时，首先会在这个区域内找一块合适的chunk给用户。当用户释放了heap 中的chunk时，ptmalloc又会使用fast bins和bins来组织空闲chunk。以备用户的下一次分配。</li>
<li>若需要分配的chunk大小小于mmap分配阈值，而heap空间又不够，则此时主分配区会通过sbrk()调用来增加heap大小，非主分配区会调用mmap映射一块新的sub-heap，也就是增加top chunk的大小，每次heap增加的值都会对齐到4KB。</li>
<li>当用户的请求超过mmap分配阈值，并且主分配区使用sbrk()分配失败的时候，或是非主分配区在top chunk中不能分配到需要的内存时，ptmalloc会尝试使用mmap()直接映射一块内存到进程内存空间。使用mmap()直接映射的chunk在释放时直接解除映射，而不再属于进程的内存空间.</li>
</ol>
<h3 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h3><ul>
<li>小于等于64字节：用pool算法分配。</li>
<li>64到512字节之间：在最佳匹配算法分配和pool算法分配中取一种合适的。</li>
<li>大于等于512字节：用最佳匹配算法分配。</li>
<li>大于等于mmap分配阈值（默认值128KB）：根据设置的mmap的分配策略进行分配，如果没有开启mmap分配阈值的动态调整机制，大于等于128KB就直接调用mmap()分配。否则，大于等于mmap分配阈值时才直接调用mmap()分配。</li>
</ul>
<h3 id="分配具体流程"><a href="#分配具体流程" class="headerlink" title="分配具体流程"></a>分配具体流程</h3><ol>
<li>获取分配区的锁，为了防止多个线程同时访问同一个分配区，在进行分配之前需要取得分配区域的锁。线程先查看线程私有实例中是否已经存在一个分配区，如果存在尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，否则，该线程搜索分配区循环链表试图获得一个空闲（没有加锁）的分配区。如果所有的分配区都已经加锁，那么ptmalloc会开辟一个新的分配区，把该分配区加入到全局分配区循环链表和线程的私有实例中并加锁，然后使用该分配区进行分配操作。开辟出来的新分配区一定为非主分配区，因为主分配区是从父进程那里继承来的。开辟非主分配区时会调用mmap()创建一个sub-heap，并设置好top chunk。</li>
<li>将用户的请求大小转换为实际需要分配的chunk空间大小。</li>
<li>判断所需分配chunk的大小是否满足chunk_size &lt;&#x3D; max_fast (max_fast 默认为 64B)，如果是的话，则转下一步，否则跳到第5步。</li>
<li>首先尝试在fast bins中取一个所需大小的chunk分配给用户。如果可以找到，则分配结束。否则转到下一步。</li>
<li>判断所需大小是否处在small bins中，即判断chunk_size &lt; 512B是否成立。如果chunk大小处在small bins中，则转下一步，否则转到第6步。</li>
<li>根据所需分配的chunk的大小，找到具体所在的某个small bin，从该bin的尾部摘取一个恰好满足大小的chunk。若成功，则分配结束，否则，转到下一步。</li>
<li>到了这一步，说明需要分配的是一块大的内存，或者small bins中找不到合适的 chunk。于是，ptmalloc首先会遍历fast bins中的chunk，将相邻的chunk进行合并，并链接到unsorted bin中，然后遍历unsorted bin中的chunk，如果unsorted bin只有一个chunk，并且这个chunk在上次分配时被使用过，并且所需分配的chunk大小属于small bins，并且chunk的大小大于等于需要分配的大小，这种情况下就直接将该chunk进行切割，分配结束，否则将根据chunk的空间大小将其放入small bins或是large bins中，遍历完成后，转入下一步。</li>
<li>到了这一步，说明需要分配的是一块大的内存，或者small bins和unsorted bin中都找不到合适的 chunk，并且fast bins和unsorted bin中所有的chunk都清除干净了。从large bins中按照“smallest-first，best-fit”原则，找一个合适的 chunk，从中划分一块所需大小的chunk，并将剩下的部分链接回到bins中。若操作成功，则分配结束，否则转到下一步。</li>
<li>如果搜索fast bins和bins都没有找到合适的chunk，那么就需要操作top chunk来进行分配了。判断top chunk大小是否满足所需chunk的大小，如果是，则从top chunk中分出一块来。否则转到下一步。</li>
<li>到了这一步，说明top chunk也不能满足分配要求，所以，于是就有了两个选择: 如果是主分配区，调用sbrk()，增加top chunk大小；如果是非主分配区，调用mmap来分配一个新的sub-heap，增加top chunk大小；或者使用mmap()来直接分配。在这里，需要依靠chunk的大小来决定到底使用哪种方法。判断所需分配的chunk大小是否大于等于 mmap分配阈值，如果是的话，则转下一步，调用mmap分配，否则跳到第12步，增加top chunk 的大小。</li>
<li>使用mmap系统调用为程序的内存空间映射一块chunk_size align 4kB大小的空间。 然后将内存指针返回给用户。</li>
<li>判断是否为第一次调用malloc，若是主分配区，则需要进行一次初始化工作，分配一块大小为(chunk_size + 128KB) align 4KB大小的空间作为初始的heap。若已经初始化过了，主分配区则调用sbrk()增加heap空间，分主分配区则在top chunk中切割出一个chunk，使之满足分配需求，并将内存指针返回给用户。</li>
</ol>
<p>参考文献：<br><a href="https://blog.csdn.net/namelij/article/details/121175864">csdn ptmalloc</a><br>《glic内存管理ptmalloc源码分析》</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：awk、sed命令</title>
    <url>/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Ased%E5%92%8Cawk%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><ol>
<li>命令行格式 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk [-F  field-separator]  &#x27;commands&#x27;  input-file(s)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>默认以空格或tab分割域，-F后可以跟一个自定义域分隔符。</li>
<li>commands表示awk命令，如print。</li>
<li>input-file表示输入的文件。</li>
</ul>
<ol start="2">
<li>shell脚本方式</li>
</ol>
<p>可以将所有awk命令插入一个文件，设置执行权限，然后将awk作为命令解释器（#!&#x2F;bin&#x2F;awk）执行。</p>
<ol start="3">
<li>将所有的awk命令插入一个单独文件，然后调用：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -f awk-script-file input-file(s)</span><br></pre></td></tr></table></figure>
其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。</li>
</ol>
<p>详细可以参考<a href="https://zhang.ge/1939.html">这篇文章</a> 和<a href="https://www.gnu.org/software/gawk/manual/gawk.html">官方文档</a></p>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><ol>
<li>运行原理</li>
</ol>
<ul>
<li>当用sed命令对文本进行处理的时候，sed先读取对象的文本文件的第一行到模式空间中。</li>
<li>当有内容进入“模式空间”时，sed的编辑命令对模式空间中的内容进行编辑操作（修改，替换，删除，追加，显示等等）</li>
<li>模式空间中的内容编辑处理完成之后，sed把此内容通过标准输出（默认为显示器）打印出来，并删除模式空间中的内容。</li>
<li>第一行处理结束。从新读取第二行的内容进行处理，直到最后一行。</li>
</ul>
<ol start="2">
<li>使用</li>
</ol>
<p><a href="https://coolshell.cn/articles/9104.html">参考这篇文章应该就够了</a></p>
<h3 id="两者区别和联系"><a href="#两者区别和联系" class="headerlink" title="两者区别和联系"></a>两者区别和联系</h3><ul>
<li><p>sed的核心是正则，主要处理“行问题”。</p>
</li>
<li><p>awk的核心是格式化，主要处理“列问题”。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：shell命令和脚本执行原理</title>
    <url>/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9Ashell%E5%91%BD%E4%BB%A4%E5%92%8C%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a>shell命令</h3><p>shell不属于内核，而是以内核之外的用户态方式运行。因此它就相当于操作系统的一层外壳，为用户提供使用操作系统的接口。<br>shell命令分为内置命令和外部命令，如下图，cd是外部命令，cat等都是外部命令。</p>
<p><img src="/images/shell-1.png"><br>当我们在命令行输入一个命令之后，会发生什么？</p>
<ul>
<li>检查用户输入的命令是否是一个内部命令，如果不是检查是不是一个应用程序；</li>
<li>shell在搜索路径或者环境变量中找应用程序；</li>
<li>如果不是一个外部命令并且没有查找到可执行文件，显示错误信息；- 如果成功找到，内部命令或者应用程序会被分解为系统调用传给内核，内核完成工作。</li>
</ul>
<p><font color = green>像cd，pwd这些内置命令是属于Shell的一部分，当Shell一运行起来就随Shell加载入内存，因此，当我们在命令行上输入这些命令就可以像调用函数一样直接使用，效率非常高。而如ls，cat这些外部命令却不是如此，当我们在命令行输入cat，当前的Shell会fork一个子进程，然后调用exec载入这个命令的可执行文件，比如bin&#x2F;cat，(<font color = orange>注意execve系统调用：它会把新程序加载到当前进程的内存空间内，当前的进程会被丢弃，它的堆、栈和所有的段数据都会被新进程相应的部分代替，然后会从新程序的初始化代码和 main 函数开始运行。同时，进程的 ID 将保持不变。</font>)因此效率上稍微低了点,最后shell用wait命令等待新进程结束</font></p>
<h3 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h3><p>shell脚本原理和shell命令相同，对于外部都是使用子进程执行。<br>这里突发奇想shell脚本能多线程吗？查了资料是可以的：</p>
<ul>
<li>使用&amp;后台运行<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line"></span><br><span class="line">all_num=10</span><br><span class="line"></span><br><span class="line">a=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> `<span class="built_in">seq</span> 1 <span class="variable">$&#123;all_num&#125;</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">sleep</span> 1</span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$&#123;num&#125;</span></span><br><span class="line">&#125; &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">b=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;startTime:\t<span class="variable">$a</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;endTime:\t<span class="variable">$b</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>控制同步：</p>
<ul>
<li>使用&amp;后台运行，使用wait同步<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line"></span><br><span class="line">all_num=10</span><br><span class="line"></span><br><span class="line">a=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> `<span class="built_in">seq</span> 1 <span class="variable">$&#123;all_num&#125;</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">sleep</span> 1</span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$&#123;num&#125;</span></span><br><span class="line">&#125; &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line"></span><br><span class="line">b=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;startTime:\t<span class="variable">$a</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;endTime:\t<span class="variable">$b</span>&quot;</span></span><br></pre></td></tr></table></figure>
控制并发数：</li>
<li>使用xargs -P</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line"></span><br><span class="line">all_num=10</span><br><span class="line">thread_num=5</span><br><span class="line"></span><br><span class="line">a=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="built_in">seq</span> 1 <span class="variable">$&#123;all_num&#125;</span> | xargs -n 1 -I &#123;&#125; -P <span class="variable">$&#123;thread_num&#125;</span> sh -c <span class="string">&quot;sleep 1;echo &#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">b=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;startTime:\t<span class="variable">$a</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;endTime:\t<span class="variable">$b</span>&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用GNU parallel</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line"></span><br><span class="line">all_num=10</span><br><span class="line">thread_num=6</span><br><span class="line"></span><br><span class="line">a=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parallel -j 5 <span class="string">&quot;sleep 1;echo &#123;&#125;&quot;</span> ::: `<span class="built_in">seq</span> 1 10`</span><br><span class="line"></span><br><span class="line">b=$(<span class="built_in">date</span> +%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;startTime:\t<span class="variable">$a</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;endTime:\t<span class="variable">$b</span>&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：内存管理大总结-ptmalloc/tcmalloc/jemalloc</title>
    <url>/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="ptmalloc"><a href="#ptmalloc" class="headerlink" title="ptmalloc"></a>ptmalloc</h3><p>GNU Libc 的内存分配器(allocator)—ptmalloc，起源于Doug Lea的malloc。由Wolfram Gloger改进得到可以支持多线程。</p>
<p>在Doug Lea实现的内存分配器中只有一个主分配区（main arena），每次分配内存都必须对主分配区加锁，分配完成后释放锁，在SMP多线程环境下，对主分配区的锁的争用很激烈，严重影响了malloc的分配效率。ptmalloc增加了动态分配区（dynamic arena），主分配区与动态分配区用环形链表进行管理。每一个分配区利用互斥锁（mutex）使线程对于该分配区的访问互斥。每个进程只有一个主分配区，但可能存在多个动态分配区，ptmalloc根据系统对分配区的争用情况动态增加动态分配区的数量，分配区的数量一旦增加，就不会再减少了。主分配区在二进制启动时调用sbrk从heap区域分配内存，Heap是由用户内存块组成的连续的内存域。而动态分配区每次使用mmap()向操作系统“批发”HEAP_MAX_SIZE大小的虚拟内存，如果内存耗尽，则会申请新的内存链到动态分配区heap data的“strcut malloc_state”。如果用户请求的大小超过HEAP_MAX_SIZE，动态分配区则会直接调用mmap()分配内存，并且当free的时候调用munmap()，该类型的内存块不会链接到任何heap data。用户向请求分配内存时，内存分配器将缓存的内存切割成小块“零售”出去。从用户空间分配内存，减少系统调用，是提高内存分配速度的好方法，毕竟前者要高效的多。</p>
<p>系统向看ptmalloc内存管理<br>在「glibc malloc」中主要有 3 种数据结构：</p>
<ul>
<li><p>malloc_state(Arena header)：一个 thread arena 可以维护多个堆，这些堆共享同一个arena header。Arena header 描述的信息包括：bins、top chunk、last remainder chunk 等；</p>
</li>
<li><p>heap_info(Heap Header)：每个堆都有自己的堆 Header（注：也即头部元数据）。当这个堆的空间耗尽时，新的堆（而非连续内存区域）就会被 mmap 当前堆的 aerna 里；</p>
</li>
<li><p>malloc_chunk(Chunk header)：根据用户请求，每个堆被分为若干 chunk。每个 chunk 都有自己的 chunk header。内存管理使用malloc_chunk，把heap当作link list从一个内存块游走到下一个块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">	<span class="type">mutex_t</span> mutex;</span><br><span class="line">	<span class="type">int</span> flags;</span><br><span class="line">	mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">	<span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">	mchunkptr top;</span><br><span class="line">	<span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">	mchunkptr last_remainder;</span><br><span class="line">	<span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">	mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="comment">/* Memory allocated from the system in this arena. */</span></span><br><span class="line">	INTERNAL_SIZE_T system_mem;</span><br><span class="line">	INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> &#123;</span></span><br><span class="line">	mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">	<span class="type">size_t</span> size; <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">	<span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">	PROT_READ|PROT_WRITE. */</span></span><br><span class="line">	<span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">	that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">	MALLOC_ALIGNMENT. */</span></span><br><span class="line">	<span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">	INTERNAL_SIZE_T prev_size; <span class="comment">/* Size of previous chunk (if free). */</span></span><br><span class="line">	INTERNAL_SIZE_T size; <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">	<span class="comment">/* Only used for large blocks: pointer to next larger size. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/memsum-1.png"></p>
</li>
<li><p>线程中内存管理<br>对于空闲的chunk，ptmalloc采用分箱式内存管理方式，每一个内存分配区中维护着[bins]的列表数据结构，用于保存free chunks。根据空闲chunk的大小和处于的状态将其放在四个不同的bin中，这四个空闲chunk的容器包括fast bins，unsorted bin， small bins和large bins。</p>
</li>
</ul>
<ol>
<li>Fast bins 可以看着是small bins的一小部分cache，主要是用于提高小内存的分配效率，虽然这可能会加剧内存碎片化，但也大大加速了内存释放的速度！</li>
<li>Unsorted bin 可以重新使用最近 free 掉的 chunk，从而消除了寻找合适 bin 的时间开销，进而加速了内存分配及释放的效率。</li>
<li>Small bins 相邻的 free chunk 将被合并，这减缓了内存碎片化，但是减慢了 free 的速度；</li>
<li>Large bin 中所有 chunk 大小不一定相同，各 chunk 大小递减保存。最大的 chunk 保存顶端，而最小的 chunk 保存在尾端；查找较慢，且释放时两个相邻的空闲 chunk 会被合并。</li>
</ol>
<p>一个 arena 中最顶部的 chunk 被称为「top chunk」。它不属于任何 bin 。当所有 bin 中都没有合适空闲内存时，就会使用 top chunk 来响应用户请求。当 top chunk 的大小比用户请求的大小小的时候，top chunk 就通过 sbrk（main arena）或 mmap（ thread arena）系统调用扩容。</p>
<p>「last remainder chunk」即最后一次 small request 中因分割而得到的剩余部分，它有利于改进引用局部性，也即后续对 small chunk 的 malloc 请求可能最终被分配得彼此靠近。当用户请求 small chunk 而无法从 small bin 和 unsorted bin 得到服务时，分配器就会通过扫描 binmaps 找到最小非空 bin。正如前文所提及的，如果这样的 bin 找到了，其中最合适的 chunk 就会分割为两部分：返回给用户的 User chunk 、添加到 unsorted bin 中的 Remainder chunk。这一 Remainder chunk 就将成为 last remainder chunk。当用户的后续请求 small chunk，并且 last remainder chunk 是 unsorted bin 中唯一的 chunk，该 last remainder chunk 就将分割成两部分：返回给用户的 User chunk、添加到 unsorted bin 中的 Remainder chunk（也是 last remainder chunk）。因此后续的请求的 chunk 最终将被分配得彼此靠近。</p>
<p><font color=orange>存在的问题：  </p>
<ul>
<li>如果后分配的内存先释放，无法及时归还系统。因为 ptmalloc 收缩内存是从 top chunk 开始,如果与 top chunk 相邻的 chunk 不能释放, top chunk 以下的 chunk 都无法释放。</li>
<li>内存不能在线程间移动，多线程使用内存不均衡将导致内存浪费</li>
<li>每个chunk至少8字节的开销很大</li>
<li>不定期分配长生命周期的内存容易造成内存碎片，不利于回收。</li>
<li>加锁耗时，无论当前分区有无耗时，在内存分配和释放时，会首先加锁。</font></li>
</ul>
<h3 id="tcmalloc"><a href="#tcmalloc" class="headerlink" title="tcmalloc"></a>tcmalloc</h3><p>tcmalloc是Google开发的内存分配器，在Golang、Chrome中都有使用该分配器进行内存分配。有效的优化了ptmalloc中存在的问题。当然为此也付出了一些代价，按下不表，先看tcmalloc的具体实现。</p>
<p>系统向看tcmalloc内存管理<br>tcmalloc把8kb的连续内存称为一个页(Page)，可以用下面两个常量来描述：<br>const size_t kPageShift &#x3D; 13;<br>const size_t kPageSize &#x3D; 1 &lt;&lt; kPageShift;<br>对于一个指针p，p&gt;&gt;kPageShift即是p的页地址。同样的对于一个页地址x，管理的实际内存区间是[x &lt;&lt;kPageShift, (x+1)&lt;&lt;kPageShift)。一个或多个连续的页组成一个Span.对于一个Span，管理的实际内存区间是[start&lt;&lt;kPageShift, (start+length)&lt;&lt;kPageShift)。tcmalloc中所有页级别的操作，都是对Span的操作。PageHeap是一个全局的用来管理Span的类。PageHeap把小于的空闲Span保存在双向循环链表上，而大的span则保存在SET中。保证了所有的内存的申请速度，减少了内存查找。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Information kept for a span (a contiguous run of pages).</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Span</span> &#123;</span></span><br><span class="line">  PageID        start;          <span class="comment">// Starting page number</span></span><br><span class="line">  Length        length;         <span class="comment">// Number of pages in span</span></span><br><span class="line">  Span*         next;           <span class="comment">// Used when in link list</span></span><br><span class="line">  Span*         prev;           <span class="comment">// Used when in link list</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>* objects;              <span class="comment">// Linked list of free objects</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Span may contain iterator pointing back at SpanSet entry of</span></span><br><span class="line">    <span class="comment">// this span into set of large spans. It is used to quickly delete</span></span><br><span class="line">    <span class="comment">// spans from those sets. span_iter_space is space for such</span></span><br><span class="line">    <span class="comment">// iterator which lifetime is controlled explicitly.</span></span><br><span class="line">    <span class="type">char</span> span_iter_space[<span class="keyword">sizeof</span>(SpanSet::iterator)];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  refcount : <span class="number">16</span>;  <span class="comment">// Number of non-free objects</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  sizeclass : <span class="number">8</span>;  <span class="comment">// Size-class for small objects (or 0)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  location : <span class="number">2</span>;   <span class="comment">// Is the span on a freelist, and if so, which?</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  sample : <span class="number">1</span>;     <span class="comment">// Sampled object?</span></span><br><span class="line">  <span class="type">bool</span>          has_span_iter : <span class="number">1</span>; <span class="comment">// If span_iter_space has valid</span></span><br><span class="line">                                   <span class="comment">// iterator. Only for debug builds.</span></span><br><span class="line">  <span class="comment">// What freelist the span is on: IN_USE if on none, or normal or returned</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We segregate spans of a given size into two circular linked</span></span><br><span class="line"><span class="comment">// lists: one for normal spans, and one for spans whose memory</span></span><br><span class="line"><span class="comment">// has been returned to the system.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SpanList</span> &#123;</span></span><br><span class="line">Span        normal;</span><br><span class="line">Span        returned;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array mapping from span length to a doubly linked list of free spans</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> index &#x27;i&#x27; stores spans of length &#x27;i + 1&#x27;.</span></span><br><span class="line">SpanList free_[kMaxPages];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets of spans with length &gt; kMaxPages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Rather than using a linked list, we use sets here for efficient</span></span><br><span class="line"><span class="comment">// best-fit search.</span></span><br><span class="line">SpanSet large_normal_;</span><br><span class="line">SpanSet large_returned_;</span><br></pre></td></tr></table></figure>
<p><img src="/images/memsum-2.png"></p>
<p><font color=orange>优点：</p>
<ul>
<li>小内存可以在ThreadCache中不加锁分配(加锁的代价大约100ns)</li>
<li>大内存可以直接按照大小分配不需要再像ptmalloc一样进行查找(ptmalloc需要在large bins链表中查找空闲chunk)</li>
<li>大内存加锁使用更高效的自旋锁</li>
<li>减少了内存碎片</li>
</ul>
<p>缺点：<br>使用自旋锁虽然减少了加锁效率，但是如果使用大内存较多的情况下，内存在Central Cache或者Page Heap加锁分配。而tcmalloc对大小内存的分配过于保守，在一些内存需求较大的服务（如推荐系统），小内存上限过低，当请求量上来，锁冲突严重，CPU使用率将指数暴增。<br></font></p>
<h3 id="jemalloc"><a href="#jemalloc" class="headerlink" title="jemalloc"></a>jemalloc</h3><p>jemalloc是facebook推出的，目前在firefox、facebook服务器、android 5.0 等服务中大量使用。 jemalloc最大的优势还是其强大的多核&#x2F;多线程分配能力. 以现代计算机硬件架构来说, 最大的瓶颈已经不再是内存容量或cpu速度, 而是多核&#x2F;多线程下的lock contention(锁竞争). 因为无论CPU核心数量如何多, 通常情况下内存只有一份. 可以说, 如果内存足够大, CPU的核心数量越多, 程序线程数越多, jemalloc的分配速度越快。</p>
<p>对于一个多线程+多CPU核心的运行环境, 传统分配器中大量开销被浪费在lock contention和false sharing上, 随着线程数量和核心数量增多, 这种分配压力将越来越大.针对多线程, 一种解决方法是将一把global lock分散成很多与线程相关的lock. 而针对多核心, 则要尽量把不同线程下分配的内存隔离开, 避免不同线程使用同一个cache-line的情况.按照上面的思路, 一个较好的实现方式就是引入arena.将内存划分成若干数量的arenas, 线程最终会与某一个arena绑定.由于两个arena在地址空间上几乎不存在任何联系, 就可以在无锁的状态下完成分配. 同样由于空间不连续, 落到同一个cache-line中的几率也很小, 保证了各自独立。由于arena的数量有限, 因此不能保证所有线程都能独占arena, 分享同一个arena的所有线程, 由该arena内部的lock保持同步.</p>
<p>chunk是仅次于arena的次级内存结构，arena都有专属的chunks, 每个chunk的头部都记录了chunk的分配信息。chunk是具体进行内存分配的区域，目前的默认大小是4M。chunk以page（默认为4K)为单位进行管理，每个chunk的前几个page（默认是6个）用于存储chunk的元数据，后面跟着一个或多个page的runs。后面的runs可以是未分配区域， 多个小对象组合在一起组成run, 其元数据放在run的头部。 大对象构成的run, 其元数据放在chunk的头部。在使用某一个chunk的时候，会把它分割成很多个run，并记录到bin中。不同size的class对应着不同的bin，在bin里，都会有一个红黑树来维护空闲的run，并且在run里，使用了bitmap来记录了分配状态。此外，每个arena里面维护一组按地址排列的可获得的run的红黑树。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_s</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 当前arena管理的dirty chunks */</span></span><br><span class="line">    <span class="type">arena_chunk_tree_t</span>  chunks_dirty;</span><br><span class="line">    <span class="comment">/* arena缓存的最近释放的chunk, 每个arena一个spare chunk */</span></span><br><span class="line">    <span class="type">arena_chunk_t</span>       *spare;</span><br><span class="line">    <span class="comment">/* 当前arena中正在使用的page数. */</span></span><br><span class="line">    <span class="type">size_t</span>          nactive;</span><br><span class="line">    <span class="comment">/*当前arana中未使用的dirty page数*/</span></span><br><span class="line">    <span class="type">size_t</span>          ndirty;</span><br><span class="line">    <span class="comment">/* 需要清理的page的大概数目 */</span></span><br><span class="line">    <span class="type">size_t</span>          npurgatory;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 当前arena可获得的runs构成的红黑树， */</span></span><br><span class="line">    <span class="comment">/* 红黑树按大小/地址顺序进行排列。 分配run时采用first-best-fit策略*/</span></span><br><span class="line">    <span class="type">arena_avail_tree_t</span>  runs_avail;</span><br><span class="line">    <span class="comment">/* bins储存不同大小size的内存区域 */</span></span><br><span class="line">    <span class="type">arena_bin_t</span>     bins[NBINS];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Arena chunk header. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_chunk_s</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 管理当前chunk的Arena */</span></span><br><span class="line">    <span class="type">arena_t</span>         *arena;</span><br><span class="line">    <span class="comment">/* 链接到所属arena的dirty chunks树的节点*/</span></span><br><span class="line">    rb_node(<span class="type">arena_chunk_t</span>)  dirty_link;</span><br><span class="line">    <span class="comment">/* 脏页数 */</span></span><br><span class="line">    <span class="type">size_t</span>          ndirty;</span><br><span class="line">    <span class="comment">/* 空闲run数 Number of available runs. */</span></span><br><span class="line">    <span class="type">size_t</span>          nruns_avail;</span><br><span class="line">    <span class="comment">/* 相邻的run数，清理的时候可以合并的run */</span></span><br><span class="line">    <span class="type">size_t</span>          nruns_adjac;</span><br><span class="line">    <span class="comment">/* 用来跟踪chunk使用状况的关于page的map, 它的下标对应于run在chunk中的位置，通过加map_bias不跟踪chunk 头部的信息</span></span><br><span class="line"><span class="comment">     * 通过加map_bias不跟踪chunk 头部的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">arena_chunk_map_t</span>   <span class="built_in">map</span>[<span class="number">1</span>]; <span class="comment">/* Dynamically sized. */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_run_s</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 所属的bin */</span></span><br><span class="line">    <span class="type">arena_bin_t</span> *bin;</span><br><span class="line">    <span class="comment">/*下一块可分配区域的索引 */</span></span><br><span class="line">    <span class="type">uint32_t</span>    nextind;</span><br><span class="line">    <span class="comment">/* 当前run中空闲块数目. */</span></span><br><span class="line">    <span class="type">unsigned</span>    nfree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/memsum-3.png"></p>
<p>jemalloc 按照内存分配请求的尺寸，分了 small object (例如 1 – 57344B)、 large object (例如 57345 – 4MB )、 huge object (例如 4MB以上)。jemalloc同样有一层线程缓存的内存名字叫tcache，当分配的内存大小小于tcache_maxclass时，jemalloc会首先在tcache的small object以及large object中查找分配，tcache不中则从arena中申请run，并将剩余的区域缓存到tcache。若arena找不到合适大小的内存块， 则向系统申请内存。当申请大小大于tcache_maxclass且大小小于huge大小的内存块时，则直接从arena开始分配。而huge object的内存不归arena管理， 直接采用mmap从system memory中申请，并由一棵与arena独立的红黑树进行管理。</p>
<p><font color=orange>优点：</p>
<ul>
<li>采用多个 arena 来避免线程同步</li>
<li>细粒度的锁，比如每一个 bin 以及每一个 extents 都有自己的锁</li>
<li>Memory Order 的使用，比如 rtree 的读写访问有不同的原子语义（relaxed, acquire, release）</li>
<li>结构体以及内存分配时保证对齐，以获得更好的 cache locality</li>
<li>cache_bin 分配内存时会通过栈变量来判断是否成功以避免 cache miss</li>
<li>dirty extent 的 delay coalesce 来获得更好的 cache locality；extent 的 lazy purge 来保证更平滑的 gc 机制</li>
<li>紧凑的结构体内存布局来减少占用空间，比如 extent.e_bits</li>
<li>rtree 引入 rtree_ctx 的两级 cache 机制，提升 extent 信息获取速度的同时减少 cache miss</li>
<li>tcache gc 时对缓存容量的动态调整</li>
</ul>
<p>缺点：</p>
<ul>
<li>某个线程在这个 arena 使用了很多内存，之后这个 arena 并没有其他线程使用，导致这个 arena 的内存无法被 gc，占用过多</li>
<li>两个位于不同 arena 的线程频繁进行内存申请，导致两个 arena 的内存出现大量交叉，但是连续的内存由于在不同 arena 而无法进行合并.</li>
</ul>
</font>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：分段分页</title>
    <url>/2021/08/12/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E5%88%86%E6%AE%B5%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="内存不够怎么办"><a href="#内存不够怎么办" class="headerlink" title="内存不够怎么办"></a>内存不够怎么办</h3><p>在早起的计算机上，程序是运行在物理内存上的，也就是说，程序在运行时所访问的地址都是物理地址，那么在多个进城同时运行的过程中，如何将计算机上有限的物理内存分配给多个程序使用是一个值得思考的问题。<br>一个比较直接的做法是在物理内存上直接进行分配，例如我们计算机有128M的内存，程序A运行需要10M，程序B需要100M，程序C需要20M，如果我们同时运行A和B，就将内存前10M给A，10~110M给B，但是这种方法存在的隐患却是很大的：  </p>
<ol>
<li>地址空间不隔离：任何程序都可以直接访问物理地址，那么恶意的程序很容易修改其他程序的内存数据。</li>
<li>内存使用率低：没有有效的内存管理机制，需要一个程序执行时，监控程序就将整个程序装入内存中然后开始执行。如果我们忽然需要运行一个程序C，这时候内存空间不够了，我们只释放A的内存空间是不够的，因此需要将B移到磁盘，这中间有大量的数据换入患处，导致效率十分低下。</li>
<li>程序运行的地址不确定：程序每次需要装入运行时，我们都需要给它在内存中分配一块足够大的空闲区域，每个空闲区域的位置是不确定的，给程序的编写造成了一定的麻烦。因为程序在编写时，访问数据和指令跳转的目标地址都是固定的，这设计到了程序的重定位问题。</li>
</ol>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>最开始解决上面这个问题使用的是分段的方法，基本思路是把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间。如A需要10M，那我们就假设有个地址从0x00000000到0x00A00000大小的假想的空间。然后从实际的物理内存中分配一个相同大小的空间例如0x00100000到0x00B00000.然后把两个空间做一一映射。这个映射过程由软件来设置，比如操作系统来设置，实际的地址转换由硬件来完成。<br><img src="/images/seg-1.png"></p>
<p>分段解决了前面提到的问题中的1~3，首先做到了地址隔离，如果A访问B的地址，软件会检测访问越界。并且由于虚拟地址，程序不需要关心物理地址的变化，因此程序也不需要重定位。不过这种方法对内存的使用效率依然很低，因为每次内存的换入换出依然是这个程序。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>分页的基本思想是将地址空间划为固定大小的页。每一页的大小由硬件支持。<br>现在我们进程的虚拟空间按页分割，常用的数据和代码页装载到内存，不常用的代码和数据保存在磁盘里。在这里，我们把虚拟空间的页叫做虚拟页，物理内存中的页叫做物理页，把磁盘中的页叫做磁盘页。从下图可以看到映射关系，我们可以发现，虚拟空间的有些页被映射到同一个物理页，这样就可以实现内存共享。<br><img src="/images/seg-2.png"></p>
<p>当进程需要两个页时，硬件会捕获这个消息，也就是产生缺页中断，操作系统会接管进程，将缺页从磁盘中读出来并且装入内存中。虚拟存储实现需要依靠硬件的支持，如下图所示，一般使用MMU单元进行页映射。<br><img src="/images/seg-3.png"></p>
<p>同时保护也是页映射的目的之一，简单来说就是每个页可以设置权限属性，谁可以修改，谁可以访问等等，只有操作系统有权限修改这些属性。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：各种锁大总结</title>
    <url>/2021/08/12/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E5%90%84%E7%A7%8D%E9%94%81%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ol>
<li><p>定义</p>
<ul>
<li>乐观锁：每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。</li>
<li>悲观锁：每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。</li>
</ul>
</li>
<li><p>使用场景：</p>
<ul>
<li>乐观锁：比较适合<font color = red>读取</font>操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。<font color = orange> 例如版本号控制，时间戳控制。</font></li>
<li>悲观锁：比较适合<font color = red>写入</font>操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。<font color = orange>例如数据库的行锁。</font></li>
</ul>
</li>
</ol>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><ol>
<li>定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为自旋锁。</li>
<li>优点：<ul>
<li>非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</li>
</ul>
</li>
<li>应用场景：<br> 在线程持有锁时间较短的情况下可以使用自旋锁节省上下文切换开销，但是对于长时间持有的锁不适宜设计为自旋，因为自选时CPU忙等，耗费大量算力。</li>
<li>变种：自适应自旋锁，可以根据上一次线程持有锁的时间来确定自旋一段时间或者直接阻塞。</li>
</ol>
<h3 id="互斥锁和条件锁（条件变量）"><a href="#互斥锁和条件锁（条件变量）" class="headerlink" title="互斥锁和条件锁（条件变量）"></a>互斥锁和条件锁（条件变量）</h3><p>可以参考<a href="https://haoqinx.github.io/2021/09/02/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/">线程同步</a>。</p>
<h3 id="其他锁"><a href="#其他锁" class="headerlink" title="其他锁"></a>其他锁</h3><ul>
<li>可重入锁和不可冲入锁：一个线程中多个流程能不能获取同一把锁，或者在递归情况下能不能避免死锁。</li>
<li>多个线程竞争时要不要排队？排队称为公平锁，先尝试插队，若失败再排队称为非公平锁。</li>
<li>轻量级锁和重量级锁（待研究）</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：到底什么是进程，线程</title>
    <url>/2021/09/02/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="一个普遍的定义"><a href="#一个普遍的定义" class="headerlink" title="一个普遍的定义"></a>一个普遍的定义</h4><ul>
<li>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。<br>上面的定义应该是比较广泛的一种定义，但是定义地非常模糊，也不好理解究竟在操作系统中进程是什么。下面以Linux操作系统为例，说明究竟在操作系统中进程以什么方式存在。</li>
</ul>
<h4 id="进程资源集合"><a href="#进程资源集合" class="headerlink" title="进程资源集合"></a>进程资源集合</h4><p>进程由什么资源组成？在Linux下大概有下面这些：</p>
<ul>
<li>可执行程序代码</li>
<li>打开的文件</li>
<li>挂起的信号</li>
<li>内核内部数据</li>
<li>处理器状态</li>
<li>一个或者多个具有内存映射的内存地址空间</li>
<li>一个或多个执行线程</li>
<li>存放全局变量的数据段</li>
</ul>
<h4 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h4><p>在Linux系统中内核把进程的列表存放在叫做任务队列（个人理解就是一个不同优先级的双向循环链表）的结构中，每一项类型为task_struct，称为进程描述符。进程描述符通过slab分配器分配。  </p>
<p>Q:什么是slab？<br>A：  </p>
<ol>
<li>使用传统分配的缺点：传统的内存分配算法通过伙伴系统分配，伙伴系统使用的是多级链表来实现，分配策略就是从小到大找最适合的链表，这种分配很容易造成内部碎片，特别是task_struct这种小对象。</li>
<li>分配流程：当用户进程或者系统进程向SLAB申请了专门存放某一类对象的内存空间，但此时SLAB中没有足够的空间来专门存放此类对象，于是SLAB就像伙伴系统申请2的幂次方个连续的物理页框，SLAB的申请得到伙伴系统满足之后，SLAB就对这一块内存进行管理，用以存放多个上文中提到的某一类对象。对象实际上指的是某一种数据类型。一个SLAB只针对一种数据类型（对象）。为了提升对对象的访问效率，SLAB可能会对对象进行对齐。为了提升效率，SLAB分配器为每一个CPU都提供了每CPU数据结构struct array_cache，该结构指向被释放的对象。当CPU需要使用申请某一个对象的内存空间时，会先检查array_cache中是否有空闲的对象，如果有的话就直接使用。如果没有空闲对象，就像SLAB分配器进行申请。  </li>
<li>说明：上面说明的缓存指的并不是真正的缓存，真正的缓存指的是硬件缓存，也就是我们通常所说的L1 cache、L2 cache、L3 cache，硬件缓存是为了解决快速的CPU和速度较慢的内存之间速度不匹配的问题，CPU访问cache的速度要快于内存，如果将常用的数据放到硬件缓存中，使用时CPU直接访问cache而不用再访问内存，从而提升系统速度。下文中的缓存实际上是用软件在内存中预先开辟一块空间，使用时直接从这一块空间中去取，是SLAB分配器为了便于对小块内存的管理而建立的。</li>
</ol>
<p>分配的进程结构体如下图所示：<br><img src="/images/pt-1.png"><br>每个任务的thread_info结构在内核栈的尾端分配，结构中task域存放的是指向任务的实际的task_struct指针。</p>
<p>内核通过进程描述符pid在标识进程，最大默认32768（为了兼容旧版本），在X86系统中通过栈指针屏蔽来计算thread_info偏移，汇编如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl $-8192, %eax</span><br><span class="line">andl %esp, %eax</span><br></pre></td></tr></table></figure>
<p>附X86常用寄存器表。<br><img src="/images/x86-1.png"></p>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>一图胜千言：<br><img src="/images/pt-2.png"></p>
<h4 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h4><p>进程上下文是进程执行活动全过程的静态描述。我们把已执行过的进程指令和数据在相关寄存器与堆栈中的内容称为进程上文，把正在执行的指令和数据在寄存器与堆栈中的内容称为进程正文，把待执行的指令和数据在寄存器与堆栈中的内容称为进程下文。</p>
<p>实际上linux内核中，进程上下文包括进程的虚拟地址空间和硬件上下文。</p>
<ol>
<li>虚拟地址上下文切换<br>在进程描述符中有mm_struct结构体来描述进程地址空间，这个结构体中有一个成员pgd，保存的是进程的页的全局目录的虚拟地址，是在fork()的时候（此处应该是写时复制是赋值的，直接fork会共用父进程的地址）设置的。<br>代码trace如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">context_switch  <span class="comment">// kernel/sched/core.c</span></span><br><span class="line">-&gt;switch_mm_irqs_off</span><br><span class="line">  -&gt;switch_mm</span><br><span class="line">  -&gt;__switch_mm</span><br><span class="line">    -&gt;check_and_switch_context</span><br><span class="line">    -&gt;cpu_switch_mm</span><br><span class="line">      -&gt;cpu_do_switch_mm(virt_to_phys(pgd),mm) <span class="comment">//arch/arm64/include/asm/mmu_context.h</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arch/arm64/mm/proc.S</span><br><span class="line"><span class="number">158</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">159  *      cpu_do_switch_mm(pgd_phys, tsk)</span></span><br><span class="line"><span class="comment">160  *</span></span><br><span class="line"><span class="comment">161  *      Set the translation table base pointer to be pgd_phys.</span></span><br><span class="line"><span class="comment">162  *</span></span><br><span class="line"><span class="comment">163  *      - pgd_phys - physical address of new TTB</span></span><br><span class="line"><span class="comment">164  */</span></span><br><span class="line"><span class="number">165</span> ENTRY(cpu_do_switch_mm)</span><br><span class="line"><span class="number">166</span>         mrs     x2, ttbr1_el1</span><br><span class="line"><span class="number">167</span>         mmid    x1, x1                          <span class="comment">// get mm-&gt;context.id</span></span><br><span class="line"><span class="number">168</span>         phys_to_ttbr x3, x0</span><br><span class="line"><span class="number">169</span></span><br><span class="line"><span class="number">170</span> alternative_if ARM64_HAS_CNP</span><br><span class="line"><span class="number">171</span>         cbz     x1, <span class="number">1f</span>                          <span class="comment">// skip CNP for reserved ASID</span></span><br><span class="line"><span class="number">172</span>         orr     x3, x3, #TTBR_CNP_BIT</span><br><span class="line"><span class="number">173</span> <span class="number">1</span>:</span><br><span class="line"><span class="number">174</span> alternative_else_nop_endif</span><br><span class="line"><span class="number">175</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM64_SW_TTBR0_PAN</span></span><br><span class="line"><span class="number">176</span>         bfi     x3, x1, #<span class="number">48</span>, #<span class="number">16</span>                <span class="comment">// set the ASID field in TTBR0</span></span><br><span class="line"><span class="number">177</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">178</span>         bfi     x2, x1, #<span class="number">48</span>, #<span class="number">16</span>                <span class="comment">// set the ASID</span></span><br><span class="line"><span class="number">179</span>         msr     ttbr1_el1, x2                   <span class="comment">// in TTBR1 (since TCR.A1 is set)</span></span><br><span class="line"><span class="number">180</span>         isb</span><br><span class="line"><span class="number">181</span>         msr     ttbr0_el1, x3                   <span class="comment">// now update TTBR0</span></span><br><span class="line"><span class="number">182</span>         isb</span><br><span class="line"><span class="number">183</span>         b       post_ttbr_update_workaround     <span class="comment">// Back to C code...</span></span><br><span class="line"><span class="number">184</span> ENDPROC(cpu_do_switch_mm)</span><br></pre></td></tr></table></figure>
代码中最核心的为181行，最终将进程的pgd虚拟地址转化为物理地址存放在ttbr0_el1中，这是用户空间的页表基址寄存器，当访问用户空间地址的时候mmu会通过这个寄存器来做遍历页表获得物理地址（ttbr1_el1是内核空间的页表基址寄存器，访问内核空间地址时使用，所有进程共享，不需要切换）。完成了这一步，也就完成了进程的地址空间切换，确切的说是进程的虚拟地址空间切换。</li>
<li>硬件上下文切换<br>将结构中的cpu寄存器信息重新设置给当前cpu即可。<br><img src="/images/pt-3.png"></li>
</ol>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程拥有独立的程序计数器，进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。一个进程可以包含多个线程，最少有一个线程。</p>
<h4 id="为啥要线程"><a href="#为啥要线程" class="headerlink" title="为啥要线程"></a>为啥要线程</h4><p>一句话来说，就是避免进程间切换的上下文转换开销。进程上下文需要虚拟空间转换，硬件寄存器上下文转换，但是在同一个进程中的线程的资源基本上是共享的，切换的开销基本可以忽略不计，因此有更高的效率。</p>
<h4 id="Linux中的线程"><a href="#Linux中的线程" class="headerlink" title="Linux中的线程"></a>Linux中的线程</h4><p><font color = orange>在内核角度，没有线程这个概念，线程是由进程实现的。</font>线程仅仅是和其他进城共享某些资源的进程。</p>
<p>创建线程  </p>
<p>在Linux中创建线程和进程最终都是调用clone()系统调用，不过进程是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clone(SIGCHLD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>而线程需要共享地址空间，文件系统资源，文件描述符和信号处理程序。如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：多线程和线程同步</title>
    <url>/2021/09/02/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><ol>
<li>不同进程的线程之间通信，等同于进程间通信。</li>
<li>相同进程中不同线程之间通信，主要是线程同步，避免对临界区资源的破坏。</li>
</ol>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol>
<li>互斥锁</li>
</ol>
<p>互斥量是最简单的同步机制，即互斥锁。多个进程(线程)均可以访问到一个互斥量，通过对互斥量加锁，从而来保护一个临界区,防止其它进程(线程)同时进入临界区，保护临界资源互斥访问。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">pthread_mutex_t</span> m;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* args)</span></span>&#123;</span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">          <span class="built_in">pthread_mutex_lock</span>(&amp;m);</span><br><span class="line">          <span class="type">pthread_t</span> res = <span class="built_in">pthread_self</span>();</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;current thread : &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;resource: &quot;</span> &lt;&lt; resource &lt;&lt; endl;</span><br><span class="line">          ++ resource;</span><br><span class="line">          <span class="built_in">pthread_mutex_unlock</span>(&amp;m);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> handler(msg) \</span></span><br><span class="line"><span class="meta">          perror(msg);\</span></span><br><span class="line"><span class="meta">          exit(-1);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>  </span>&#123;  </span><br><span class="line">     <span class="type">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">pthread_mutex_init</span>(&amp;m, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;p1, <span class="literal">nullptr</span>, func, <span class="number">0</span>))&#123;</span><br><span class="line">          <span class="built_in">handler</span>(<span class="string">&quot;thread create error&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;p2, <span class="literal">nullptr</span>, func, <span class="number">0</span>))&#123;</span><br><span class="line">          <span class="built_in">handler</span>(<span class="string">&quot;thread create error&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">pthread_join</span>(p1, <span class="literal">nullptr</span>))&#123;</span><br><span class="line">          <span class="built_in">handler</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">pthread_join</span>(p2, <span class="literal">nullptr</span>))&#123;</span><br><span class="line">          <span class="built_in">handler</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ol start="2">
<li>条件变量</li>
</ol>
<p>条件变量是并发编程中的一种同步机制。条件变量使得线程能够阻塞到等待某个条件发生后，再继续执行</p>
<ul>
<li>条件变量的实现原理：<br>条件变量其实就是一种等待机制，每个条件变量对应一个等待原因和等待队列，通常有两种操作：wait和signal。<br>条件变量的伪代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Condition</span>&#123;</span><br><span class="line">    <span class="type">int</span> waitNum = <span class="number">0</span>;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
wait操作分为两步，首先对waitNum + 1,然后将当前进程加入等待队列中。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Condition::<span class="built_in">Wait</span>(lock)</span><br><span class="line">&#123;</span><br><span class="line">	++numWaiting;</span><br><span class="line">	Add current thread to WaitQueue q;</span><br><span class="line">	<span class="built_in">release</span>(lock);</span><br><span class="line">	<span class="built_in">schedule</span>(); <span class="comment">//调度机制，让出CPU</span></span><br><span class="line">	<span class="built_in">acquire</span>(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于singal操作来说，则如果等待队列中有线程的话，将它取出唤醒，waitNum减一即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Condition::<span class="built_in">Singal</span>()&#123;</span><br><span class="line">	<span class="keyword">if</span>(waitNum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		remove t from q;</span><br><span class="line">		<span class="built_in">wakeup</span>(q);</span><br><span class="line">		--waitNum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
条件变量的原理虽然很简单，但是使用起来却是比较费脑，还是参考<a href="https://www.cnblogs.com/Solstice/p/3309089.html">陈硕大佬这篇文章</a>正确使用，下面是一个<font color=orange>保证不会出错的使用方法。</font>经典例子见<a href="https://github.com/chenshuo/recipes/blob/master/thread/test/Waiter_test.cc">github</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Waiter7</span> : <span class="keyword">public</span> Waiter</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">while</span> (!signaled_)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">pthread_cond_wait</span>(&amp;cond_, &amp;mutex_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">()</span> <span class="keyword">override</span> <span class="comment">// Sorry, bad name in base class, poor OOP</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">broadcast</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">broadcast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">    <span class="built_in">pthread_cond_broadcast</span>(&amp;cond_);</span><br><span class="line">    signaled_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">bool</span> signaled_ = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>条件变量里面有个经典的假唤醒问题，特别是在广播的时候，一个条件满足了，但是当被唤醒线程拿到资源的时候其实已经被其他线程先行一步消耗了，因此需要在等待时使用while循环判断和等待。<br>这个其实和网络编程里面的惊群现象比较相似。</p>
<ol start="3">
<li>读写锁</li>
</ol>
<p>读写锁的核心思想是：将线程访问共享数据时发出的请求分为两种，分别是：</p>
<ul>
<li>读请求：只读取共享数据，不做任何修改；</li>
<li>写请求：存在修改共享数据的行为。</li>
</ul>
<p>当有多个线程发出读请求时，这些线程可以同时执行，也就是说，共享数据的值可以同时被多个发出读请求的线程获取；当有多个线程发出写请求时，这些线程只能一个一个地执行（同步执行）。此外，当发出读请求的线程正在执行时，发出写请求的线程必须等待前者执行完后才能开始执行；当发出写请求的线程正在执行时，发出读请求的线程也必须等待前者执行完后才能开始执行。</p>
<p>本质上，读写锁就是一个全局变量，发出读请求和写请求的线程都可以访问它。为了区别线程发出的请求类别，当读写锁被发出读请求的线程占用时，我们称它为“读锁”；当读写锁被发出写请求的线程占用时，称它为“写锁”。  </p>
<table>
<thead>
<tr>
<th>当前读写锁模式</th>
<th>读请求</th>
<th>写请求</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td>允许占用</td>
<td>允许占用</td>
</tr>
<tr>
<td>读锁</td>
<td>允许占用</td>
<td>阻塞线程执行</td>
</tr>
<tr>
<td>写锁</td>
<td>阻塞线程执行</td>
<td>阻塞线程执行</td>
</tr>
</tbody></table>
<ul>
<li><p>当读写锁未被任何线程占用时，发出读请求和写请求的线程都可以占用它。注意，由于读请求和写请求的线程不能同时执行，读写锁默认会优先分配给发出读请求的线程。</p>
</li>
<li><p>当读写锁的状态为“读锁”时，表明当前执行的是发出读请求的线程（可能有多个）。此时如果又有线程发出读请求，该线程不会被阻塞，但如果有线程发出写请求，它就会被阻塞，直到读写锁状态改为“无锁”。</p>
</li>
<li><p>当读写锁状态为“写锁”时，表明当前执行的是发出写请求的线程（只能有 1 个）。此时无论其它线程发出的是读请求还是写请求，都必须等待读写锁状态改为“无锁”后才能执行。</p>
</li>
</ul>
<p>总的来说，对于进程空间中的共享资源，读写锁允许发出“读”请求的线程共享资源，发出“写”请求的线程必须独占资源，进而实现线程同步。</p>
<ol start="4">
<li>信号量</li>
</ol>
<p>在linux中进程和线程相似，参考前面的<a href="https://haoqinx.github.io/2021/09/14/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">进程间通信</a>。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：孤儿进程和僵尸进程</title>
    <url>/2021/09/14/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><ul>
<li>基本概念：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li>
</ul>
<p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait &#x2F; waitpid来取时才释放。 但这样就导致了问题，<font color = "orange">如果进程不调用wait &#x2F; waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</font>  </p>
<ul>
<li>形成原因：<br>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</li>
<li>举例说明  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">//创建一个进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">//创建失败</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork error:&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the child process.\n&quot;</span>);</span><br><span class="line">        <span class="comment">//输出进程ID和父进程ID</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid: %d\tppid:%d\n&quot;</span>,<span class="built_in">getpid</span>(),<span class="built_in">getppid</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I will sleep five seconds.\n&quot;</span>);</span><br><span class="line">        <span class="comment">//睡眠30s，保证父进程先退出</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">30</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid: %d\tppid:%d\n&quot;</span>,<span class="built_in">getpid</span>(),<span class="built_in">getppid</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process is exited.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am father process.\n&quot;</span>);</span><br><span class="line">        <span class="comment">//父进程睡眠1s，保证子进程输出进程id</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;father process is  exited.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行结果如下所示：<br><img src="/images/guer-1.png"><br>从图中可以看出，父进程退出之后，有init进程收留孤儿进程。</li>
</ul>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ul>
<li>基本概念：<br>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。  </li>
<li>形成原因：<br>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</li>
<li>例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 </li>
<li>解决方法：<br>严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程就能瞑目而去了。<br>测试代码如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork error:&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child process.I am exiting.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am father process.I will sleep two seconds\n&quot;</span>);</span><br><span class="line">    <span class="comment">//等待子进程先退出</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father process is exiting.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行结果如下所示<br><img src="/images/jiangshi-1.png"><br>从图中可以看出，子进程变成了僵尸进程。<br>同理，如果父进程循环创建子进程，而子进程在父进程之前退出，那么就会有相当多数量的僵尸进程。</li>
<li>解决方法：</li>
</ul>
<ol>
<li><p>通过信号机制：子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。测试程序如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_child</span><span class="params">(<span class="type">int</span> signo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">//创建捕捉子进程退出信号</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGCHLD,sig_child);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork error:&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child process,pid id %d.I am exiting.\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am father process.I will sleep two seconds\n&quot;</span>);</span><br><span class="line">    <span class="comment">//等待子进程先退出</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//输出进程信息</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;ps -o pid,ppid,state,tty,command&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father process is exiting.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_child</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">pid_t</span>        pid;</span><br><span class="line">     <span class="type">int</span>        stat;</span><br><span class="line">     <span class="comment">//处理僵尸进程</span></span><br><span class="line">     <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated.\n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果如下：<br><img src="/images/jiangshi-2.png"><br>从图中可以看出，父进程捕捉到子进程结束的信号。</p>
</li>
<li><p>fork两次<br>《Unix 环境高级编程》8.6节说的非常详细。原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。测试程序如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span>  pid;</span><br><span class="line">    <span class="comment">//创建第一个子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork error:&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一个子进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程再创建子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the first child process.pid:%d\tppid:%d\n&quot;</span>,<span class="built_in">getpid</span>(),<span class="built_in">getppid</span>());</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;fork error:&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个子进程退出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;first procee is exited.\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二个子进程</span></span><br><span class="line">        <span class="comment">//睡眠3s保证第一个子进程退出，这样第二个子进程的父亲就是init进程里</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the second child process.pid: %d\tppid:%d\n&quot;</span>,<span class="built_in">getpid</span>(),<span class="built_in">getppid</span>());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程处理第一个子进程退出</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitpid</span>(pid, <span class="literal">NULL</span>, <span class="number">0</span>) != pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;waitepid error:&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的运行结果为：<br><img src="/images/jiangshi-2.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：从按下开机到进入系统，到底经历了什么？</title>
    <url>/2021/09/02/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E7%94%B5%E6%BA%90%E9%94%AE%E5%88%B0%E5%90%AF%E5%8A%A8%E5%85%A8%E8%BF%87%E7%A8%8B%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="开机全程"><a href="#开机全程" class="headerlink" title="开机全程"></a>开机全程</h3><p><a href="https://www.ruanyifeng.com/blog/2013/02/booting.html">参考阮一峰大佬的博客1</a>,<a href="https://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html">博客2</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：编译链接</title>
    <url>/2021/09/02/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>第一步预编译的过程个相当于如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -E hello.c -o hello.i</span></span><br></pre></td></tr></table></figure>
<p>预编译主要处理源文件中以#开始的预编译命令</p>
<ul>
<li>将所有#define删除，并展开所有宏定义、</li>
<li>处理所有条件编译指令，如#if,#ifdef,#elif,#else,#endif</li>
<li>处理#include指令，将被包含的文件插入到该编译指令的位置。<font color=orange>注意这可能是个递归的过程，也就是被包含的文件可能还包含其他文件.</font></li>
<li>删除所有注释</li>
<li>添加行号和文件名标识，如#2”hello.c” 2,以便编译时编译器产生调试用的行号信息和产生编译错误或警告时的行号提示。</li>
<li>保留所有#pragma编译器指令，因为编译器必须使用他们。</li>
</ul>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>过程相当于</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -S hello.i -o hello.s</span></span><br></pre></td></tr></table></figure>
<ul>
<li>词法分析：有限状态机</li>
<li>语法分析：语法树</li>
<li>语义分析：静态语义、动态语义</li>
<li>中间代码生成：生成三地址码</li>
<li>目标代码生成：生成汇编代码</li>
<li>优化</li>
</ul>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>静态链接就是将几个输出目标文件合并成一个输出文件。</p>
<ol>
<li>最简单的就是按序叠加：<br><img src="/images/static-1.png"></li>
</ol>
<p>但是这种做法浪费空间并且有大量内存碎片。<br>2. 相似段合并：<br><img src="/images/static-2.png"></p>
<p>整个链接过程分两步：</p>
<ul>
<li>空间和地址分配：扫描所有输出目标文件，获得各个段的长度，属性和位置，将输入目标文件的符号表中所有符号定义和符号引用手机起来，统一放到一个全局符号表，连接器能够获得所有输入目标文件的的段长度，将它们合并。</li>
<li>符号解析和重定位：使用第一步的信息，读取输入文件中段的数据，重定位信息，进行符号解析和重定位。<font color=orange>核心是重定位过程。</font></li>
</ul>
<p>使用objdump查看链接前后地址的分配的情况：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000028  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  00000068  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000068  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .comment      00000036  0000000000000000  0000000000000000  00000068  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000009e  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .eh_frame     00000038  0000000000000000  0000000000000000  000000a0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000000  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .data         00000004  0000000000000000  0000000000000000  00000040  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000044  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .comment      00000036  0000000000000000  0000000000000000  00000044  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000007a  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ab:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000003a  00000000004000e8  00000000004000e8  000000e8  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .eh_frame     00000058  0000000000400128  0000000000400128  00000128  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .data         00000004  0000000000600180  0000000000600180  00000180  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  3 .comment      00000035  0000000000000000  0000000000000000  00000184  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>
<p><font color=orange>在链接之前，目标文件中所有的段的VMA都是0，因为虚拟空间还没有分配。在链接之后被分配了地址0x0000003a。</font></p>
<p>下一步就是符号地址的确定。<br>由于符号在段内的相对位置是固定的，因此函数名和变量的地址也就确定了，这时候我们需要给每个符号加上一个偏移量，使他们能够调整到正确的虚拟地址上。<br>完成上述空间和地址的分配步骤之后，就进行符号解析和重定位。<br>那么链接器需要知道哪些指令需要被调整。<br>事实上在ELF文件中有一个<font color = orange>重定位表</font>来专门保存。<br>使用objdump -r a.o来查看。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000000023 R_X86_64_32       shared</span><br><span class="line">0000000000000030 R_X86_64_PC32     swap-0x0000000000000004</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure>

<p>OFFSET对应指令位置，VALUE对应符号.在连接过程中会扫描符号表，如果符号未定义，会报链接错误。<br>静态链接的缺点很明显，一是浪费空间，因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以同一个目标文件都在内存存在多个副本；另一方面就是更新比较困难，因为每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>动态链接出现的原因就是为了解决静态链接中提到的两个问题，一方面是空间浪费，另外一方面是更新困难。下面介绍一下如何解决这两个问题。  </p>
<ul>
<li>动态链接的过程：<br>假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。</li>
<li>优缺点<br>动态链接的优点显而易见，就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；另一个优点是，更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</li>
<li>如何重定位？<br>前面我们讲过静态链接时地址的重定位，那我们现在就在想动态链接的地址又是如何重定位的呢？虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>前世今生</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：进程间通信</title>
    <url>/2021/09/14/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h3><p>适用场景：在父子线程间传递信息。<br>核心是pipe函数，创建了全双工的两个文件描述符。下图来自APUE十五章。<br><img src="/images/ipc-1.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> err = <span class="built_in">pipe</span>(fd);</span><br><span class="line">    <span class="type">char</span> line[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span>(err == <span class="number">-1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pipe error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;fork error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">char</span> s[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>], s, <span class="built_in">sizeof</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">read</span>(fd[<span class="number">0</span>], line, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, line, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命令管道"><a href="#命令管道" class="headerlink" title="命令管道"></a>命令管道</h3><p>在Linux中使用mkfifo函数创建一个命令管道，可以使用此管道实现不同进程之间的通信。<br>命名管道和匿名的相同和不用是：</p>
<ul>
<li>相同：<ul>
<li>都用管道通信</li>
<li>管道数据都存在内核内存的缓冲区</li>
</ul>
</li>
<li>不同：<ul>
<li>匿名不在磁盘建立管道文件，FIFO在磁盘建立文件</li>
<li>PIPE需要进程具有亲缘关系，FIFO不需要</li>
</ul>
</li>
</ul>
<p>读和写可以设置阻塞或者非阻塞：</p>
<ul>
<li>阻塞：<ul>
<li>写端等待数据被读走后才写</li>
<li>读端等待数据写入后才读</li>
</ul>
</li>
<li>非阻塞：<ul>
<li>写端一直写，直到缓冲区满</li>
<li>读端无论有无数据，立刻返回</li>
</ul>
</li>
</ul>
<p>下面是一个使用实例：</p>
<p>写端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FIFE <span class="string">&quot;./fiffo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SIZE PIPE_BUF</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mkfifo</span>(FIFO_FIFE, <span class="number">0666</span>) &lt; <span class="number">0</span> &amp;&amp; errno != EEXIST)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;create fifo file error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> info[] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FIFE, O_CREAT | O_WRONLY, <span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">60</span>;</span><br><span class="line">            <span class="keyword">while</span>(-- count)&#123;</span><br><span class="line">                <span class="built_in">write</span>(fd, info, <span class="built_in">sizeof</span>(info));</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;writing&quot;</span> &lt;&lt; info &lt;&lt; <span class="string">&quot; msg to fifo&quot;</span> &lt;&lt; endl;</span><br><span class="line">                info[<span class="number">0</span>] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> sig[] = <span class="string">&quot;end&quot;</span>;</span><br><span class="line">            <span class="built_in">write</span>(fd, sig, <span class="built_in">sizeof</span>(sig));</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FIFE <span class="string">&quot;./fiffo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SIZE PIPE_BUF</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mkfifo</span>(FIFO_FIFE, <span class="number">0666</span>) &lt; <span class="number">0</span> &amp;&amp; errno != EEXIST)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;create fifo file error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[BUFF_SIZE];</span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FIFE, O_CREAT | O_RDONLY, <span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="built_in">read</span>(fd, buf, BUFF_SIZE);</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;reading &quot;</span> &lt;&lt; buf &lt;&lt; <span class="string">&quot; from fifo&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf, <span class="string">&quot;end&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号是异步的，一个进程不必通过任何操作来等待信号的到达。<br>使用信号有两个作用：</p>
<ul>
<li>让进程直到发生了一个特定的事件</li>
<li>强迫进程去执行信号处理程序</li>
</ul>
<p>ps: 信号机制是一种特殊的软中断设计。</p>
<p>信号机制底层实现：</p>
<ol>
<li>信号产生：内核更新目标进程的数据结构表示一个新信号已发送；</li>
<li>信号传递：内核强迫目标进程：<ul>
<li>改变进程的执行状态</li>
<li>执行一个信号处理函数</li>
</ul>
</li>
<li>注意：当信号产生但还未被传递，则称为挂起信号。进程执行信号处理函数时屏蔽同编号的信号。</li>
</ol>
<p>信号处理的相关源码和细节<a href="https://os.51cto.com/art/202108/675743.htm">参考这篇文章</a>.<br>用一张图来概括：<br><img src="/images/ipc-2.png"></p>
<p>下面写一个实例吧：<br>在新版系统中使用sigaction处理信号：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 sigaction 结构取代了单一的 sighandler_t 函数指针</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">	<span class="built_in">void</span>     (*sa_handler)(<span class="type">int</span>); <span class="comment">// 信号处理函数</span></span><br><span class="line">	<span class="built_in">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);	<span class="comment">// 另一种替代的信号处理函数</span></span><br><span class="line">	<span class="type">sigset_t</span>   sa_mask;  <span class="comment">// 指定了应该被阻塞的信号掩码</span></span><br><span class="line">	<span class="type">int</span>        sa_flags; <span class="comment">// 指定一组修改信号行为的标志</span></span><br><span class="line">	<span class="built_in">void</span>     (*sa_restorer)(<span class="type">void</span>); <span class="comment">// 应用程序不是使用这个成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接收端：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR_EXIT(m) \</span></span><br><span class="line"><span class="meta">     do &#123; \</span></span><br><span class="line"><span class="meta">        perror(m); \</span></span><br><span class="line"><span class="meta">        exit(EXIT_FAILURE); \</span></span><br><span class="line"><span class="meta">    &#125;  while( 0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">( <span class="type">int</span>, <span class="type">siginfo_t</span> *,  <span class="type">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc,  <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">     <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    act.sa_sigaction = handler;  <span class="comment">//sa_sigaction与sa_handler只能取其一</span></span><br><span class="line">     <span class="comment">//sa_sigaction多用于实时信号，可以保存信息</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = SA_SIGINFO;  <span class="comment">// 设置标志位后可以接收其他进程</span></span><br><span class="line">     <span class="comment">// 发送的数据，保存在siginfo_t结构体中</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGUSR1, &amp;act,  <span class="literal">NULL</span>) &lt;  <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">ERR_EXIT</span>( <span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mypid:&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">     <span class="keyword">for</span> (; ;)</span><br><span class="line">        <span class="built_in">pause</span>();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">( <span class="type">int</span> sig, <span class="type">siginfo_t</span> *info,  <span class="type">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;recv a sig=%d data=%d data=%d\n&quot;</span>,</span><br><span class="line">           sig, info-&gt;si_value.sival_int, info-&gt;si_int);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发送端：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR_EXIT(m) \</span></span><br><span class="line"><span class="meta">     do &#123; \</span></span><br><span class="line"><span class="meta">        perror(m); \</span></span><br><span class="line"><span class="meta">        exit(EXIT_FAILURE); \</span></span><br><span class="line"><span class="meta">    &#125;  while( 0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc,  <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (argc !=  <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,  <span class="string">&quot;Usage %s pid\n&quot;</span>, argv[ <span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="built_in">atoi</span>(argv[ <span class="number">1</span>]);  <span class="comment">//字符串转换为整数</span></span><br><span class="line">     <span class="keyword">union</span> <span class="title class_">sigval</span> val;</span><br><span class="line">    val.sival_int =  <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sigqueue</span>(pid, SIGUSR1, val);  <span class="comment">// 只可以发信号给某个进程，而不能是进程组</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color = green>上面这两段程序在ubuntu 16.04虚拟机、linux16.04 系统运行正常，在wsl ubuntu 18.04下运行时，接受不到信号，暂时还没有找到原因。</font></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量的本质就是对资源的一组控制原语，进程间可以通过信号量实现同步。</p>
<p>下面用信号量实现经典的生产者消费者问题，<font color = green> 下面使用线程实现的，但是原理差不多，主要就是解决同步问题。</font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> item;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pSpeed 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cSpeed 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> mutex, empty, full;</span><br><span class="line"><span class="type">int</span> head, tail;</span><br><span class="line"><span class="type">int</span> buf[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showbuf</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head &gt; tail)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tail; i &lt;= head; ++ i)&#123;</span><br><span class="line">            cout &lt;&lt; buf[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(head &lt; tail)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tail; i &lt;= N; ++ i)&#123;</span><br><span class="line">            cout &lt;&lt; buf[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; head; ++ i)&#123;</span><br><span class="line">            cout &lt;&lt; buf[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++ i)&#123;</span><br><span class="line">            cout &lt;&lt; buf[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        item r = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sleep</span>(pSpeed);</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;empty);</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;mutex);</span><br><span class="line">        buf[head] = r;</span><br><span class="line">        head = (++ head) % N;</span><br><span class="line">        <span class="built_in">showbuf</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;full);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">customer</span><span class="params">(<span class="type">void</span>* id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">sleep</span>(cSpeed);</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;full);</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;mutex);</span><br><span class="line">        buf[tail] = <span class="number">0</span>;</span><br><span class="line">        tail = (++ tail) % N;</span><br><span class="line">        <span class="built_in">showbuf</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;empty);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc,  <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    head = <span class="number">0</span>, tail = head;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sem_init</span>(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sem_init error 1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sem_init</span>(&amp;empty, <span class="number">0</span>, N) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sem_init error 1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sem_init</span>(&amp;full, <span class="number">0</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sem_init error 1&quot;</span>);</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2, c1, c2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;p1, <span class="literal">NULL</span>, producer, (<span class="type">void</span>*)<span class="string">&quot;p1&quot;</span>))</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;p2, <span class="literal">NULL</span>, producer, (<span class="type">void</span>*)<span class="string">&quot;p1&quot;</span>))</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;c1, <span class="literal">NULL</span>, customer, (<span class="type">void</span>*)<span class="string">&quot;c1&quot;</span>))</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;c2, <span class="literal">NULL</span>, customer, (<span class="type">void</span>*)<span class="string">&quot;c2&quot;</span>))</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">pthread_join</span>(p1, <span class="literal">NULL</span>)) <span class="built_in">perror</span>(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">pthread_join</span>(p2, <span class="literal">NULL</span>)) <span class="built_in">perror</span>(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">pthread_join</span>(c1, <span class="literal">NULL</span>)) <span class="built_in">perror</span>(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">pthread_join</span>(c2, <span class="literal">NULL</span>)) <span class="built_in">perror</span>(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存就是允许两个或多个进程共享一定的存储区。就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。因为数据不需要在客户机和服务器端之间复制，数据直接写到内存，不用若干次数据拷贝，所以这是最快的一种IPC。<br><font color = orange>注意：共享内存没有任何的同步与互斥机制，所以要使用信号量来实现对共享内存的存取的同步。</font></p>
<p>下面以mmap为例说明如何进行进程间通信：<br>注意需要先创建一个文件，文件名作为输入参数。<br>读端：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100  </span></span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="type">int</span> fd, nread, i;  </span><br><span class="line">     <span class="keyword">struct</span> <span class="title class_">stat</span> sb;  </span><br><span class="line">     <span class="type">char</span> *mapped, buf[BUF_SIZE];  </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUF_SIZE; i++) &#123;  </span><br><span class="line">          buf[i] = <span class="string">&#x27;#&#x27;</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">/* 打开文件 */</span>  </span><br><span class="line">     <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">          <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">     </span><br><span class="line">     <span class="comment">/* 获取文件的属性 */</span>  </span><br><span class="line">     <span class="keyword">if</span> ((<span class="built_in">fstat</span>(fd, &amp;sb)) == <span class="number">-1</span>) &#123;  </span><br><span class="line">          <span class="built_in">perror</span>(<span class="string">&quot;fstat&quot;</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">     </span><br><span class="line">     <span class="comment">/* 将文件映射至进程的地址空间 */</span>  </span><br><span class="line">     <span class="keyword">if</span> ((mapped = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, sb.st_size, PROT_READ |   </span><br><span class="line">                    PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)) == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;  </span><br><span class="line">          <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">     </span><br><span class="line">     <span class="comment">/* 文件已在内存, 关闭文件也可以操纵内存 */</span>  </span><br><span class="line">     <span class="built_in">close</span>(fd);  </span><br><span class="line">     </span><br><span class="line">     <span class="comment">/* 每隔两秒查看存储映射区是否被修改 */</span>  </span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">          cout &lt;&lt; mapped &lt;&lt; endl;</span><br><span class="line">          <span class="built_in">sleep</span>(<span class="number">2</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>写端：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进程B的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100  </span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;  </span><br><span class="line">    <span class="type">int</span> fd, nread, i;  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> sb;  </span><br><span class="line">    <span class="type">char</span> *mapped, buf[BUF_SIZE];  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUF_SIZE; i++) &#123;  </span><br><span class="line">        buf[i] = <span class="string">&#x27;#&#x27;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 打开文件 */</span>  </span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获取文件的属性 */</span>  </span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">fstat</span>(fd, &amp;sb)) == <span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fstat&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 私有文件映射将无法修改文件 */</span>  </span><br><span class="line">    <span class="keyword">if</span> ((mapped = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, sb.st_size, PROT_READ |   </span><br><span class="line">                    PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)) == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 映射完后, 关闭文件也可以操纵内存 */</span>  </span><br><span class="line">    <span class="built_in">close</span>(fd);  </span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">/* 修改一个字符 */</span>  </span><br><span class="line">        mapped[<span class="number">0</span>] = <span class="string">&#x27;9&#x27;</span>; </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; mapped &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Linux的消息队列(queue)实质上是一个链表, 它有消息队列标识符(queue ID). msgget创建一个新队列或打开一个存在的队列; msgsnd向队列末端添加一条新消息; msgrcv从队列中取消息, 取消息是不一定遵循先进先出的, 也可以按消息的类型字段取消息。<br>下面实例说明如何利用linux msg系列系统调用来使用消息队列进行进程间通信：<br>发送端：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LEN = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">item</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> data[MAX_LEN];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> handle_error(msg) \</span></span><br><span class="line"><span class="meta">        perror(msg);    \</span></span><br><span class="line"><span class="meta">        exit(-1);   </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>  </span>&#123;  </span><br><span class="line">     <span class="type">int</span> msqid;</span><br><span class="line">     item it;</span><br><span class="line">     <span class="type">long</span> <span class="type">int</span> msgtype = <span class="number">0</span>;</span><br><span class="line">     msqid = <span class="built_in">msgget</span>((<span class="type">key_t</span>)<span class="number">10086</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">     <span class="keyword">if</span>(msqid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">handle_error</span>(<span class="string">&quot;msg queue create error&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> count = <span class="number">20</span>;</span><br><span class="line">     <span class="keyword">while</span>(-- count)&#123;</span><br><span class="line">          <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</span><br><span class="line">               <span class="built_in">memcpy</span>(it.data, <span class="string">&quot;end&quot;</span>, <span class="built_in">sizeof</span>(<span class="string">&quot;end&quot;</span>));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">               string temp = <span class="string">&quot;number: &quot;</span> + <span class="built_in">to_string</span>(count);</span><br><span class="line">               <span class="type">const</span> <span class="type">char</span> * msg = temp.<span class="built_in">c_str</span>();</span><br><span class="line">               <span class="built_in">memcpy</span>(it.data, msg, <span class="built_in">sizeof</span>(msg));</span><br><span class="line">          &#125;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;sending:&quot;</span> &lt;&lt; it.data &lt;&lt; endl;</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">msgsnd</span>(msqid, &amp;it, <span class="built_in">sizeof</span>(item), <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="built_in">handle_error</span>(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>接收端：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进程B的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LEN = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">item</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> data[MAX_LEN];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> handle_error(msg) \</span></span><br><span class="line"><span class="meta">        perror(msg);    \</span></span><br><span class="line"><span class="meta">        exit(-1);   </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;  </span><br><span class="line">    <span class="type">int</span> msqid;</span><br><span class="line">    item it;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> msgtype = <span class="number">0</span>;</span><br><span class="line">    msqid = <span class="built_in">msgget</span>((<span class="type">key_t</span>)<span class="number">10086</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(msqid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">handle_error</span>(<span class="string">&quot;msg queue create error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">msgrcv</span>(msqid, &amp;it, <span class="built_in">sizeof</span>(item), msgtype, <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">handle_error</span>(<span class="string">&quot;msg rev error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;msg : &quot;</span> &lt;&lt; it.data &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(it.data, <span class="string">&quot;end&quot;</span>) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>常用于网络编程，在进程间通信时可以用，但是感觉大材小用了。在后续网络编程中会详细分析。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：页缓存</title>
    <url>/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E9%A1%B5%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="什么是页缓存"><a href="#什么是页缓存" class="headerlink" title="什么是页缓存"></a>什么是页缓存</h3><p>我们知道文件一般存放在硬盘（机械硬盘或固态硬盘）中，CPU 并不能直接访问硬盘中的数据，而是需要先将硬盘中的数据读入到内存中，然后才能被 CPU 访问。</p>
<p>由于读写硬盘的速度比读写内存要慢很多（DDR4 内存读写速度是机械硬盘500倍，是固态硬盘的200倍），所以为了避免每次读写文件时，都需要对硬盘进行读写操作，Linux 内核使用 页缓存（Page Cache） 机制来对文件中的数据进行缓存。</p>
<p>为了提升对文件的读写效率，Linux 内核会以页大小（4KB）为单位，将文件划分为多数据块。当用户对文件中的某个数据块进行读写操作时，内核首先会申请一个内存页（称为 页缓存）与文件中的数据块进行绑定。如下图所示：<br><img src="/images/pagecache.png"></p>
<p>如上图所示，当用户对文件进行读写时，实际上是对文件的 页缓存 进行读写。所以对文件进行读写操作时，会分以下两种情况进行处理：</p>
<p>当从文件中读取数据时，如果要读取的数据所在的页缓存已经存在，那么就直接把页缓存的数据拷贝给用户即可。否则，内核首先会申请一个空闲的内存页（页缓存），然后从文件中读取数据到页缓存，并且把页缓存的数据拷贝给用户。<br>当向文件中写入数据时，如果要写入的数据所在的页缓存已经存在，那么直接把新数据写入到页缓存即可。否则，内核首先会申请一个空闲的内存页（页缓存），然后从文件中读取数据到页缓存，并且把新数据写入到页缓存中。对于被修改的页缓存，内核会定时把这些页缓存刷新到文件中。</p>
<h3 id="页缓存实现"><a href="#页缓存实现" class="headerlink" title="页缓存实现"></a>页缓存实现</h3><p>在 Linux 内核中，使用 file 对象来描述一个被打开的文件，其中有个名为 f_mapping 的字段，定义如下；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">f_mapping</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码可以看出，f_mapping 字段的类型为 address_space 结构，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>           *<span class="title">host</span>;</span>      <span class="comment">/* owner: inode, block_device */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">page_tree</span>;</span>  <span class="comment">/* radix tree of all pages */</span></span><br><span class="line">    <span class="type">rwlock_t</span>               tree_lock;  <span class="comment">/* and rwlock protecting it */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>address_space 结构其中的一个作用就是用于存储文件的 页缓存，下面介绍一下各个字段的作用：</p>
<p>host：指向当前 address_space 对象所属的文件 inode 对象（每个文件都使用一个 inode 对象表示）。<br>page_tree：用于存储当前文件的 页缓存。<br>tree_lock：用于防止并发访问 page_tree 导致的资源竞争问题。<br>从 address_space 对象的定义可以看出，文件的 页缓存 使用了 radix树 来存储。</p>
<ul>
<li>radix树：又名基数树，它使用键值（key-value）对的形式来保存数据，并且可以通过键快速查找到其对应的值。内核以文件读写操作中的数据 偏移量 作为键，以数据偏移量所在的 页缓存 作为值，存储在 address_space 结构的 page_tree 字段中。(<font color=orange>其实简单点讲，radix树可以理解为压缩过的trie树，也就是把只有一个子孩子的节点合并到它的父节点中.</font>)<br>下图展示了上述各个结构之间的关系：<br><img src="/images/pagecache-2.png"></li>
</ul>
<p>左上角是一个file结构体，里面的mapping对应一个address_space,映射到一个radix树，radix存储的是文件偏移量对应的页缓存。如上图共有64个分叉，高度为2。Linux(2.6.7) 内核中的分叉为 64(2^6)，树高为 6(32位系统)或者 11(64位系统)，用来快速定位 32 位或者 64 位偏移，radix tree 中的每一个叶子节点指向文件内相应偏移所对应的Cache项。radix树为稀疏树提供了有效的存储，代替固定尺寸数组提供了键值到指针的快速查找。</p>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>现在我们来分析一下读取文件数据的过程，用户可以通过调用 read 系统调用来读取文件中的数据，其调用链如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">read()</span><br><span class="line">└→ sys_read()</span><br><span class="line">   └→ vfs_read()</span><br><span class="line">      └→ do_sync_read()</span><br><span class="line">         └→ generic_file_aio_read()</span><br><span class="line">            └→ do_generic_file_read()</span><br><span class="line">               └→ do_generic_mapping_read()</span><br></pre></td></tr></table></figure>
<p>从上面的调用链可以看出，read 系统调用最终会调用 do_generic_mapping_read 函数来读取文件中的数据，其实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">do_generic_mapping_read</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> file_ra_state *_ra,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">                        <span class="type">loff_t</span> *ppos,</span></span><br><span class="line"><span class="params">                        <span class="type">read_descriptor_t</span> *desc,</span></span><br><span class="line"><span class="params">                        <span class="type">read_actor_t</span> actor)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">cached_page</span>;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    cached_page = <span class="literal">NULL</span>;</span><br><span class="line">    index = *ppos &gt;&gt; PAGE_CACHE_SHIFT;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">find_page:</span><br><span class="line">        <span class="comment">// 1. 查找文件偏移量所在的页缓存是否存在</span></span><br><span class="line">        page = find_get_page(mapping, index);</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 2. 如果页缓存不存在, 那么跳到 no_cached_page 进行处理</span></span><br><span class="line">            <span class="keyword">goto</span> no_cached_page; </span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">page_ok:</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 3. 如果页缓存存在, 那么把页缓存的数据拷贝到用户应用程序的内存中</span></span><br><span class="line">        ret = actor(desc, page, offset, nr);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (ret == nr &amp;&amp; desc-&gt;count)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">readpage:</span><br><span class="line">        <span class="comment">// 4. 从文件读取数据到页缓存中</span></span><br><span class="line">        error = mapping-&gt;a_ops-&gt;readpage(filp, page);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">goto</span> page_ok;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">no_cached_page:</span><br><span class="line">        <span class="keyword">if</span> (!cached_page) &#123;</span><br><span class="line">            <span class="comment">// 5. 申请一个内存页作为页缓存</span></span><br><span class="line">            cached_page = page_cache_alloc_cold(mapping);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 把新申请的页缓存添加到文件页缓存中</span></span><br><span class="line">        error = add_to_page_cache_lru(cached_page, mapping, index, GFP_KERNEL);</span><br><span class="line">        ...</span><br><span class="line">        page = cached_page;</span><br><span class="line">        cached_page = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> readpage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do_generic_mapping_read 函数的实现比较复杂，经过精简后，上面代码只留下最重要的逻辑，可以归纳为以下几个步骤：</p>
<ul>
<li>通过调用 find_get_page 函数查找要读取的文件偏移量所对应的页缓存是否存在，如果存在就把页缓存中的数据拷贝到应用程序的内存中。</li>
<li>否则调用 page_cache_alloc_cold 函数申请一个空闲的内存页作为新的页缓存，并且通过调用 add_to_page_cache_lru 函数把新申请的页缓存添加到文件页缓存和 LRU 队列中（后面会介绍）。</li>
<li>通过调用 readpage 接口从文件中读取数据到页缓存中，并且把页缓存的数据拷贝到应用程序的内存中。<br>从上面代码可以看出，当页缓存不存在时会申请一块空闲的内存页作为页缓存，并且通过调用 add_to_page_cache_lru 函数把其添加到文件的页缓存和 LRU 队列中。</li>
</ul>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：文件系统</title>
    <url>/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>感觉<a href="https://blog.csdn.net/yuexiaxiaoxi27172319/article/details/45241923">这篇文章</a>已经讲的十分透彻清晰。另外需要掌握细节的话参考《Linux内核设计与实现（第三版）》第十三章：虚拟文件系统。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络编程：epoll内核原理</title>
    <url>/2021/09/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Aepoll%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="内核函数poll-wait"><a href="#内核函数poll-wait" class="headerlink" title="内核函数poll_wait"></a>内核函数poll_wait</h3><ul>
<li>作用：把当前进程加入到驱动里自定义的等待队列上 </li>
<li>当驱动事件就绪后，就可以在驱动里自定义的等待队列上唤醒调用poll的进程</li>
</ul>
<h3 id="钩子poll"><a href="#钩子poll" class="headerlink" title="钩子poll"></a>钩子poll</h3><p>内核f_op-&gt;poll必须配合驱动自己的等待队列才能用，不然驱动有事件产生后不知道哪些进程调用了poll来等待这个事件：<br>内核f_op-&gt;poll要做的事情：</p>
<ul>
<li>调用poll_wait，将当前进程放入驱动设备的等待队列上，这样驱动就知道哪些进程在调用poll等待事件</li>
<li>检查此时立刻已有的事件（POLLIN\POLLOUT\POLLERR……）并返回掩码表示<br>f_op-&gt;poll是一个非阻塞的操作，立即返回，返回值以掩码形式表示当前已产生的事件集合。<br>例如：<br>snull驱动有两个自定义的等待队列：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wait_queue_head_t</span> inq;<span class="comment">//读取进程无数据可读时，在此队列等待</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> outq;<span class="comment">//写入进程无空间可写时，在此队列等待</span></span><br></pre></td></tr></table></figure>
由于snull驱动的读操作read会在读取数据后，唤醒outq队列上的写进程们<br>且snull驱动的写操作write会在写入数据后，唤醒inq队列上的读进程们，因此snull驱动的poll操作：</li>
</ul>
<ol>
<li>调用poll_wait将当前进程加入到inq;</li>
<li>调用poll_wait将当前进程加入到outq;</li>
<li>查看当前有什么事件，返回掩码.<br>假设某进程X调用poll，则进程X会出现在inq与outq等待队列上</li>
</ol>
<p>之后snull写入时，由于将唤醒inq，故调用poll而进入inq的进程X被唤醒<br>同理，snull读取时，由于将唤醒outq，故调用poll而进入outq的进程X被唤醒.<br>于是，读、写事件唤醒了调用poll等待事件产生的进程们。</p>
<h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>等待队列对头：wait_queue_head_t<br>队列的成员：wait_queue_t<br>wait_queue_t的成员:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *private; <span class="comment">/*指向进程描述符task_struct*/</span></span><br><span class="line"><span class="type">wait_queue_func_t</span>  func;<span class="comment">//唤醒时调用此函数，即钩子函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">task_list</span>;</span><span class="comment">//队列链表指针</span></span><br></pre></td></tr></table></figure>
<p><font color = orange>一般钩子函数func是内核默认函数default_wake_function，功能就是唤醒进程。<br>我们也可以在把进程放入等待队列时主动设定钩子函数，使得在唤醒进程时自动执行我们需要的操作.</font><br><font color = red>epoll就利用了队列钩子函数：把产生的事件内容copy到rdlist,这样，事件来临时会自动把事件内容放到rdlist中，而不需要我们自己遍历监听句柄们查有谁产生了事件.</font></p>
<h3 id="epoll内核原理1：调用epoll-create1-x2F-epoll-create"><a href="#epoll内核原理1：调用epoll-create1-x2F-epoll-create" class="headerlink" title="epoll内核原理1：调用epoll_create1&#x2F;epoll_create"></a>epoll内核原理1：调用epoll_create1&#x2F;epoll_create</h3><p>创建了epoll句柄eventpoll，返回其文件表示的描述符epfd<br><img src="/images/epoll-1.png"></p>
<p>eventpoll内部有以下关键数据结构：</p>
<ul>
<li>rbtree：红黑树，每个被加入到epoll监控的文件事件会创建一个epitem结构，作为rbtree节点; <ul>
<li>使用rbtree的优点：可容纳大量文件事件，方便增删改（O(lgN)）</li>
</ul>
</li>
<li>rdlist：内核链表，用于存放当前产生了期待事件产生的文件句柄们（这里的一个文件句柄可以理解为一个epoll_event）</li>
<li>wq：当进程调用epoll_wait等待时，进程加入等待队列wq</li>
<li>poll_wait：eventpoll本身的等待队列，由于eventpoll自己也被当做文件，这个队列用于自己被别人调用select&#x2F;poll&#x2F;epoll监听的情况（一般没啥用）。</li>
</ul>
<p>poll_wait在啥时候用呢：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = socket(...);</span><br><span class="line">efd1 = epoll_create();</span><br><span class="line">efd2 = epoll_create();</span><br><span class="line">epoll_ctl(efd1, EPOLL_CTL_ADD, fd, ...);</span><br><span class="line">epoll_ctl(efd2, EPOLL_CTL_ADD, efd1, ...);</span><br></pre></td></tr></table></figure>
<p>如上，efd1监控fd，而efd2监控了efd1，即嵌套的epoll监控：epoll监控另一个epoll句柄<br>efd2要监控efd1，将调用efd1的poll函数<br>回忆之前说过：文件f_op-&gt;poll需要配合驱动提供的等待队列<br>对于epollfd，等待队列就是poll_wait<br>efd2监听efd1，会调用efd1-&gt;f_op-&gt;poll，于是把当前进程放到efd1的poll_wait队列上<br>在epoll的内核实现中，当efd1本身监听到fd事件产生后，会顺便唤醒poll_wait上的进程<br>于是，“efd1监听到事件” 被通知到efd2。这样，就实现了epollfd被其他多路复用监听了！<br>故：poll_wait就是用于epoll句柄被另外的多路复用监听的，配合epoll自己的f_op-&gt;poll，看起来一般用不到。</p>
<h3 id="epoll内核原理2：调用epoll-ctl操作句柄新增监控事件"><a href="#epoll内核原理2：调用epoll-ctl操作句柄新增监控事件" class="headerlink" title="epoll内核原理2：调用epoll_ctl操作句柄新增监控事件"></a>epoll内核原理2：调用epoll_ctl操作句柄新增监控事件</h3><p>epoll_ctl：EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL新增、修改、删除红黑树上的文件句柄。<br><font color = orange>其中epll_ctl：EPOLL_CTL_ADD新增句柄不仅仅新增红黑树节点，更关键的是对文件开始监控！与select&#x2F;poll的本质区别：并不是调用epoll_wait的时候才监听文件，而是EPOLL_CTL_ADD的时候就开始监听了!</font></p>
<ul>
<li>EPOLL_CTL_ADD<br>  epoll_ctl(epfd, EPOLL_CTL_ADD, fd, fdevent)核心流程：<ul>
<li>对要注册的事件event-&gt;events追加关心事件：EPOLLERR | EPOLLHUP(EPOLLERR、EPOLLHUP事件会被自动监听，即使我们没设置)</li>
<li>创建epitem结构，加入到红黑树中.</li>
<li><font color = red>revent &#x3D; file-&gt;f_op-&gt;poll，即调用poll，把当前进程放到文件的等待队列上且设置回调函数ep_poll_callback，返回值revent是文件当前已产生事件掩码.</font></li>
<li>检查返回事件：如果revent与关心事件event-&gt;events有交集（说明ADD之前事件就准备好了）<ul>
<li>把此epitem节点拷贝到rdlist链表中；（就绪句柄拷贝到rdlist）;</li>
<li>如果有进程在wq等待队列上（即有进程在调用epoll_wait等待），则唤醒之！</li>
<li>顺便，如果有进程在poll_wait等待队列上（即有进程调用多路复用来监听当前epoll句柄），则唤醒之！</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以看到，如果在EPOLL_CTL_ADD一个文件之前，这个文件关心的事件就已经产生了的话，由于会唤醒wq队列上的进程，则此时EPOLL_CTL_ADD会使得epoll_wait函数从阻塞中返回.</p>
<p><img src="/images/epoll-2.png"></p>
<ul>
<li><p>回调函数ep_poll_callback<br>  回调函数ep_poll_callback作为等待队列的回调函数：<br>  当文件事件来临，唤醒文件等待队列上进程，ep_poll_callback函数将被自动调用，并把已产生事件们作为其参数传入。<br>  流程：</p>
<ul>
<li>ep_poll_callback检查已产生事件与关心事件是否有交集，如果有：<ul>
<li>文件的epitem节点拷贝到rdlist链表上（就绪句柄拷贝到rdlist）</li>
<li>如果有进程在wq等待队列上（即有进程在调用epoll_wait等待），则唤醒之！</li>
<li>顺便，如果有进程在poll_wait等待队列上（即有进程调用多路复用来监听当前epoll句柄），则唤醒之！</li>
</ul>
</li>
</ul>
<p>  简而言之：回调函数把文件句柄拷贝到rdlist，并唤醒epoll_wait等待的进程</p>
</li>
</ul>
<h3 id="epoll内核原理3：当文件有事件来临时："><a href="#epoll内核原理3：当文件有事件来临时：" class="headerlink" title="epoll内核原理3：当文件有事件来临时："></a>epoll内核原理3：当文件有事件来临时：</h3><ol>
<li>对应的等待队列上的进程被唤醒，执行回调函数ep_poll_callback，并把已产生事件们以参数传入</li>
<li>call ep_poll_callback.<br><img src="/images/epoll-4.png"></li>
</ol>
<p>简而言之：事件发生时，文件句柄被自动拷贝到rdlist，调用epoll_wait等待的进程们被唤醒</p>
<h3 id="epoll内核原理4：调用epoll-wait等待事件"><a href="#epoll内核原理4：调用epoll-wait等待事件" class="headerlink" title="epoll内核原理4：调用epoll_wait等待事件"></a>epoll内核原理4：调用epoll_wait等待事件</h3><p>epoll_wait并不监听文件句柄，而是等待rdlist不空 or 收到信号 or 超时这三种条件后返回<br>伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">epoll_wait(epfd, events, MAXSIZE, timeout)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    jitimeout = 剩余时间，timeout换算为内核时间</span><br><span class="line">    <span class="keyword">while</span> rdlist为空：</span><br><span class="line">        当前进程放到等待队列wq中；</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            如果rdlist不空，或者jitimeout = <span class="number">0</span>超时</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            如果有信号挂起</span><br><span class="line">                res = EINTR</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            jitimeout = schedule_timeout(jitimeout)</span><br><span class="line">            让出CPU，唤醒后返回新的剩余时间</span><br><span class="line"></span><br><span class="line">    如果res = <span class="number">0</span>，说明rdlist不空 or 超时了</span><br><span class="line">        则把rdlist中句柄们调用ep_send_events函数拷贝到events数组中，返回拷贝了几个句柄，赋值给res</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//res = -1，收到信号；</span></span><br><span class="line">    <span class="comment">//res = 0，超时</span></span><br><span class="line">    <span class="comment">//res &gt; 0, 有res个句柄拷贝到events数组</span></span><br></pre></td></tr></table></figure>
<p>主要逻辑：</p>
<ul>
<li>不断让出CPU，直到： <ul>
<li>rdlist有数据</li>
<li>超时</li>
<li>收到信号</li>
</ul>
</li>
<li>如果rdlist有数据，则拷贝到用户传入的events数组<br><img src="/images/epoll-5.png"></li>
</ul>
<p>简而言之：等待rdlist不空或者超时、信号中断，rdlist不空则把句柄们拷贝到用户空间.</p>
<h3 id="水平触发、边沿触发"><a href="#水平触发、边沿触发" class="headerlink" title="水平触发、边沿触发"></a>水平触发、边沿触发</h3><p>拷贝句柄函数ep_send_events会先遍历rdlist中每个句柄，对于每个句柄，再次调用poll获取实际事件：</p>
<ol>
<li>如果与关心事件有交集：<br>如果句柄是水平触发（EPOLLLT），则再次把句柄加入到rdlist；否则从rdlist中删除.<br>于是水平模式下次还会准备好，这就是EPOLLET 与 EPOLLLT的区别原理</li>
<li>如果与关心事件无交集，从rdlist中删除之.<br>问题：如此一来看起来水平模式的句柄永远都不断重新加入rdlist，这就成永远都通知了吧？<br>当事件已经被处理完后，调用poll得到的实际事件与关心事件已经无交集了，于是会被删除的！</li>
</ol>
<p>ep_send_events函数内再次调用poll获取实际事件就是为了EPOLLLT模式而生的，防止其永远加入rdlist！<br>于是，EPOLLLT读事件 做到了只要有数据就不停通知，直到没数据就不再通知了.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络编程：select/poll内核原理</title>
    <url>/2021/09/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Aselect,poll%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,<span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>int maxfdp是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！在Windows中这个参数的值无所谓，可以设置不正确。</p>
</li>
<li><p>struct fd_set可以理解为一个集合，这个集合中存放的是文件描述符(file descriptor)，即文件句柄。fd_set集合可以通过一些宏由人为来操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD_ZERO(fd_set *fdset)：清空fdset与所有文件句柄的联系。 </span><br><span class="line">FD_SET(<span class="type">int</span> fd, fd_set *fdset)：建立文件句柄fd与fdset的联系。 </span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set *fdset)：清除文件句柄fd与fdset的联系。 </span><br><span class="line">FD_ISSET(<span class="type">int</span> fd, fdset *fdset)：检查fdset联系的文件句柄fd是否可读写，&gt;<span class="number">0</span>表示可读写。 </span><br></pre></td></tr></table></figure></li>
<li><p>struct timeval用来代表时间值，有两个成员，一个是秒数，另一个是毫秒数。 若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；第二，若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；第三，timeout的值大于0，这就是等待的超时时间，即select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span>      </span><br><span class="line">    <span class="type">long</span> tv_sec;   <span class="comment">/*秒 */</span></span><br><span class="line">    <span class="type">long</span> tv_usec;  <span class="comment">/*微秒 */</span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>三个fd_set分别监视文件描述符的读写异常变化，如果有select会返回一个大于0的值。如果没有则在timeout的时间后select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的读&#x2F;写&#x2F;异常变化。</p>
</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>源码中的调用树如下：<br><img src="/images/select-1.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">staticint <span class="title function_">core_sys_select</span><span class="params">(<span class="type">int</span> n, fd_set __user *inp, fd_set __user *outp, fd_set __user *<span class="built_in">exp</span>, s64 *timeout)</span> &#123;</span><br><span class="line">    <span class="comment">//读取当前进程的文件描述符表，如果传入的n大于当前进程最大的文件描述符，给予修正。</span></span><br><span class="line">    <span class="comment">//尝试使用栈分配内存，不够则用堆。需要使用6倍于最大描述符的描述符个数</span></span><br><span class="line">    <span class="comment">//get_fd_set调用copy_from_user从用户空间拷贝了fd_set</span></span><br><span class="line">    <span class="comment">//执行ret = do_select(n, &amp;fds, timeout);</span></span><br><span class="line">    <span class="comment">//将修改后的fd_set写回用户空间</span></span><br><span class="line">&#125;</span><br><span class="line">staticint <span class="title function_">core_sys_select</span><span class="params">(<span class="type">int</span> n, fd_set __user *inp, fd_set __user *outp, fd_set __user *<span class="built_in">exp</span>, s64 *timeout)</span> &#123;</span><br><span class="line">    <span class="comment">//读取当前进程的文件描述符表，如果传入的n大于当前进程最大的文件描述符，给予修正。</span></span><br><span class="line">    <span class="comment">//尝试使用栈分配内存，不够则用堆。需要使用6倍于最大描述符的描述符个数</span></span><br><span class="line">    <span class="comment">//get_fd_set调用copy_from_user从用户空间拷贝了fd_set</span></span><br><span class="line">    <span class="comment">//执行ret = do_select(n, &amp;fds, timeout);</span></span><br><span class="line">    <span class="comment">//将修改后的fd_set写回用户空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>do_select函数中，遍历所有n个fd，对每一个fd调用对应驱动程序中的poll函数。poll函数调用poll_wait函数，poll_wait函数调用__pollwait()，这个函数会初始化等待队列项（有个pollwake函数），并将该等待队列项添加到从驱动程序中传递过来的等待队列头中去。驱动程序在得知设备有IO事件时（通常是该设备上IO事件中断），会调用wakeup，wakeup –&gt; _wake_up_common -&gt; curr-&gt;func(即pollwake)。pollwake函数里面调用_pollwake函数, 通过pwq-&gt;triggered &#x3D; 1将进程标志为唤醒。再调用default_wake_function(&amp;dummy_wait, mode, sync, key)这个默认的通用唤醒函数唤醒调用select的进程。 请注意，poll函数会返回一个mask码值，通过这个值我们可以判断是否可读写。更详细的必须看 do_select源码。</p>
<h3 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h3><ol>
<li><p>select的睡眠过程<br>支持阻塞操作的设备驱动通常会实现一组自身的等待队列如读&#x2F;写等待队列用于支持上层(用户层)所需的BLOCK或NONBLOCK操作。当应用程序通过设备驱动访问该设备时(默认为BLOCK操作)，若该设备当前没有数据可读或写，则将该用户进程插入到该设备驱动对应的读&#x2F;写等待队列让其睡眠一段时间，等到有数据可读&#x2F;写时再将该进程唤醒。</p>
<p> select就是巧妙的利用等待队列机制让用户进程适当在没有资源可读&#x2F;写时睡眠，有资源可读&#x2F;写时唤醒。下面我们看看select睡眠的详细过程。</p>
<p> select会循环遍历它所监测的fd_set内的所有文件描述符对应的驱动程序的poll函数。驱动程序提供的poll函数首先会将调用select的用户进程插入到该设备驱动对应资源的等待队列(如读&#x2F;写等待队列)，然后返回一个bitmask告诉select当前资源哪些可用。当select循环遍历完所有fd_set内指定的文件描述符对应的poll函数后，如果没有一个资源可用(即没有一个文件可供操作)，则select让该进程睡眠，一直等到有资源可用为止，进程被唤醒(或者timeout)继续往下执行。</p>
</li>
<li><p>唤醒该进程的过程通常是在所监测文件的设备驱动内实现的，驱动程序维护了针对自身资源读写的等待队列。当设备驱动发现自身资源变为可读写并且有进程睡眠在该资源的等待队列上时，就会唤醒这个资源等待队列上的进程。</p>
</li>
</ol>
<h3 id="poll和select的区别"><a href="#poll和select的区别" class="headerlink" title="poll和select的区别"></a>poll和select的区别</h3><ol>
<li>使用的是定长数组，而poll是通过用户自定义数组长度的形式（pollfd[]）。</li>
<li>select只支持最大fd &lt; 1024，如果单个进程的文件句柄数超过1024，select就不能用了。poll在接口上无限制，考虑到每次都要拷贝到内核，一般文件句柄多的情况下建议用poll。</li>
<li>select由于使用的是位运算，所以select需要分别设置read&#x2F;write&#x2F;error fds的掩码。而poll是通过设置数据结构中fd和event参数来实现read&#x2F;write，比如读为POLLIN，写为POLLOUT，出错为POLLERR：</li>
<li>：select中fd_set是被内核和用户共同修改的，所以要么每次FD_CLR再FD_SET，要么备份一份memcpy进去。而poll中用户修改的是events，系统修改的是revents。所以参考muduo的代码，都不需要自己去清除revents，从而使得代码更加简洁。</li>
<li>select的timeout使用的是struct timeval *timeout，poll的timeout单位是int。</li>
<li>select使用的是绝对时间，poll使用的是相对时间。</li>
<li>select的timeout为NULL时表示无限等待，否则是指定的超时目标时间；poll的timeout为-1表示无限等待。所以有用select来实现usleep的。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络编程：同步/异步，阻塞/非阻塞，IO复用</title>
    <url>/2021/09/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9A%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%EF%BC%8CIO%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：<br><img src="/images/io-1.png"></p>
<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。<br>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
<h3 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src="/images/io-2.png"></p>
<p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<br>所以，用户进程其实是需要不断的主动询问kernel数据好了没有。</p>
<h3 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h3><p>它的基本原理就是select&#x2F;poll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：<br><img src="/images/io-3.png"></p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。<br>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select&#x2F;epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select&#x2F;epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）<br>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>linux下的asynchronous IO其实用得很少。先看一下它的流程：<br><img src="/images/io-4.png"></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h3 id="阻塞-x2F-非阻塞-同步-x2F-异步区别？"><a href="#阻塞-x2F-非阻塞-同步-x2F-异步区别？" class="headerlink" title="阻塞&#x2F;非阻塞,同步&#x2F;异步区别？"></a>阻塞&#x2F;非阻塞,同步&#x2F;异步区别？</h3><ul>
<li>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</li>
<li>A synchronous I&#x2F;O operation causes the requesting process to be blocked until that I&#x2F;O operation completes;<br>An asynchronous I&#x2F;O operation does not cause the requesting process to be blocked;<br>同步&#x2F;异步两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。<br>各个IO Model的比较如图所示：<br><img src="/images/io-5.png"></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核系列：软链接硬链接符号链接</title>
    <url>/2021/08/29/Linux%E5%86%85%E6%A0%B8%E7%B3%BB%E5%88%97%EF%BC%9A%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li>软连接<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s file slink </span><br></pre></td></tr></table></figure></li>
<li>硬链接<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln file hlink</span><br></pre></td></tr></table></figure></li>
</ul>
<p>观察inode编号：<br><img src="/images/hardsoft-1.png"><br><img src="/images/hardsoft-2.png"><br>硬链接和源文件有想用文件索引，软连接有单独文件索引</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li>删除硬链接源文件不影响，删除源文件硬链接存在，并且内容不变。</li>
<li>删除软连接源文件不影响，删除源文件软连接会找不到源文件。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>硬链接：指向文件的指针，增加文件的引用计数。应用场景之一是文件备份。</p>
<ul>
<li>硬链接不会建立自己的 inode 索引和 block（数据块），而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；</li>
</ul>
</li>
<li><p>软连接：相当于快捷方式。<br>  -软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号<br>  软链接可以链接目录文件、可以跨分区链接；硬链接是不可以的</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>NLP：BPE</title>
    <url>/2020/10/02/NLP%EF%BC%9ABPE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="BPE"><a href="#BPE" class="headerlink" title="BPE"></a>BPE</h3><p><img src="/images/bpe-1.jpg"></p>
<p><img src="/images/bpe-2.jpg"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>Language Model</tag>
      </tags>
  </entry>
  <entry>
    <title>NLP：K-Adapter</title>
    <url>/2020/10/02/NLP%EF%BC%9AK-Adapter/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="K-Adapter"><a href="#K-Adapter" class="headerlink" title="K-Adapter"></a>K-Adapter</h3><p><img src="/images/K-Adapter-1.jpg"></p>
<p><img src="/images/K-Adapter-2.jpg"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>预训练</tag>
      </tags>
  </entry>
  <entry>
    <title>NLP：AE&amp;AR模型对比分析</title>
    <url>/2020/10/02/NLP%EF%BC%9AAE&amp;AR%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="AE-amp-AR优缺点、优缺点分析"><a href="#AE-amp-AR优缺点、优缺点分析" class="headerlink" title="AE&amp;AR优缺点、优缺点分析"></a>AE&amp;AR优缺点、优缺点分析</h3><p><img src="/images/aear-1.jpg"></p>
<p><img src="/images/aear-2.jpg"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>预训练</tag>
      </tags>
  </entry>
  <entry>
    <title>NLP：K-Bert</title>
    <url>/2020/10/02/NLP%EF%BC%9AK-BERT/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="K-BERT"><a href="#K-BERT" class="headerlink" title="K-BERT"></a>K-BERT</h3><p><img src="/images/K-BERT-1.jpg"><br><img src="/images/K-BERT-2.jpg"><br><img src="/images/K-BERT-3.jpg"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>预训练</tag>
      </tags>
  </entry>
  <entry>
    <title>NLP：Knowledge-Enhanced PTMs</title>
    <url>/2020/10/02/NLP%EF%BC%9AKnowledge-enhenced-PTM/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="Knowledge-Enhanced-PTMs"><a href="#Knowledge-Enhanced-PTMs" class="headerlink" title="Knowledge-Enhanced PTMs"></a>Knowledge-Enhanced PTMs</h3><p><img src="/images/Knowledge-Enhanced-PTM.jpg"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>预训练</tag>
      </tags>
  </entry>
  <entry>
    <title>NLP：Transformer变种</title>
    <url>/2020/10/02/NLP%EF%BC%9Atransformer%E5%8F%98%E7%A7%8D/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="transformer变种"><a href="#transformer变种" class="headerlink" title="transformer变种"></a>transformer变种</h3><p><img src="/images/transformer%E5%8F%98%E7%A7%8D_%E9%A1%B5%E9%9D%A2_1.jpg"><br><img src="/images/transformer%E5%8F%98%E7%A7%8D_%E9%A1%B5%E9%9D%A2_2.jpg"><br><img src="/images/transformer%E5%8F%98%E7%A7%8D_%E9%A1%B5%E9%9D%A2_3.jpg"><br><img src="/images/transformer%E5%8F%98%E7%A7%8D_%E9%A1%B5%E9%9D%A2_4.jpg"><br><img src="/images/transformer%E5%8F%98%E7%A7%8D_%E9%A1%B5%E9%9D%A2_5.jpg"><br><img src="/images/transformer%E5%8F%98%E7%A7%8D_%E9%A1%B5%E9%9D%A2_6.jpg"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>预训练</tag>
      </tags>
  </entry>
  <entry>
    <title>NLP：大规模预训练模型</title>
    <url>/2020/10/02/NLP%EF%BC%9A%E9%A2%84%E8%AE%AD%E7%BB%83%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ol>
<li>Language Representation Learning<br>下图展示了NLP的一般网络结构，下面一层是对词进行非上下文的编码，上面一层代表了在具体任务上对词进行基于上下文的编码。<br><img src="/images/survey-1.png"></li>
</ol>
<ul>
<li>Non-contextual Embeddings：<br>下面这层嵌入的目标是将离散的语言符号映射到连续的embedding空间中，一般在训练的过程中是随着具体任务的其他模型参数一起训练的。<br>这种嵌入有两个缺点，首先是这种嵌入是静态的，也就是说词嵌入表示不随着文本的改变而改变，第二点是会出现OOV问题，因此这种表示没办法对一词多义的词进行良好的表示，为了解决这个问题，character-level和sub-word level的word分解被广泛应用到NLP任务中，例如说CharCNN，FastTest,BPE等。</li>
<li>Contextual Embeddings：<br>为了解决一词多义等词嵌入问题，必须结合上下文的信息来进行embedding，下面是几种方式，其中(a)和(b)属于sequence models,(c)属于None-sequence models。<br><img src="/images/survey-2.png"><br>(a)和(b)的优点是容易训练并且在不同的NLP任务中取得了不错的结果，缺点是无法捕捉长期依赖。(c)的优点是可以捕捉任意两个词之间的关系，更加灵活和强大，缺点是需要十分庞大的训练语料并且在小数据集上容易过拟合。</li>
</ul>
<h3 id="Overview-of-PTMs"><a href="#Overview-of-PTMs" class="headerlink" title="Overview of PTMs"></a>Overview of PTMs</h3><ol>
<li>预训练任务<br>预训练任务主要分成三种：</li>
</ol>
<ul>
<li>Supervised learning</li>
<li>Unsupervised learning（簇、密度、隐藏表示）</li>
<li>Self-Supervised learning（MLM、NSP等）</li>
</ul>
<ol start="2">
<li><p>Language Modeling (LM)<br>Probabilistic language modeling (LM)是最通用的无监督预训练任务，下面给出一个形式化的定义：<br>给定一个文本序列<br><img src="/images/survey-3.png"><br>那么他的概率可以被分解成：<br><img src="/images/survey-4.png"><br>单向语言模型的缺点就是只能将其左方和他自己进行编码。</p>
</li>
<li><p>Masked Language Modeling (MLM)<br>具体来说就是遮挡掉一部分token，然后试图使用其他的token预测遮盖掉的部分，这种预训练方法也有缺点，就是在训练阶段和fine-tune阶段的token出现数量不一致，因为在训练阶段遮挡了一部分token</p>
</li>
<li><p>Sequence-to-Sequence MLM (Seq2Seq MLM)<br>MLM通常被看做是一个分类任务，将一个masked的seq输入到encoder中，然后通过softmax输出分类概率，或者我们可以使用encoder-decoder架构，在encoder输入masked的seq，让decoder去生成对应的token（MASS、T5）</p>
</li>
<li><p>Enhanced Masked Language Modeling (E-MLM)<br>对MLM任务进行提升，比如：</p>
<ul>
<li>RoBERTa使用动态mask；</li>
<li>UniLM将MLM任务扩展为单向、双向、seq2seq三种；</li>
<li>XLM使用双向平行语料库进行训练，XLM的每个训练样本包含含义相同语言不同的两条句子，而不是像BERT中一条样本仅来自同1一语言，XLM模型中，我们可以对每组句子，用一个语言的上下文信息去预测另一个语言被遮住的token。因为句子对中不同的随机词语会被遮住，模型可以利用翻译信息去预测token。模型也接受语言ID和不同语言token的顺序信息，也就是位置编码。这些新的元数据能帮模型学习到不同语言的token间关系。</li>
<li>structBERT:1&#x2F;3的时候： 是上下句，分类为1,1&#x2F;3的时候：  是上下句反序，分类为2,1&#x2F;3的时候： 是不同文档的句子，分类为3 这个任务对句子对的任务效果好。</li>
</ul>
</li>
<li><p>Permuted Language Modeling (PLM)<br>为了解决在训练阶段的[MASK]模型在微调阶段不存在的影响，Permuted Language Model被提出来了，其中个最有代表性的是Xlnet.</p>
</li>
<li><p>Denoising Autoencoder (DAE)<br>输入一个带有噪声的seq，使用一个seq2seq模型去重建无噪声文本，有以下几种方法去破坏文本：</p>
<ul>
<li>Token Masking：随机采样token然后将它们替换成[mask]</li>
<li>Token Deletion：随机删除token，模型需要知道删除的token的位置</li>
<li>Text Infilling:具有代表性的是spanBERT，随机屏蔽一段text，模型需要预测多少text被屏蔽。</li>
<li>Sentence Permutation:随机打乱句子的顺序。  </li>
<li>Document Rotation:随机选择一个token然后旋转documet，以这个token为开始，模型需要确定document的真实开始位置。</li>
</ul>
</li>
<li><p>Contrastive Learning (CTL)</p>
</li>
</ol>
<p>对比学习假设一些文本对相对于随机选择来说有更高的语义相似性。对于一个文本对，定义一个得分方程s(x,y)，任务的目标是最小化目标函数：<br><img src="/images/survey-5.png"><br>其中y+叫做和x相似的正样本，y-叫做和x不相似的负样本。得分方程通常通过learnable neural encoder学习，有两种方式，一种是<br><img src="/images/survey-6.png"><br>另一种是：<br><img src="/images/survey-7.png"><br>CTL的想法是”learning by comparison”，CTL通常比LM的复杂度低。</p>
<ol start="9">
<li>Deep InfoMax (DIM)</li>
</ol>
<p>最早是cv上面的概念，是通过最大化image representation 和local regions之间的互信息来提升image representation表达能力的。泛化到nlp里面就是把seq开头的字符（比如[cls]）的hidden state作为文本的编码表示，DIM的目标是最大化<br><img src="/images/survey-8.png"><br>10. Replaced Token Detection (RTD)<br>主要思想和NCE一样，但是预测的是给定一个token的上下文预测这个token是否被替换。CBOW可以看做是一个RTD的简易版本。<br>ELECTRA：使用类似GAN的思想，具体参考论文。WKLM则是在entity-level替换单词（替换的单词和被替换的词具有相同的类别，也就是相似度比较高），然后训练模型判断实体是否被替换。<br>11. Next Sentence Prediction (NSP)<br>50%替换成随意的下一个句子，但是后来的工作对于这个预训练任务基本上没有采用，效果也很好。<br>12. Sentence Order Prediction (SOP)<br>打乱两个句子的顺序进行训练。</p>
<h3 id="PTM的分类"><a href="#PTM的分类" class="headerlink" title="PTM的分类"></a>PTM的分类</h3><ol>
<li>Representation Type：non-contextual and contextual models</li>
<li>Architectures：LSTM, Transformer encoder, Transformer decoder, and the full Transformer architecture</li>
<li>Pre-Training Task Types：2.1已经讨论过了</li>
<li>Extensions：knowledge-enriched PTMs, multilingual or language-specific PTMs, multi-model PTMs, domainspecific PTMs and compressed PTMs.</li>
</ol>
<p><img src="/images/survey-10.png"><br><img src="/images/survey-11.png"></p>
<h3 id="PTM扩展"><a href="#PTM扩展" class="headerlink" title="PTM扩展"></a>PTM扩展</h3><p>PTM的扩展</p>
<ol>
<li>Knowledge-Enriched PTMs</li>
</ol>
<ul>
<li>linguistically-informed BERT（LIBERT）:在BERT中引入语言学知识；</li>
<li>SentiLR：对每个单词引入情感标签；</li>
<li>SenseBERT：在训练过程中除了经典BERT的MLM任务等等，还引入了WordNet里面的软标签，e.g. bass具有noun.food，noun.animal，noun.artifact，noun.person三种标签，模型需要预测这些意义;</li>
<li>ERNIE：引入实体联系知识；</li>
<li>KnowBERT:在输入文本中显式建模实体跨度(Entity spans)，并使用实体链接器(Entity Linker)从KB中检测mention、检索相关的实体嵌入(Entity embeddings)，以形成知识增强的实体跨度表示形式。然后使用word-to-entity attention将单词的表示重新上下文化，以携带全部的实体信息。</li>
<li>KEPLER:将知识图谱的实体嵌入引入到预训练中；</li>
<li>K-BERT：将知识图谱的三元组形式通过tree-form的形式输入到BERT；</li>
<li>Pretrained encyclopedia：Weakly supervised</li>
</ul>
<p>knowledge-pretrained language model：引入知识图谱的知识<br>这些模型大多数会在引入知识的时候更新参数，这会带来灾难遗忘的问题。</p>
<ul>
<li>K-Adapter:在训练不同的预训练任务的时候，使用不同的adapter，这样可以保证连续的知识融合。</li>
<li>Enhancing pre-trained language representations with rich knowledge for machine reading comprehension:机器阅读理解模型，知识和文本融合，包括语言和事实知识的融合。</li>
<li>Barack’s wife hillary: Using knowledge graphs for fact-aware language modeling:将语言模型扩展到知识图谱语言模型。</li>
<li>Latent relation language models：将语言模型融合到latent relation language model</li>
</ul>
<h3 id="多语言"><a href="#多语言" class="headerlink" title="多语言"></a>多语言</h3><ol>
<li>Cross-Lingual Language Understanding (XLU)</li>
</ol>
<ul>
<li>Multilingual BERT：使用共享词库和权重在wikipedia上训练top104个语言，每个训练样本是单语言的，虽然没有跨语言样本，但是展现出了较好的效果。</li>
<li>XLM：前面提到过的，在平行语料中使用MLM训练。</li>
</ul>
<ol start="2">
<li>Cross-Lingual Language Generation (XLG)</li>
</ol>
<ul>
<li>MASS：不用多说</li>
<li>XNLG</li>
<li>mBART</li>
</ul>
<ol start="3">
<li>Multi-Modal PTMs</li>
</ol>
<ul>
<li>Video-Text PTMs<ol>
<li>VideoBERT</li>
<li>CBT</li>
<li>Uni-ViLM</li>
</ol>
</li>
<li>Image-Text PTMs<ol start="4">
<li>ViLBERT</li>
<li>LXMERT</li>
<li>VisualBERT</li>
<li>B2T2</li>
<li>VLBERT</li>
<li>Unicoder-VL</li>
<li>UNITER</li>
</ol>
</li>
<li>Audio-Text PTMs</li>
</ul>
<h3 id="预训练模型压缩"><a href="#预训练模型压缩" class="headerlink" title="预训练模型压缩"></a>预训练模型压缩</h3><p><img src="/images/survey-11.png"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>预训练</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11新特性：Alias-Template</title>
    <url>/2021/09/04/c++11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AAlias-Template/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>有时候模板名称很长，我们想用一个别名替代这串模板声明：<br>看似好像跟#define一样，就像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Vec<span class="string">&lt;T&gt;</span> template<span class="string">&lt;typename T&gt;</span> std::vector<span class="string">&lt;T,MyAlloc&lt;T&gt;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>于是上面这个#define会被替换成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line">Vec&lt;T&gt; cpll;</span><br><span class="line"><span class="comment">//转换结果</span></span><br><span class="line"><span class="keyword">template</span>&lt;typaname <span class="type">int</span>&gt; std::vector&lt;<span class="type">int</span>, MyAlloc&lt;<span class="type">int</span>&gt;&gt; coll;</span><br></pre></td></tr></table></figure>
<p>这是无法通过编译的，因为typedef是不接受参数的。<br>这时候我们就可以使用模板别名。如下面的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br></pre></td></tr></table></figure>
<p>我们还可以使用模板别名定义函数指针模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> myfunc = <span class="built_in">int</span>(*)(T, T);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// myfunc&lt;int&gt; 为函数指针类型，是类型名</span></span><br><span class="line">    <span class="comment">// pFunc 为函数指针</span></span><br><span class="line">    myfunc&lt;<span class="type">int</span>&gt; pFunc;    </span><br><span class="line">    pFunc = Add;    <span class="comment">// 将函数地址赋值给函数指针变量</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">pFunc</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11新特性：Variadic Templates</title>
    <url>/2021/09/02/c++11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AVariadic-Templates/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="使用形式"><a href="#使用形式" class="headerlink" title="使用形式"></a>使用形式</h3><p>可变参数模板(variadic template)为一个接受可变数目参数的模板函数或模板类。<br>用class…或typename…指出接下来的参数表示零个或多个类型的列表。<br>一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表(可以是一个函数的实参列表).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;empty&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; firstArg, <span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; firstArg;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在上面例子中,在函数形参输入是Types&amp;… args，省略在前，而在函数内则是args…，省略在后。<br>上例会输出每一个参数，直到为空时输出empty。展开参数包的函数有两个，一个是递归函数，另外一个是递归终止函数，参数包args…在展开的过程中递归调用自己，每调用一次参数包中的参数就会少一个，直到所有的参数都展开为止，当没有参数时，则调用非模板函数print终止递归过程。<br>编译器从函数实参推断模板参数类型.对可变参数模板,编译器还会推断包中的参数数目.用sizeof…()可以获取模板参数包的参数个数和函数参数包的参数个数.</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>可以方便使用递归调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_combine</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp;val)</span></span>&#123;</span><br><span class="line">    seed ^= std::<span class="built_in">hash</span>&lt;T&gt;()(val) + <span class="number">0x9e3779b9</span></span><br><span class="line">            + (seed &lt;&lt; <span class="number">6</span>) +(seed &gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp;val)</span></span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Types&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp;val, <span class="type">const</span> Types&amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">    <span class="built_in">hash_val</span>(seed,args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="type">const</span> Types&amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> seed = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">hash_val</span>(seed, args...);</span><br><span class="line">    <span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="type">size_t</span> res = <span class="built_in">hash_val</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3182UL</span>);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段函数的调用顺序是1 -&gt; 2 -&gt; 3 -&gt; 4。<br>下面还有一个经典的tuple例子：<br><img src="/images/vt-1.png"></p>
<p>对于递归继承，也可以使用可变模板参数实现。例如STL中的tuple：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... values&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head, Tail...&gt;:<span class="keyword">private</span> tuple&lt;Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">tuple</span>(Head v, Tail... vtail):</span><br><span class="line">    <span class="built_in">m_head</span>(v),<span class="built_in">inherited</span>(vtail...)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11新特性：decltype</title>
    <url>/2021/09/04/c++11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9Adecltype/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="源从何来"><a href="#源从何来" class="headerlink" title="源从何来"></a>源从何来</h3><p>很长时间以来我们都希望有这么一个功能：给定一个对象，通过某个函数或者关键字，获得它的类型。c++有typeid的实现，也就是返回一个对象的typeid字符串，但是这个字符串不能用来声明一个新变量。因此c++11就出现了decltype这个关键字。</p>
<h3 id="三大作用"><a href="#三大作用" class="headerlink" title="三大作用"></a>三大作用</h3><ul>
<li><p>声明返回类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(x + y)</span> <span class="title">add</span><span class="params">(T1 x, T2 y)</span></span>;</span><br></pre></td></tr></table></figure>
<p>还有另外一种写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 x, T2 y)</span> -&gt; <span class="title">decltype</span><span class="params">(x + y)</span></span>;<span class="comment">//和lambda有点像？</span></span><br></pre></td></tr></table></figure>
<p>在上面这个函数里，有两个模板参数，变量x和y对operator + 进行操作符重载之后，我们不知道函数的返回类型是什么，这个时候我们就可以用decltype来做。</p>
</li>
<li><p>元编程<br>在模板函数或者模板类里面，可以灵活使用decltype来获得模板类型定义新变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; coll;</span><br><span class="line">    <span class="comment">//通过对象名拿到类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(coll)::value_type elem;</span><br><span class="line">    <span class="comment">//得到模板参数对象的迭代器名</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(obj)</span>::iterator iterType</span>;</span><br><span class="line">    <span class="comment">//定义迭代器</span></span><br><span class="line">    iterType iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>传递lambda表达式的类型<br>使用decltype和lambda可以起到仿函数的作用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> Foo&amp; f1, <span class="type">const</span> Foo&amp; f2)&#123;</span><br><span class="line">    <span class="keyword">return</span> f1.<span class="built_in">data</span>() &gt; f2.<span class="built_in">data</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::set&lt;Foo,<span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">coll</span><span class="params">(cmp)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="和auto的区别"><a href="#和auto的区别" class="headerlink" title="和auto的区别"></a>和auto的区别</h3><ul>
<li>auto类型说明符用编译器计算变量的初始值来推断其类型,而decltype虽然也让编译器分析表达式并得到它的类型,但是不实际计算表达式的值。</li>
<li>编译器推断出来的auto类型有时候和初始值的类型并不完全一致,编译器会适当的改变结果类型使其更符合初始化规则,例如，auto一般会忽略掉顶层const，而把底层const保留下来,与之相反,decltype会保留变量的顶层const。</li>
<li>decltype的结果类型与表达形式密切相关。有一种情况需要特别注意：对于decltype 所用表达式来说，如果变量名加上一对括号，则得到的类型与不加上括号的时候可能不同。如果decltype使用的是一个不加括号的变量，那么得到的结果就是这个变量的类型。但是如果给这个变量加上一个或多层括号，那么编译器会把这个变量当作一个表达式看待，变量是一个可以作为左值的特殊表达式，所以这样的decltype就会返回引用类型。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11新特性：lambda</title>
    <url>/2021/09/04/c++11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9Alambda/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h3><p>lambda表达式的本质就是重载了()运算符的类，这种类通常被称为functor，即行为像函数的类。因此lambda表达式对象其实就是一个匿名的functor。<br>一个标准的lambda表达式包括：捕获列表、参数列表、mutable指示符、尾置返回类型（-&gt;返回类型）和函数体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (params list) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>capture list：捕获外部变量列表</li>
<li>params list：形参列表</li>
<li>mutable指示符：用来说用是否可以修改捕获的变量</li>
<li>exception：异常设定</li>
<li>return type：返回类型</li>
<li>function body：函数体</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>lambda实际上是一个匿名仿函数对象。重载operator()来实现仿函数功能。基本使用方法如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="type">int</span> x = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">auto</span> fun = [&amp;x,y](<span class="type">int</span> x, <span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">fun</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反汇编之后可以看到：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   <span class="number">0x0000000000401569</span> &lt;+<span class="number">0</span>&gt;:     <span class="keyword">push</span>   <span class="built_in">rbp</span></span><br><span class="line">   <span class="number">0x000000000040156a</span> &lt;+<span class="number">1</span>&gt;:     <span class="keyword">mov</span>    <span class="built_in">rbp</span>,<span class="built_in">rsp</span></span><br><span class="line">   <span class="number">0x000000000040156d</span> &lt;+<span class="number">4</span>&gt;:     <span class="keyword">sub</span>    <span class="built_in">rsp</span>,<span class="number">0x40</span></span><br><span class="line">   <span class="number">0x0000000000401571</span> &lt;+<span class="number">8</span>&gt;:     <span class="keyword">call</span>   <span class="number">0x4016f0</span> &lt;__main&gt;</span><br><span class="line">   <span class="number">0x0000000000401576</span> &lt;+<span class="number">13</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x8</span>],<span class="number">0x9</span>   </span><br><span class="line">   <span class="number">0x000000000040157d</span> &lt;+<span class="number">20</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x4</span>],<span class="number">0x13</span>  </span><br><span class="line">   <span class="number">0x0000000000401584</span> &lt;+<span class="number">27</span>&gt;:    <span class="keyword">lea</span>    <span class="built_in">rax</span>,[<span class="built_in">rbp</span>-<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x0000000000401588</span> &lt;+<span class="number">31</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x20</span>],<span class="built_in">rax</span>  </span><br><span class="line">   <span class="number">0x000000000040158c</span> &lt;+<span class="number">35</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x4</span>]   </span><br><span class="line">   <span class="number">0x000000000040158f</span> &lt;+<span class="number">38</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x18</span>],<span class="built_in">eax</span>  </span><br><span class="line">   <span class="number">0x0000000000401592</span> &lt;+<span class="number">41</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x8</span>]   </span><br><span class="line">   <span class="number">0x0000000000401595</span> &lt;+<span class="number">44</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x4</span>]   </span><br><span class="line">   <span class="number">0x0000000000401598</span> &lt;+<span class="number">47</span>&gt;:    <span class="keyword">lea</span>    <span class="built_in">rax</span>,[<span class="built_in">rbp</span>-<span class="number">0x20</span>]</span><br><span class="line">   <span class="number">0x000000000040159c</span> &lt;+<span class="number">51</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">r8d</span>,<span class="built_in">ecx</span></span><br><span class="line">   <span class="number">0x000000000040159f</span> &lt;+<span class="number">54</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x00000000004015a2</span> &lt;+<span class="number">57</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x401550</span> &lt;&lt;lambda(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;::operator()(<span class="keyword">int</span>, <span class="keyword">int</span>) const&gt;</span><br><span class="line">=&gt; <span class="number">0x00000000004015a7</span> &lt;+<span class="number">62</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x00000000004015ac</span> &lt;+<span class="number">67</span>&gt;:    <span class="keyword">add</span>    <span class="built_in">rsp</span>,<span class="number">0x40</span></span><br><span class="line">   <span class="number">0x00000000004015b0</span> &lt;+<span class="number">71</span>&gt;:    <span class="keyword">pop</span>    <span class="built_in">rbp</span></span><br><span class="line">   <span class="number">0x00000000004015b1</span> &lt;+<span class="number">72</span>&gt;:    <span class="keyword">ret</span></span><br><span class="line">End of assembler dump</span><br></pre></td></tr></table></figure>
<p>看到call的是一个lambda(int,int)::operator()(int,int)const方法。<br>这个函数的反汇编结果是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) disas <span class="number">0x401550</span></span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function &lt;lambda(<span class="type">int</span>, <span class="type">int</span>)&gt;::<span class="built_in">operator</span>()(<span class="type">int</span>, <span class="type">int</span>) <span class="type">const</span>:</span><br><span class="line">   <span class="number">0x0000000000401550</span> &lt;+<span class="number">0</span>&gt;:     push   rbp</span><br><span class="line">   <span class="number">0x0000000000401551</span> &lt;+<span class="number">1</span>&gt;:     mov    rbp,rsp</span><br><span class="line">   <span class="number">0x0000000000401554</span> &lt;+<span class="number">4</span>&gt;:     mov    QWORD PTR [rbp+<span class="number">0x10</span>],rcx</span><br><span class="line">   <span class="number">0x0000000000401558</span> &lt;+<span class="number">8</span>&gt;:     mov    DWORD PTR [rbp+<span class="number">0x18</span>],edx  </span><br><span class="line">   <span class="number">0x000000000040155b</span> &lt;+<span class="number">11</span>&gt;:    mov    DWORD PTR [rbp+<span class="number">0x20</span>],r8d</span><br><span class="line">   <span class="number">0x000000000040155f</span> &lt;+<span class="number">15</span>&gt;:    mov    edx,DWORD PTR [rbp+<span class="number">0x18</span>]</span><br><span class="line">   <span class="number">0x0000000000401562</span> &lt;+<span class="number">18</span>&gt;:    mov    eax,DWORD PTR [rbp+<span class="number">0x20</span>]</span><br><span class="line">   <span class="number">0x0000000000401565</span> &lt;+<span class="number">21</span>&gt;:    add    eax,edx</span><br><span class="line">   <span class="number">0x0000000000401567</span> &lt;+<span class="number">23</span>&gt;:    pop    rbp</span><br><span class="line">   <span class="number">0x0000000000401568</span> &lt;+<span class="number">24</span>&gt;:    ret</span><br></pre></td></tr></table></figure>

<h3 id="捕获形式"><a href="#捕获形式" class="headerlink" title="捕获形式"></a>捕获形式</h3><center>

<table>
<thead>
<tr>
<th align="center">捕获形式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[]</td>
<td align="center">不捕获任何外部变量</td>
</tr>
<tr>
<td align="center">[变量名, …]</td>
<td align="center">默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td>
</tr>
<tr>
<td align="center">[this]</td>
<td align="center">以值的形式捕获this指针</td>
</tr>
<tr>
<td align="center">[&#x3D;]</td>
<td align="center">以值的形式捕获所有外部变量</td>
</tr>
<tr>
<td align="center">[&amp;]</td>
<td align="center">以引用形式捕获所有外部变量</td>
</tr>
<tr>
<td align="center">[&#x3D;, &amp;x]</td>
<td align="center">变量x以引用形式捕获，其余变量以传值形式捕获</td>
</tr>
<tr>
<td align="center">[&amp;, x]</td>
<td align="center">变量x以值的形式捕获，其余变量以引用形式捕获</td>
</tr>
</tbody></table>
</center>
需要注意的事项：

<ul>
<li>外部变量是在lambda匿名类构造时传入的。并且传入的是外部变量的引用（由于C++的引用本身就是语法糖，反汇编层面看到的是指针，但是结合源码分析不难得出这里应该是引用）。<font color = orange>ambda匿名类会将捕获参数中的变量添加到其成员变量中，并设置一个带有该参数引用类型的构造函数，并在构造函数中完成对相应成员变量的赋值。在调用其operator()函数时，如果用到了捕获列表中的局部变量，则从给匿名类对象的成员变量中取出。</font></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11新特性：type-Alias,noexcept,override,final</title>
    <url>/2021/09/04/c++11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9Atype-Alias,noexcept,override,final/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="Type-Alias"><a href="#Type-Alias" class="headerlink" title="Type Alias"></a>Type Alias</h3><p>在c++11之前定义函数指针需要typedef或者#define：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*func)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>现在我们可以使用using关键字定义，更加直观：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> func = <span class="built_in">void</span>(*)(<span class="type">int</span>,<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>在STL源码中也大量使用using替换typedef，例如vector的源码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span> = allocator&lt;_Ty&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123; <span class="comment">// varying size array of values</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> _Vb_val;</span><br><span class="line">    <span class="keyword">friend</span> _Tidy_guard&lt;vector&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> _Alty        = _Rebind_alloc_t&lt;_Alloc, _Ty&gt;;</span><br><span class="line">    <span class="keyword">using</span> _Alty_traits = allocator_traits&lt;_Alty&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">static_assert</span>(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v&lt;_Ty, <span class="keyword">typename</span> _Alloc::value_type&gt;,</span><br><span class="line">        _MISMATCHED_ALLOCATOR_MESSAGE(<span class="string">&quot;vector&lt;T, Allocator&gt;&quot;</span>, <span class="string">&quot;T&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> value_type      = _Ty;</span><br><span class="line">    <span class="keyword">using</span> allocator_type  = _Alloc;</span><br><span class="line">    <span class="keyword">using</span> pointer         = <span class="keyword">typename</span> _Alty_traits::pointer;</span><br><span class="line">    <span class="keyword">using</span> const_pointer   = <span class="keyword">typename</span> _Alty_traits::const_pointer;</span><br><span class="line">    <span class="keyword">using</span> reference       = _Ty&amp;;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="type">const</span> _Ty&amp;;</span><br><span class="line">    <span class="keyword">using</span> size_type       = <span class="keyword">typename</span> _Alty_traits::size_type;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> _Alty_traits::difference_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> _Scary_val = _Vector_val&lt;<span class="type">conditional_t</span>&lt;_Is_simple_alloc_v&lt;_Alty&gt;, _Simple_types&lt;_Ty&gt;,</span><br><span class="line">        _Vec_iter_types&lt;_Ty, size_type, difference_type, pointer, const_pointer, _Ty&amp;, <span class="type">const</span> _Ty&amp;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> iterator               = _Vector_iterator&lt;_Scary_val&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_iterator         = _Vector_const_iterator&lt;_Scary_val&gt;;</span><br><span class="line">    <span class="keyword">using</span> reverse_iterator       = _STD reverse_iterator&lt;iterator&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_reverse_iterator = _STD reverse_iterator&lt;const_iterator&gt;;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>typedef和type alias没有任何区别，两者都可以出现在namespace scope, block scope, class scope.</p>
<h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><p>定义函数不抛出异常。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span><span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span><span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>也可以在小括号里面写在某种情况下不抛出异常:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;typaname Type&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Type&amp; x, Type&amp; y)</span><span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(x.swap(y)))</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果在swap()内没有处理异常，异常就回随着函数调用向上返回，直到函数abort().<br>特别的，在右值拷贝和右值构造函数中，需要声明不抛出异常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mystring</span>&#123;</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//move constructor</span></span><br><span class="line">    <span class="built_in">Mystring</span>(Mystring&amp;&amp; str)<span class="keyword">noexcept</span>:</span><br><span class="line">    <span class="built_in">data</span>(str.data),<span class="built_in">len</span>(str.len)&#123;&#125;</span><br><span class="line">    <span class="comment">//move assignment</span></span><br><span class="line">    Mystring&amp; <span class="keyword">operator</span>=(Mystring&amp;&amp; str)<span class="keyword">noexcept</span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为move constructor在vector扩容的时候会被调用，如果抛出异常，没办法释放空间，就会造成内存泄露。</p>
<h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>字面意思就是覆盖，用在虚函数里面。如果子类需要复写父类的函数，加上这个关键字会比较安全。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">float</span>)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">//virtual void func(int) override&#123;&#125;; 错误</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">float</span>)</span> <span class="keyword">override</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>可以用在两个地方:</p>
<ul>
<li>如果一个类声明final类型，那么就不能被其他类继承。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">final</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">float</span>)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123; <span class="comment">// error</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">float</span>)</span> <span class="keyword">override</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>如果一个虚函数声明final，那么它就不能被复写。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">float</span>)</span><span class="keyword">final</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">float</span>)</span> <span class="keyword">override</span></span>&#123;&#125;;<span class="comment">//error</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11新特性：template-template-parameter</title>
    <url>/2021/09/04/c++11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9Atemplate-template-parameter/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>模板参数就是模板的参数，它是一种模板技巧，形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Foo</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)&#123;</span><br><span class="line">                c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(), <span class="built_in">T</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要向模板参数传递参数的时候，例如我需要一个形如Foo&lt;string,list<string>&gt;这样的类，在使用的时候可以这么定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板别名不能写在函数体内</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Lst = list&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Foo&lt;string, list&gt; mylist1;  <span class="comment">//写法错误</span></span><br><span class="line">Foo&lt;string, Lst&gt; mylist2;</span><br></pre></td></tr></table></figure>
<p>下面这个不是模板参数，因为list已经绑定了int类型的模板参数.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> operateo== &lt;&gt; (cosnt stack&amp;, <span class="type">const</span> stack&amp;);</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> operateo&lt; &lt;&gt; (cosnt stack&amp;, <span class="type">const</span> stack&amp;);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;</span><br><span class="line">  ......</span><br><span class="line">&#125;;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">stack&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; s2;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11新特性：右值引用</title>
    <url>/2021/09/04/c++11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>是一种新的引用类型。可以来帮助解决unnecessary copying问题和实现完美转发。<br>当右手边是一个右值，那么左手边可以steal resources from right side，而不需要重新分配内存。</p>
<h3 id="左值vs右值"><a href="#左值vs右值" class="headerlink" title="左值vs右值"></a>左值vs右值</h3><ul>
<li>左值：可以出现在operator&#x3D;左边的量。</li>
<li>右值：只能出现在operator&#x3D;右边的量。<br>以int为例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">4</span>;</span><br><span class="line">a = b;</span><br><span class="line">b = a;</span><br><span class="line">a + b = <span class="number">42</span>;<span class="comment">//error a+b 是一个右值</span></span><br></pre></td></tr></table></figure>
以string为例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line">s1 + s2 = s2; <span class="comment">//ok</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1:&quot;</span> &lt;&lt; s1 &lt;&lt; endl; <span class="comment">//s1:Hello</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s2:&quot;</span> &lt;&lt; s2 &lt;&lt; endl; <span class="comment">//s2:world</span></span><br><span class="line"><span class="built_in">string</span>() = <span class="string">&quot;World&quot;</span>;</span><br></pre></td></tr></table></figure>
以complex为例<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">3</span>,<span class="number">8</span>)</span>,<span class="title">c2</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">c1 + c2 = <span class="built_in">complex</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>,<span class="number">9</span>);</span><br><span class="line"><span class="built_in">complex</span>&lt;<span class="type">int</span>&gt;() = <span class="built_in">complex</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure>
从上面的例子来看，string和complex的临时对象可以出现在左边，这存在bug。<br>但是<font color=orange>临时对象一定是右值。</font><br>在看一个例子：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">foo</span>();</span><br><span class="line"><span class="type">int</span> *p = &amp;<span class="built_in">foo</span>(); <span class="comment">//error 函数返回类型是右值</span></span><br><span class="line"><span class="built_in">foo</span>() = <span class="number">7</span>; <span class="comment">//右值不能被赋值danms</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>如果需要减小临时对象释放和新对象内存分配和拷贝的开销，可以使用右值引用。<br><font color = orange>右值引用拷贝构造的底层原理就是对指针的浅拷贝。</font><br>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="引用折叠-amp-万能引用"><a href="#引用折叠-amp-万能引用" class="headerlink" title="引用折叠 &amp; 万能引用"></a>引用折叠 &amp; 万能引用</h3><ul>
<li>引用折叠：C++中禁止reference to reference，所以编译器需要对四种情况(也就是L2L,L2R,R2L,R2R)进行处理，将他们“折叠”(也可说是“坍缩”)成一种单一的reference。</li>
<li>万能引用：T&amp;&amp;<ul>
<li>T &amp;&amp; 碰到右值int &amp;&amp;， T匹配成int；</li>
<li>T &amp;&amp; 遇到左值 int ，也能匹配，T此时是int &amp;。</li>
<li>T &amp;&amp; 碰到左值const int，T匹配为 const int &amp;。</li>
<li>T &amp;&amp;碰到左值const int *（指针类型), T匹配为const int *&amp; </li>
<li>T &amp;&amp;碰到左值const int * const（指针类型), T匹配为const int *const &amp;<br>例如：</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testForward</span>(<span class="number">1</span>); <span class="comment">// case 1</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">testForward</span>(x); <span class="comment">// case 2</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;rx = x;</span><br><span class="line">    <span class="built_in">testForward</span>(rx); <span class="comment">// case 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>万能引用把实参类型推导为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//case 1 </span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">testForward</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> &amp;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//case 2</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">testForward</span>&lt;<span class="type">int</span> &amp;&gt;(<span class="type">int</span> &amp; v)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//case 3</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">testForward</span>&lt;<span class="type">const</span> <span class="type">int</span> &amp;&gt;(<span class="type">const</span> <span class="type">int</span> &amp; v)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><ul>
<li>动机：看下面这个例子<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T &amp; t)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue ref&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T &amp;&amp; t)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue ref&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span>&#123; </span><br><span class="line">    <span class="built_in">print</span>(v);<span class="comment">//v此时已经是个左值了,永远调用左值版本的print</span></span><br><span class="line">    <span class="built_in">print</span>(std::forward&lt;T&gt;(v)); <span class="comment">//本文的重点</span></span><br><span class="line">    <span class="built_in">print</span>(std::<span class="built_in">move</span>(v)); <span class="comment">//永远调用右值版本的print</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;======================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">testForward</span>(x); <span class="comment">//实参为左值</span></span><br><span class="line">    <span class="built_in">testForward</span>(std::<span class="built_in">move</span>(x)); <span class="comment">//实参为右值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Lvalue ref</span></span><br><span class="line"><span class="comment">// Lvalue ref</span></span><br><span class="line"><span class="comment">// Rvalue ref</span></span><br><span class="line"><span class="comment">// ======================</span></span><br><span class="line"><span class="comment">// Lvalue ref</span></span><br><span class="line"><span class="comment">// Rvalue ref</span></span><br><span class="line"><span class="comment">// Rvalue ref</span></span><br><span class="line"><span class="comment">// ======================</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>用户希望testForward(x);最终调用的是左值版本的print，而testForward(std::move(x));最终调用的是右值版本的print。</p>
<p>可惜的是，在testForward中，虽然参数v是右值类型的，但此时v在内存中已经有了位置，所以v其实是个左值！（请仔细阅读这段话，保证你理解了）</p>
<p>所以，print(v)永远调用左值版本的print，与用户的本意不符。print(std::move(v));永远调用右值版本的print，与用户的本意也不符。只有print(std::forward<T>(v));才符合用户的本意，这就是本文的主题。</p>
<p><font color = orange>不难发现，本质问题在于，左值右值在函数调用时，都转化成了左值(也就是有名称，可以取地址），使得函数转调用时无法判断左值和右值。</font></p>
<p>在STL中，随处可见这种问题。比如C++11引入的emplace_back，它接受左值也接受右值作为参数，接着，它转调用了空间配置器的construct函数，而construct又转调用了placement new，placement new根据参数是左值还是右值，决定调用拷贝构造函数还是移动构造函数。</p>
<h3 id="std-forward源码"><a href="#std-forward源码" class="headerlink" title="std::forward源码"></a>std::forward源码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接受左值</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接受右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当我们传入T &#x3D; int &amp;，经过模板参数推导和引用折叠：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> &amp; &amp;&amp; <span class="comment">//折叠</span></span><br><span class="line">forward(<span class="keyword">typename</span> std::remove_reference&lt;<span class="type">int</span> &amp;&gt;::type&amp; <span class="type">__t</span>) <span class="keyword">noexcept</span> <span class="comment">//remove_reference的作用与名字一致，不过多解释</span></span><br><span class="line">&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp; &amp;&amp;&gt;(<span class="type">__t</span>); &#125; <span class="comment">//折叠</span></span><br></pre></td></tr></table></figure>
<p>  最终转化为：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> &amp; <span class="comment">//折叠</span></span><br><span class="line">forward(<span class="type">int</span> &amp; <span class="type">__t</span>) <span class="keyword">noexcept</span> <span class="comment">//remove_reference的作用与名字一致，不过多解释</span></span><br><span class="line">&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&gt;(<span class="type">__t</span>); &#125; <span class="comment">//折叠</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们传入std::move(int)<br>  模板推导：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> &amp;&amp; </span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;<span class="type">int</span>&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span> <span class="comment">//remove_reference的作用与名字一致，不过多解释</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>  经过引用折叠：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> &amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="type">int</span> &amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span> <span class="comment">//remove_reference的作用与名字一致，不过多解释</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>  万能引用绑定到右值上时，不会发生引用折叠，所以这里没有引用折叠。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11新特性：智能指针</title>
    <url>/2021/09/14/c++11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="为什么要引入智能指针？"><a href="#为什么要引入智能指针？" class="headerlink" title="为什么要引入智能指针？"></a>为什么要引入智能指针？</h3><p>首先我们来看下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>*_ptr=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(_ptr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">test</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(...)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在test函数中new一个四字节的空间，</li>
<li>判断if条件的语句为真，抛出异常</li>
<li>main函数直接catch 捕获异常，函数返回0</li>
<li>try 执行了直接执行catch，程序结束，以至于没有执行delete_ptr释放空间，导致内存泄漏。</li>
</ol>
<p>理解智能指针需要从下面三个层次：</p>
<ol>
<li>从较浅的层面看，智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。</li>
<li>智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。</li>
<li>智能指针还有一个作用是把值语义转换成引用语义。</li>
</ol>
<h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><ul>
<li>性质</li>
</ul>
<ol>
<li>对其持有的对内存具有唯一拥有权。</li>
<li>对象销毁时会释放其持有的堆内存。</li>
</ol>
<ul>
<li>使用<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; sp2;</span><br><span class="line">sp2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; sp3 = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
注意尽量使用方式3去创建，因为形式3更安全。</li>
</ul>
<p>Q:为什么形式3更安全？<br>A:<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item21.md">参考《effective modern c++》</a></p>
<p>鉴于std::auto_ptr的前车之鉴，std::unique_ptr禁止赋值语义，为了达到这个效果，std::unique_ptr类的拷贝构造函数和赋值运算符被标记为delete。<br>但是可以通过移动构造函数来将堆内存转移。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">func</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(val));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; sp = <span class="built_in">func</span>(<span class="number">12</span>);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; sp2 = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">12</span>);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; sp3 = <span class="built_in">move</span>(sp2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>std::unique_ptr不仅可以持有一个堆对象，还可以持有一组堆对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>[]&gt; sp2;</span><br><span class="line">sp2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]);</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">sp3</span><span class="params">(make_unique&lt;<span class="type">int</span>[]&gt;(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p>加入堆内存对象内部还有需要回收的资源，我们还可以自定义智能指针的资源释放函数。<br>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Socket</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Socket</span>()&#123;&#125;</span><br><span class="line">    <span class="comment">//关闭资源句柄</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> deletor = [](Socket* pSocket) &#123;</span><br><span class="line">        <span class="comment">//关闭句柄</span></span><br><span class="line">        pSocket-&gt;<span class="built_in">close</span>();</span><br><span class="line">         <span class="keyword">delete</span> pSocket;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Socket, <span class="title">void</span><span class="params">(*)</span><span class="params">(Socket * pSocket)</span>&gt; <span class="title">spSocket</span><span class="params">(<span class="keyword">new</span> Socket(), deletor)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>unique_ptr对持有的资源具有独占性，shared_ptr持有的资源在多个shared_ptr<br>之间共享，每多一个shared_ptr对资源的引用，资源引用计数将增加1，每个指向该资源的<br>shared_ptr对象析构时，资源引用计数减一，最后一个shared_ptr对象析构时，发现资源<br>计数为0，将释放其持有的资源。多个线程之间，递增和减少资源的引用计数是安全的（不意味着<br>多个线程同时操纵资源对象是安全的）。shared_ptr使用use_count()来获取当前持有资源的<br>引用计数。除了上面描述的，基本上使用方法和unique_ptr相似。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; sp2;</span><br><span class="line">sp2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; sp3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>再看下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    cout &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    cout &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    sp2.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        shared_ptr&lt;A&gt; sp3 = sp1;</span><br><span class="line">        cout &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">A()</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">~A()</span><br></pre></td></tr></table></figure>
<p>实际开发中，有时候需要在类中返回包裹当前对象（this）的一个std::shared_ptr<br>对象给外部使用，C++ 新标准也为我们考虑到了这一点，有如此需求的类只要继承自<br>std::enable_shared_from_this 模板对象即可。用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;A&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">getSelf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，类 A 的继承 std::enable_shared_from_this 并提供一个<br>getSelf() 方法返回自身的 std::shared_ptr 对象，在 getSelf() 中<br>调用 shared_from_this() 即可。<br>陷阱一：不应该共享栈对象的 this 给智能指针对象<br>陷阱二：避免 std::enable_shared_from_this 的循环引用问题</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>std::weak_ptr 是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，<br>只是提供了对其管理的资源的一个访问手段，引入它的目的为协助 std::shared_ptr<br>工作。<br>std::weak_ptr 可以从一个 std::shared_ptr 或另一个std::weak_ptr 对象构造，<br>std::shared_ptr 可以直接赋值给 std::weak_ptr ，也可以通过 std::weak_ptr<br>的 lock() 函数来获得 std::shared_ptr。它的构造和析构不会引起引用计数的增<br>加或减少。std::weak_ptr 可用来解决 std::shared_ptr 相互引用时的死锁问题<br>（即两个std::shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降<br>为 0， 资源永远不会释放）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个shared_ptr对象</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造函数得到一个weak_ptr对象</span></span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过赋值运算符得到一个weak_ptr对象</span></span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; sp3 = sp1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过一个weak_ptr对象得到另外一个weak_ptr对象</span></span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; sp4 = sp2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">// use count: 1</span></span><br><span class="line"><span class="comment">// use count: 1</span></span><br><span class="line"><span class="comment">// use count: 1</span></span><br><span class="line"><span class="comment">// use count: 1</span></span><br></pre></td></tr></table></figure>
<p>既然，std::weak_ptr 不管理对象的生命周期，那么其引用的对象可能在某个时刻被销毁了<br>，如何得知呢？<br>std::weak_ptr 提供了一个 expired() 方法来做这一项检测，返回 true，<br>说明其引用的资源已经不存在了；返回 false，说明该资源仍然存在，这个时候可以使用<br>std::weak_ptr 的 lock() 方法得到一个std::shared_ptr 对象然后继续操作资源，以下<br>代码演示了该用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tmpConn_ 是一个 std::weak_ptr&lt;TcpConnection&gt; 对象</span></span><br><span class="line"><span class="comment">//tmpConn_引用的TcpConnection已经销毁，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (tmpConn_.<span class="built_in">expired</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">std::shared_ptr&lt;TcpConnection&gt; conn = tmpConn_.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (conn)&#123;</span><br><span class="line">    <span class="comment">//操作conn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有读者可能对上述代码产生疑问，既然使用了 std::weak_ptr 的 expired() 方<br>法判断了对象是否存在，为什么不直接使用 std::weak_ptr 对象对引用资源进行<br>操作呢？实际上这是行不通的，std::weak_ptr 类没有重写operator-&gt; 和 operator*<br>方法，因此不能 <em>std::shared_ptr 或 std::unique_ptr 一样直接操作对象，<br>同时 std::weak_ptr 类也没有重写 operator! 操作，因此也不能通过 std::weak_ptr</em>*<br>对象直接判断其引用的资源是否存在。<br>之所以weak_ptr 不增加引用资源的引用计数不管理资源的生命周期，是因为，即使它实现<br>了以上说的几个方法，调用它们也是不安全的，因为在调用期间，引用的资源可能恰好被<br>销毁了，这会造成棘手的错误和麻烦。<br>正确使用场景是那些资源如果可能就使用，如果不可使用则不用的场景，它不参与资源的生<br>命周期管理。例如，网络分层结构中，Session 对象（会话对象）利用 Connection 对象<br>（连接对象）提供的服务工作，但是 Session 对象不管理 Connection 对象的生命周期，<br>Session 管理 Connection 的生命周期是不合理的，因为网络底层出错会导致 Connection<br>对象被销毁，此时 Session 对象如果强行持有 Connection 对象与事实矛盾。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>NLP：预训练模型蒸馏</title>
    <url>/2020/10/02/NLP%EF%BC%9A%E9%A2%84%E8%AE%AD%E7%BB%83%E8%92%B8%E9%A6%8F/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>把一个大模型或者多个模型ensemble学到的知识迁移到另一个轻量级单模型上，方便部署。简单的说就是用小模型去学习大模型的预测结果，而不是直接学习训练集中的label。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/distill-1.png"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>知识蒸馏</tag>
      </tags>
  </entry>
  <entry>
    <title>c++STL系列：deque</title>
    <url>/2021/09/02/c++STL%E7%B3%BB%E5%88%97%EF%BC%9Adeque/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/images/deque-2.png"></p>
<p><img src="/images/deque-1.png"><br>STL中使用分段数组串接起来一个双向队列。我们使用buffer来描述这些分段数组。<br>deque使用一个map数组来管理这些buffer，里面存放指向这些buffer头的指针，如果deque需要向前或者扩充，就在map数组中填充指针。图中的start和finish迭代器用来管理deque的扩充。<br><font color=orange>总的来说，deque的存储模式是分段连续的。deque的控制中心行为模式类似vector，开始的时候在中心分配buffer指针，如果空间不足，就两倍增长。</font></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>deque的迭代器主要包含四个数据。</p>
<ul>
<li>cur：指向当前迭代器迭代的元素位置。</li>
<li>first：指向当前buffer首地址。</li>
<li>last：指向当前buffer末地址的下一个位置（主要遵循iterator的前闭后开原则）。</li>
<li>node：指向当前buffer在map数组中的位置。<br><img src="/images/deque-3.png"></li>
</ul>
<p>如何保持buffer在使用中的连续性？通过操作符重载和其他操作，调度指针。</p>
<h3 id="G4-9版本"><a href="#G4-9版本" class="headerlink" title="G4.9版本"></a>G4.9版本</h3><p><img src="/images/deque-5.png"></p>
<p>和其他容器一样，为了遵循面向对象，定义和实现分离的原则，重构了数据结构，但是基本原理没有变。</p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++STL系列：list</title>
    <url>/2021/09/02/c++STL%E7%B3%BB%E5%88%97%EF%BC%9Alist/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="G2-9源码结构"><a href="#G2-9源码结构" class="headerlink" title="G2.9源码结构"></a>G2.9源码结构</h3><p><img src="/images/list-1.png"></p>
<p>在低版本下list的结构比较简单，就是一个list模板类和一个node模板类。总体的数据结构事宜个环形双向链表。<br>begin()指向头结点，end()指向尾节点。</p>
<ul>
<li>迭代器<br><img src="/images/list-2.png"></li>
</ul>
<p>源码中迭代器的结构如下，迭代器重载了前++,后++，-&gt;,*等一系列操作符，为了达到指针的效果。<br>这里需要注意的第一个是++这个操作符重载，形如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;....&#125;</span><br></pre></td></tr></table></figure>
<p>的为后置++，而前置++ 不需要形参:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>++()&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>为什么后置++返回self，而后置返回一个引用呢？<font color=orange>是为了阻止后置++连续使用，也就是下面这种形式:</font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">i++++;<span class="comment">//错误 self类型不能++</span></span><br><span class="line">++++i;<span class="comment">//正确 </span></span><br></pre></td></tr></table></figure>

<p>另外需要注意的是-&gt;这个操作符重载,下面这个图阐述的很清楚:<br><img src="/images/list-3.png"></p>
<h3 id="G4-9版本"><a href="#G4-9版本" class="headerlink" title="G4.9版本"></a>G4.9版本</h3><p><img src="/images/list-4.png"></p>
<p>相对于G2.9版本，4.9版本的list充分利用了面向对象的设计方法，将实现类与基础类分割开，这符合effective c++的设计条款，但是对于源码阅读来说就不是很友好了。但是很庆幸，在基础的设计上新版本并没有特别多的改动，基本思想和原版本一致。<br>list的原理十分简单，下面简单总结一下list的使用。</p>
<center>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">erase()</td>
<td align="center">删除一个元素</td>
</tr>
<tr>
<td align="center">front()</td>
<td align="center">返回第一个元素</td>
</tr>
<tr>
<td align="center">get_allocator()</td>
<td align="center">返回list的配置器</td>
</tr>
<tr>
<td align="center">insert()</td>
<td align="center">插入一个元素到list中</td>
</tr>
<tr>
<td align="center">max_size()</td>
<td align="center">返回list能容纳的最大元素数量</td>
</tr>
<tr>
<td align="center">merge()</td>
<td align="center">合并两个list</td>
</tr>
<tr>
<td align="center">pop_back()</td>
<td align="center">删除最后一个元素</td>
</tr>
<tr>
<td align="center">pop_front()</td>
<td align="center">删除第一个元素</td>
</tr>
<tr>
<td align="center">push_back()</td>
<td align="center">在list的末尾添加一个元素</td>
</tr>
<tr>
<td align="center">push_front()</td>
<td align="center">在list的头部添加一个元素</td>
</tr>
<tr>
<td align="center">remove()</td>
<td align="center">从list删除元素</td>
</tr>
<tr>
<td align="center">remove_if()</td>
<td align="center">按指定条件删除元素</td>
</tr>
<tr>
<td align="center">resize()</td>
<td align="center">改变list的大小</td>
</tr>
<tr>
<td align="center">reverse()</td>
<td align="center">把list的元素倒转</td>
</tr>
<tr>
<td align="center">sort()</td>
<td align="center">给list排序</td>
</tr>
<tr>
<td align="center">unique()</td>
<td align="center">删除list中重复的元素</td>
</tr>
<tr>
<td align="center">splice()</td>
<td align="center">合并两个list</td>
</tr>
</tbody></table>
</center>


]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++STL系列：map &amp; multimap</title>
    <url>/2021/09/02/c++STL%E7%B3%BB%E5%88%97%EF%BC%9Amap/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>map&#x2F;multimap 也是以红黑树为底层结构。<br>红黑树的左旋右旋、性质在这里先不深究。</p>
<h3 id="map-x2F-multimap"><a href="#map-x2F-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h3><p>和set不同的是map&#x2F;multimap是以pair的key为排序对象，在G2.9的实现截图如下：<br><img src="/images/map-2.png"></p>
<p>map&#x2F;multimap给定的默认仿函数为less&lt;_Ty&gt;，默认的取值仿函数是select1st&lt;pair&lt;const int, string&gt;&gt;。<br>map也提供<font color=orange>[]</font>的操作符重载：<br><img src="/images/map-1.png"></p>
<p>需要注意的是如果存在要查找的值就返回，否则返回要查找的值应该出现的位置。</p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++STL系列：set &amp; multiset</title>
    <url>/2021/09/02/c++STL%E7%B3%BB%E5%88%97%EF%BC%9Aset/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>set&#x2F;multiset以红黑树为底层结构，因此元素在插入过程中自动排序。<br><img src="/images/rbtree.png"></p>
<p><img src="/images/rbtree-2.png"></p>
<p>STL中的红黑树为了方便实现，创建了一个假的header，并使用指针指向真正的红黑树根节点。<br>红黑树使用三个数据记录树结构：</p>
<ul>
<li>node_count:节点的个数。</li>
<li>header：指向真正的根节点。</li>
<li>key_compare:仿函数，如果节点中存储的是一个类&#x2F;对象，使用仿函数来比较元素大小。</li>
</ul>
<p>红黑树提供遍历操作和iterator。遍历得到的是元素排列的中序遍历，也就是从大到小或者从小到大的顺序。</p>
<h3 id="set-x2F-multiset"><a href="#set-x2F-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h3><p>set的迭代器无法改变元素值（因为需要保持红黑树的性质），实现的技巧是使用const迭代器。</p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++STL系列：stack&amp;&amp;queue</title>
    <url>/2021/09/02/c++STL%E7%B3%BB%E5%88%97%EF%BC%9Astack&amp;&amp;queue/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p><img src="/images/stack-1.png"></p>
<p>通过模板、has-a方式使用deque，按照栈的特点封装deque的方法。</p>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p><img src="/images/queue-1.png"></p>
<p>和stack一样，通过模板、has-a方式使用deque，按照队列的特点封装deque的方法。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><img src="/images/stack-2.png"></p>
<p><img src="/images/stack-3.png"></p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++STL系列：unordered 容器</title>
    <url>/2021/09/02/c++STL%E7%B3%BB%E5%88%97%EF%BC%9Aunordered-set%E3%80%81map/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="底层结构：hashtable"><a href="#底层结构：hashtable" class="headerlink" title="底层结构：hashtable"></a>底层结构：hashtable</h3><p>unordered set&#x2F;map底层是以hashtable为数据结构，任何对象&#x2F;类都可以折射成一个数值（类对象都是由数据构成，对数据进行一些操作然后hash就可以转化成一个数值）.</p>
<p><img src="/images/hashtable-1.png"></p>
<p>在空间充足的情况下如果hashtable足够长，那么冲突可以大大降低，但是现实中常常采用的是hashtable长度为M，N为数据量，只要M&gt;N即可。<br>常见的hashtable解决碰撞的方法：<br>例如，已知哈希表长度m&#x3D;11，哈希函数为：H（key）&#x3D; key % 11，则H（47）&#x3D;3，H（26）&#x3D;4，H（60）&#x3D;5，假设下一个关键字为69，则H（69）&#x3D;3，与47冲突。</p>
<ul>
<li><p>线性探测再散列<br>  dii&#x3D;1，2，3，…，m-1<br>  这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。  </p>
<p>  如果用线性探测再散列处理冲突，下一个哈希地址为H1&#x3D;（3 + 1）% 11 &#x3D; 4，仍然冲突，再找下一个哈希地址为H2&#x3D;（3 + 2）% 11 &#x3D; 5，还是冲突，继续找下一个哈希地址为H3&#x3D;（3 + 3）% 11 &#x3D; 6，此时不再冲突，将69填入5号单元。</p>
</li>
<li><p>二次探测再散列</p>
<p>  di&#x3D;12，-12，22，-22，…，k2，-k2 ( k&lt;&#x3D;m&#x2F;2 )</p>
<p>  这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。  </p>
<p>  如果用二次探测再散列处理冲突，下一个哈希地址为H1&#x3D;（3 + 12）% 11 &#x3D; 4，仍然冲突，再找下一个哈希地址为H2&#x3D;（3 - 12）% 11 &#x3D; 2，此时不再冲突，将69填入2号单元。</p>
</li>
<li><p>伪随机探测再散列</p>
<p>  di&#x3D;伪随机数序列。</p>
<p>  具体实现时，应建立一个伪随机数发生器，（如i&#x3D;(i+p) % m），并给定一个随机数做起点。</p>
<p>  如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1&#x3D;（3 + 2）% 11 &#x3D; 5，仍然冲突，再找下一个哈希地址为H2&#x3D;（3 + 5）% 11 &#x3D; 8，此时不再冲突，将69填入8号单元。</p>
</li>
<li><p>再hash<br>  这种方法是同时构造多个不同的哈希函数：</p>
<p>  Hi&#x3D;RH1（key） i&#x3D;1，2，…，k</p>
<p>  当哈希地址Hi&#x3D;RH1（key）发生冲突时，再计算Hi&#x3D;RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>
</li>
<li><p>链地址法<br>  这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>
</li>
<li><p>建立公共溢出区<br>  这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>
</li>
</ul>
<p>STL的hashtable使用链表法，<font color=orange>hashtable的容量大小预先定义好，是一串素数串。当数据量超过hashtable容量之后，会进行rehashing操作，将所有数据再次进行hash操作，放入新的hashtable。</font></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>hashtable的迭代器也是利用指针，来模拟顺序的遍历操作。<br><img src="/images/hashtable-2.png"></p>
<p>迭代器中存储的是当前node的指针和当前hash bucket的编号。</p>
<h3 id="hash操作"><a href="#hash操作" class="headerlink" title="hash操作"></a>hash操作</h3><p>STL中使用模板的特化和泛化来hash。STL对内置类型进行了特化，如果需要对自定义类型进行hash，需要写对应的模板函数特化版本。<br><img src="/images/hash-3.png"></p>
<p><img src="/images/hash-4.png"></p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++STL系列：vector</title>
    <url>/2021/09/02/c++STL%E7%B3%BB%E5%88%97%EF%BC%9Avector/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="G2-9版本"><a href="#G2-9版本" class="headerlink" title="G2.9版本"></a>G2.9版本</h3><p><img src="/images/vec-1.png"></p>
<p>上图展示了vector的底层结构和G2.9版本的源码。<br>vector实际上是一个数组，在vector中有一些变量记录了数组的信息，start记录了起始位置，finish记录数据结束位置。<br><font color=orange>当vector用完capacity的空间，vector会两倍增长,增长的方式是寻找一个两倍大小的空间，然后将所有元素拷贝过去。</font><br>对中间和开始处进行添加删除元素操作需要移动内存,如果你的元素是结构或是类,那么移动的同时还会进行拷贝构造和析构操作，所以性能不高 （最好将结构或类的指针放入vector中，而不是结构或类本身，这样可以避免移动时的构造与析构)。</p>
<h3 id="G4-9版本"><a href="#G4-9版本" class="headerlink" title="G4.9版本"></a>G4.9版本</h3><p><img src="/images/vec-2.png"></p>
<p>和list一样，G4.9定义和实现分离，遵循面向对象的设计方式。其他并无特别之处。</p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++STL系列：常见问题</title>
    <url>/2021/09/02/c++STL%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="为什么set-x2F-map底层用红黑树而不用AVL树？"><a href="#为什么set-x2F-map底层用红黑树而不用AVL树？" class="headerlink" title="为什么set&#x2F;map底层用红黑树而不用AVL树？"></a>为什么set&#x2F;map底层用红黑树而不用AVL树？</h3><p>红黑树与AVL比较：</p>
<ol>
<li><p>AVL是严格平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率降低；红黑树是弱平衡的，算是一种折中，插入最多旋转2次，删除最多旋转3次。</p>
</li>
<li><p>红黑树在查找、插入删除的复杂度都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层都是使用的红黑树。</p>
</li>
</ol>
<h3 id="STL的sort内部使用什么排序算法？"><a href="#STL的sort内部使用什么排序算法？" class="headerlink" title="STL的sort内部使用什么排序算法？"></a>STL的sort内部使用什么排序算法？</h3><p>直接上源码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line"><span class="function">_CONSTEXPR20 <span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">const</span> _RanIt _First, <span class="type">const</span> _RanIt _Last, _Pr _Pred)</span> </span>&#123; <span class="comment">// order [_First, _Last), using _Pred</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _UFirst = _Get_unwrapped(_First);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _ULast  = _Get_unwrapped(_Last);</span><br><span class="line">    _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个入口函数，先检查迭代器的区间是不是合法的，然后进入主要的排序函数,下面看排序函数是怎么工作的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line">_CONSTEXPR20 <span class="type">void</span> _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t&lt;_RanIt&gt; _Ideal, _Pr _Pred) &#123;</span><br><span class="line">    <span class="comment">// order [_First, _Last), using _Pred</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Last - _First &lt;= _ISORT_MAX) &#123; <span class="comment">// small</span></span><br><span class="line">            _Insertion_sort_unchecked(_First, _Last, _Pred);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_Ideal &lt;= <span class="number">0</span>) &#123; <span class="comment">// heap sort if too many divisions</span></span><br><span class="line">            _Make_heap_unchecked(_First, _Last, _Pred);</span><br><span class="line">            _Sort_heap_unchecked(_First, _Last, _Pred);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// divide and conquer by quicksort</span></span><br><span class="line">        <span class="keyword">auto</span> _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);</span><br><span class="line"></span><br><span class="line">        _Ideal = (_Ideal &gt;&gt; <span class="number">1</span>) + (_Ideal &gt;&gt; <span class="number">2</span>); <span class="comment">// allow 1.5 log2(N) divisions</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_Mid.first - _First &lt; _Last - _Mid.second) &#123; <span class="comment">// loop on second half</span></span><br><span class="line">            _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);</span><br><span class="line">            _First = _Mid.second;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// loop on first half</span></span><br><span class="line">            _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);</span><br><span class="line">            _Last = _Mid.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个递归函数，注释可以说是非常清晰了。</p>
<ol>
<li>首先检查要排序的长度，如果长度小于_ISORT_MAX &#x3D; 32，那么直接进行插入排序。主要的想法是<br>在32这么一个量级上序列基本上已经有序，使用插入排序效率已经相对较高。</li>
<li>然后检查递归深度，没进行一次递归，就对_Ideal进行 _Ideal &#x3D; (_Ideal &gt;&gt; 1) + (_Ideal &gt;&gt; 2)操作，<br>主要的作用是防止快排递归深度过深导致爆栈。</li>
<li>如果深度可以接受，进行快排。</li>
</ol>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++内存管理系列：G2.9内存管理</title>
    <url>/2021/09/02/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%9AG2.9%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="VC6-x2F-BC5-x2F-G2-9-std-allocator"><a href="#VC6-x2F-BC5-x2F-G2-9-std-allocator" class="headerlink" title="VC6&#x2F;BC5&#x2F;G2.9(std::allocator)"></a>VC6&#x2F;BC5&#x2F;G2.9(std::allocator)</h3><p><img src="/images/vc6.png"><br><img src="/images/bc5.png"></p>
<p><img src="/images/g2.9.png"></p>
<p>上面这三个分配器都是基于::operator new和::operator delete实现的，并没有特殊优化.</p>
<h3 id="G2-9-pool-alloc"><a href="#G2-9-pool-alloc" class="headerlink" title="G2.9 __pool_alloc"></a>G2.9 __pool_alloc</h3><p>G2.9版本实现了一个内存池，用来减小malloc开销和cookie。先说一下cookie：</p>
<p><img src="/images/cookie.png"></p>
<p>当我们每次向系统申请一块内存（堆）时，系统会在我们申请的内存两头放两个cookie，32位机器是4字节，64位机器是8个字节。<br>cookie的主要用途是：</p>
<ul>
<li>标记申请内存块的大小，如果能想起来我们在delete的时候并没有给定指针的大小，那么系统是怎么知道那块内存有多大呢？通过指针前移4&#x2F;8个字节，读取内存里的结果就可以。</li>
<li>标记此块内存是否被占用，上图中00000041的1就是用来标记此后的0x40内存是被占用的，如果想在此继续申请就会被拒绝。</li>
</ul>
<p>其实malloc本身是一个内存池，我们申请是很快的，主要就是要避免cookie开销，试想一下，如果我们的对象中只有一个指针，那么cookie就占据了66%的空间，这是我们所不能容忍的。</p>
<p>下面通过侯捷大佬的课件回忆一下内存池的整个分配过程。<br><img src="/images/g4.9-1.png"><br>上图是总览，这个freelist总共有16个区块，每个区块负责不同大小的内存分配。区块之间的递增大小为8。<br><img src="/images/g4.9-1-1.png"><br>这里的freelist使用了嵌入式指针技术（embedding pointer）当区块没有被分配出去之前，结构体内存放的是指向下一区块的指针，分配时将指针值赋给下一个区块的指针，然后将对象信息直接覆盖掉指针。<br><img src="/images/g4.9-1-2.png"><br>这是对应代码中的定义。<br>下面来看一下具体的分配过程。在图中解释的十分清楚.<br><img src="/images/g4.9-2.png"><br><img src="/images/g4.9-3.png"><br><img src="/images/g4.9-4.png"><br><img src="/images/g4.9-5.png"><br><img src="/images/g4.9-6.png"><br><img src="/images/g4.9-7.png"><br><img src="/images/g4.9-8.png"><br><img src="/images/g4.9-9.png"><br><img src="/images/g4.9-10.png"><br><img src="/images/g4.9-11.png"><br><img src="/images/g4.9-12.png"><br><img src="/images/g4.9-13.png"><br><img src="/images/g4.9-14.png"></p>
<p>G2.9的内存管理通过自由链表构造一个内存池来控制，这样做会大量减少cookie的产生，但是也存在问题，比如最后一页，其实在我们的内存中还有大量剩余内存，但是对一个大区块，我们却无法合并区块来提供给用户，并且随着申请数量的加大，我们的累积量会越来愈大，严重情况下会影响其他进程合理的内存要求。<br>关于追加量为什么是累计量的4倍，一个可能的解释是编写此内存分配的程序员认为或者根据经验，内存申请会越来越多，我们提前准备好足够多的内存能避免这种情况。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>c++内存管理系列：bitmap-allocator</title>
    <url>/2021/09/02/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%9Abitmap-allocator/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bitmap_allocator</span>: <span class="keyword">private</span> free_list&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">pointer </span></span><br><span class="line"><span class="function">    <span class="title">allocate</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (__n &gt; <span class="keyword">this</span>-&gt;<span class="built_in">max_size</span>())</span><br><span class="line">            std::__throw_bad_alloc();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(__n == <span class="number">1</span>, <span class="literal">true</span>))<span class="comment">//如果数量为1个,则调用_M_allocate_single_object()</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_M_allocate_single_object();</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//如果申请的数量大于1个,则直接调用operator new</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="type">const</span> size_type __b = __n * <span class="built_in">sizeof</span>(value_type);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;pointer&gt;(::<span class="keyword">operator</span> <span class="built_in">new</span>(__b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图解形式：</p>
<p><img src="/images/bitmap-1.png"></p>
<p>首先是64个blocks，每一个对象占用1个block，64个blocks加上bitmap[1]和bitmap[0]再加上use count形成一个super block。即super block &#x3D; 64<em>block + bitmap[1] + bitmap[0];<br>use count表示64个block已经用了几个，如果某一个block被使用了，那么bitmap[1]和bitmap[0]相应bit的数字变为0，bitmap[1]和bitmap[0]均为unsigned int，所以两个加起来共有64比特，也就可以表示64个block的使用情况。<br>在最前面还有一个数字，表示super block的大小，上图中的大小为：4(use count)+4 * 2(bitmap)+64</em>8(单个对象大小)&#x3D;524字节。单个对象的大小只能是8的倍数。</p>
<p>多个super block是通过__mini_vector管理的，__mini_vector是一个vector，但不是标准库的vector，而是自己写的一个vector，但它与标准库中的vector拥有同样的特性——两倍增长。也就是说，如果64个block用光了，下次会分配128个block。<br>__mini_vector有3个用来管理内存的成员变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">pointer _M_start;</span><br><span class="line">pointer _M_finish;</span><br><span class="line">pointer _M_end_of_storage;</span><br></pre></td></tr></table></figure>
<p>当64个block用光时，会再申请128个，然后bitmap变为4个。和vector的成长一样，会申请另一块内存然后将现在的搬过去：</p>
<p><img src="/images/bitmap-2.png"><br><img src="/images/bitmap-3.png"><br>每次都这样成长两倍，2的幂次方级别地成长。</p>
<h3 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate"></a>deallocate</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bitmap_allocator</span>: <span class="keyword">private</span> free_list&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function">    <span class="title">deallocate</span><span class="params">(pointer __p, size_type __n)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(__p != <span class="number">0</span>, <span class="literal">true</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(__n == <span class="number">1</span>, <span class="literal">true</span>))<span class="comment">//如果数量为1,则调用_M_deallocate_single_object()释放</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;_M_deallocate_single_object(__p);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ::<span class="keyword">operator</span> <span class="built_in">delete</span>(__p);<span class="comment">//数量大于1使用operator delete释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/bitmap-4.png"><br><img src="/images/bitmap-6.png"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>c++内存管理系列：VC6-malloc</title>
    <url>/2021/09/02/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%9AVC6-malloc/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="VC6-malloc"><a href="#VC6-malloc" class="headerlink" title="VC6 malloc"></a>VC6 malloc</h3><ul>
<li>想要搞清malloc是怎么运作的，就必须直到malloc首次分配内存进行了哪些操作，进行了哪些初始化。</li>
<li>很多人认为我们执行一个cpp文件是从main函数开始，但是实际上系统还会为我们进行一系列的环境准备，这些动作通常包含了环境变量的获取、堆的初始化等等一系列操作，在不同环境下可能略有不同。在cpp文件执行之后也存在很多善后操作，这个会在c++前世今生详细介绍。</li>
<li>下面来看一下vc环境下会有哪些动作.</li>
</ul>
<p><img src="/images/vcinit.png"></p>
<ul>
<li>这是c++执行程序的函数栈信息，main函数竟然只排在第8步。我们需要重点关注的函数是_heap_alloc_dbg()，这是真正要分配内存的函数，在这之前，我们先来看看需要分配的内存内容和大小是什么吧。</li>
</ul>
<p><img src="/images/vc6-sbh.png"></p>
<p>上述这个结构体用来做内存分配中表头的信息，包含了一个32bit的高位，32bits的低位，32bits的commit信息，一个指针和一个tagRegion结构体指针。<br><img src="/images/vc6-all.png"><br>ioinit函数调用malloc_crt函数，这个函数是一个宏定义，在debug模式最终调用_malloc_dbg函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_malloc_dbg(s,_CRT_BLOCK,_THISFILE,__LINE__);</span><br></pre></td></tr></table></figure>
<p><img src="/images/vc6-mbh.png"></p>
<p>上图展示了首次分配内存的大小和初始化情况。在第一次内存分配中，我们首先将nSize作为函数参数传入（256 bytes），_CrtMemBlockHeader是debug模式下要附加到数据上的内容。总的来看数据前面加上了调试信息，对应_CrtMemBlockHeader的每一个字段，数据后面添加了nNoManLandSize &#x3D; 4B，然后经过对齐之后，我们需要blocksize大小的内存。最后调用heap_alloc_base这个函数申请内存。</p>
<p><img src="/images/vc6-mbh-2.png"></p>
<p>在_heap_alloc_dbg()这个函数中，申请完了内存，我们就对它进行初始化，最后返回数据。注意到这是一个双向链表，有指向下一个区块和前一个区块的指针。在debug模式下，数据块两端附着了很多信息，用于变量的跟踪和调试。数据块两端填充的值在图中可以看出，是规定好的值。</p>
<p><img src="/images/vc6-1.png"><br>获得内存大小之后，判断需要的内存大小是否比阈值小，如果是，就使用sbh处理，否则向操作系统申请Heap内存。为什么阈值是3F8(1016字节)?因为1016+上下两个cookie之后是1024。</p>
<p><img src="/images/vc6-3.png"><br>在_heap_alloc_base内接下来进行内存对齐。</p>
<p><img src="/images/vc6-4.png"><br>上面展示了管理1MB内存的数据结构。还记得开始的时候Head的设计吗，它有两个指针，其中一个就是tagRegion指针，这个结构体的内容如右图所示，首先是一个整数，接下来是一个64位char数组，接下来是32个32bits的高位数组和低位数组共32组64bits，用来管理这块内存中某个区块有或没有。最后是32个<br>tagGroup结构体。<br>group结构体里面首先是一个整数，接下来有64个listhead，而listhead里面存放双向指针。<br><img src="/images/vc6-5.png"></p>
<p>然后我们尝试从整体把握。我们要用一个group管理1MB的空间，然后需要new出来这么多结构管理，这些结构本身占16K左右空间。我们的想法是用这32个group来管理1MB的32个片段(32K)。32K对应8页。SBH将这8个page使用双向链表串联起来，然后挂在最后一个listhead上。<br>我们并不是在一开始就申请1MB的空间，而是申请32K，如果用完了再申请，因此开始时我们拥有的是虚地址。</p>
<p><img src="/images/vc6-6.png"><br>接下来详细看这个结构，在每个page都有一段保留空间（字节对齐），保留空间下面和最下面都有一段0xffffffff（-1）用来做空间合并，即page内合并不影响page之间的合并。4080记录空间空间的大小。<br><img src="/images/vc6-7.png"></p>
<p>下面我们来整理一下之前的所有动作。如上图所示：</p>
<ul>
<li>首先在crt的ioinit.c函数的81行申请了100h大小的内存，经过debug header，内存对齐之后大小为130h。</li>
<li>初始化64个header，每个header用来管理1MB的内存，此时调用的是VirtualAlloc函数，注意MEM_RESERVE表示保留这些内存（现在是虚地址）。</li>
<li>然后初始化region，每个region有32个group，每个group有64个双向指针，这些指针用来管理不同大小的block。</li>
<li>然后真正向操作系统申请32k的内存，注意此时的参数是MEM_COMMIT，然后将此块内存分为8个page，使用双向链表连接在一起，挂在group 0 的最后一个双向指针上（group的64个指针管理不同大小区块，从8B到1024B，如果大于1024B就挂在最后一个链表上，由于8K&gt;1K,因此挂在最后）。</li>
<li>更改region的32 x 64bits数组的第0号链表的最后一位为1，表示已经有内存块挂载。</li>
<li>然后在page1切割内存，4080-130, 改变cookie大小（ec0），下面表示切割的内存，cookie为131,1表示被占用，130表示大小。</li>
</ul>
<p>回头我们来看一下region的32 x 64bits数组有什么用，哈哈，现在理解了，用来表示32个group的64个链表是否被占用，可以用来快速查询。<br>那group的int有什么用呢？用来记录分配的次数，如果分配一次就加一，回收一次就减一，便于记录是否回收完备。</p>
<p>当我们第二次分配的时候，先在region里面查找最近的大于目标大小的group的list，然后在上面切割即可。</p>
<h3 id="VC6-free"><a href="#VC6-free" class="headerlink" title="VC6 free"></a>VC6 free</h3><p>归还的时候会发生什么呢？请看下图。</p>
<p><img src="/images/vc6-8.png"></p>
<p>假如我们在第15次需要归还240h大小的内存。我们需要做的是：</p>
<ul>
<li>更改group 的count值：14-&gt;13.</li>
<li>先计算240h&#x2F;16 &#x3D; 36，我们应该将这块内存归还到第36（index &#x3D; 35）链表中。</li>
<li>然后利用嵌入式指针技术，将35号链表的指针和这块内存的指针构成一个链表。</li>
</ul>
<p>那么当有相邻的内存被释放，应该怎么合并呢，请看：<br><img src="/images/vc6-9.png"></p>
<p>这里就凸显了上下cookie的作用，在free 300这块空间，首先往下看（指针+*指针+4）看下方是否为空，再往上看（指针 - 4）是否为空，如果为空，合并成一个大区间。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>c++内存管理系列：jemalloc</title>
    <url>/2021/08/29/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%9Ajemalloc/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>jemalloc 是由 Jason Evans 在 FreeBSD 项目中引入的新一代内存分配器。它是一个通用的 malloc 实现，侧重于减少内存碎片和提升高并发场景下内存的分配效率，其目标是能够替代 malloc。jemalloc 应用十分广泛，在 Firefox、Redis、Rust、Netty 等出名的产品或者编程语言中都有大量使用。具体细节可以参考 Jason Evans 发表的论文 《A Scalable Concurrent malloc Implementation for FreeBSD》。</p>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>了解了vc6内存管理、ptmalloc、tcmalloc之后，jemalloc理解起来就轻松了不上，因为jemalloc有些地方借鉴了tcmalloc，先pull出整体架构图：<br><img src="/images/jemalloc-1.png"></p>
<p>图中涉及 jemalloc 的几个核心概念，例如 arena、bin、chunk、run、region、tcache 等，我们下面逐一进行介绍。</p>
<ul>
<li><font color=red>arena</font> 是 jemalloc 最重要的部分，内存由一定数量的 arenas 负责管理。每个用户线程都会被绑定到一个 arena 上，线程采用 round-robin 轮询的方式选择可用的 arena 进行内存分配，为了减少线程之间的锁竞争，默认每个 CPU 会分配 4 个 arena。</li>
<li><font color=red>bin</font> 用于管理不同档位的内存单元，每个 bin 管理的内存大小是按分类依次递增。因为 jemalloc 中小内存的分配是基于 Slab 算法完成的，所以会产生不同类别的内存块。</li>
<li><font color=red>chunk</font> 是负责管理用户内存块的数据结构，chunk 以 Page 为单位管理内存，默认大小是 4M，即 1024 个连续 Page。每个 chunk 可被用于多次小内存的申请，但是在大内存分配的场景下只能分配一次。</li>
<li><font color=red>run</font> 实际上是 chunk 中的一块内存区域，每个 bin 管理相同类型的 run，最终通过操作 run 完成内存分配。run 结构具体的大小由不同的 bin 决定，例如 8 字节的 bin 对应的 run 只有一个 Page，可以从中选取 8 字节的块进行分配。</li>
<li><font color=red>region</font> 是每个 run 中的对应的若干个小内存块，每个 run 会将划分为若干个等长的 region，每次内存分配也是按照 region 进行分发。</li>
<li><font color=red>tcache</font> 是每个线程私有的缓存，用于 small 和 large 场景下的内存分配，每个 tcahe 会对应一个 arena，tcache 本身也会有一个 bin 数组，称为tbin。与 arena 中 bin 不同的是，它不会有 run 的概念。tcache 每次从 arena 申请一批内存，在分配内存时首先在 tcache 查找，从而避免锁竞争，如果分配失败才会通过 run 执行内存分配。</li>
</ul>
<p>jemalloc 的几个核心的概念介绍完了，我们再重新梳理下它们之间的关系：</p>
<ul>
<li>内存是由一定数量的 arenas 负责管理，线程均匀分布在 arenas 当中；</li>
<li>每个 arena 都包含一个 bin 数组，每个 bin 管理不同档位的内存块；</li>
<li>每个 arena 被划分为若干个 chunks，每个 chunk 又包含若干个 runs，每个 run 由连续的 Page 组成，run 才是实际分配内存的操作对象；</li>
<li>每个 run 会被划分为一定数量的 regions，在小内存的分配场景，region 相当于用户内存；</li>
<li>每个 tcache 对应 一个 arena，tcache 中包含多种类型的 bin。</li>
</ul>
<p>首先讲下 Samll 场景，如果请求分配内存的大小小于 arena 中的最小的 bin，那么优先从线程中对应的 tcache 中进行分配。首先确定查找对应的 tbin 中是否存在缓存的内存块，如果存在则分配成功，否则找到 tbin 对应的 arena，从 arena 中对应的 bin 中分配 region 保存在 tbin 的 avail 数组中，最终从 availl 数组中选取一个地址进行内存分配，当内存释放时也会将被回收的内存块进行缓存。</p>
<p>Large 场景的内存分配与 Samll 类似，如果请求分配内存的大小大于 arena 中的最小的 bin，但是不大于 tcache 中能够缓存的最大块，依然会通过 tcache 进行分配，但是不同的是此时会分配 chunk 以及所对应的 run，从 chunk 中找到相应的内存空间进行分配。内存释放时也跟 samll 场景类似，会把释放的内存块缓存在 tacache 的 tbin 中。此外还有一种情况，当请求分配内存的大小大于tcache 中能够缓存的最大块，但是不大于 chunk 的大小，那么将不会采用 tcache 机制，直接在 chunk 中进行内存分配。</p>
<p>Huge 场景，如果请求分配内存的大小大于 chunk 的大小，那么直接通过 mmap 进行分配，调用 munmap 进行回收。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>c++内存管理系列：new/operator new/placement new</title>
    <url>/2021/08/29/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%9Anew&amp;&amp;delete/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="内存分配的层面"><a href="#内存分配的层面" class="headerlink" title="内存分配的层面"></a>内存分配的层面</h3><ul>
<li><p>c++ 内存分配相相关函数如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">分配</th>
<th align="center">释放</th>
<th align="center">类属</th>
<th align="center">可否重载</th>
</tr>
</thead>
<tbody><tr>
<td align="center">malloc()</td>
<td align="center">free()</td>
<td align="center">C函数</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">new</td>
<td align="center">delete</td>
<td align="center">C++表达式</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">::operator new()</td>
<td align="center">::operator delete()</td>
<td align="center">C++函数</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">allocator<T>::allocate()</td>
<td align="center">allocator<T>::deallocate()</td>
<td align="center">C++标准库</td>
<td align="center">可自由设计并搭配任何容器</td>
</tr>
</tbody></table>
</li>
</ul>
<p><img src="/images/008.png"></p>
<center>内存分配层次</center>

<ul>
<li><p>那么我们应该如何使用这几个呢？下面给一段测试程序：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">complex&lt;<span class="type">int</span>&gt;* p2 = <span class="keyword">new</span> complex&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">512</span>);</span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GNU下的allocator</span></span><br><span class="line">allocator&lt;<span class="type">int</span>&gt; alloc;</span><br><span class="line"><span class="type">int</span>* p4 = alloc.<span class="built_in">allocate</span>(<span class="number">512</span>);</span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p4, <span class="number">512</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="operator-new-x2F-operator-delete"><a href="#operator-new-x2F-operator-delete" class="headerlink" title="operator new&#x2F;operator delete"></a>operator new&#x2F;operator delete</h3><ul>
<li>new背后做的事<br>对于下面这行代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">complex* p = <span class="keyword">new</span> <span class="built_in">complex</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>编译器会帮我们转化成下面三个动作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">complex* p;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="type">void</span>* mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(complex)); <span class="comment">//申请内存</span></span><br><span class="line">    p = <span class="built_in">static_cast</span>&lt;complex*&gt;(mem); <span class="comment">// 类型转换</span></span><br><span class="line">    p -&gt; complex::<span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(std::bad_alloc)&#123;</span><br><span class="line">    <span class="comment">//若构造函数失败，回收资源</span></span><br><span class="line">    <span class="comment">//若内存不够，重复获取直到有足够资源或者直接抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而operator new的声明为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span> <span class="params">(std::bad_alloc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>源码是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//__cdecl 是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。 被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *__CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> <span class="title">throw</span> <span class="params">(std::bad_alloc)</span> </span>&#123;       </span><br><span class="line">	<span class="comment">// try to allocate size bytes</span></span><br><span class="line">	<span class="type">void</span> *p;</span><br><span class="line">	<span class="keyword">while</span> ((p = <span class="built_in">malloc</span>(size)) == <span class="number">0</span>)      <span class="comment">//申请空间</span></span><br><span class="line">		<span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>) &#123;      <span class="comment">//若申请失败则调用处理函数       </span></span><br><span class="line">			<span class="comment">// report no memory</span></span><br><span class="line">			<span class="type">static</span> <span class="type">const</span> std::bad_alloc nomem;</span><br><span class="line">            _RAISE(nomem);               <span class="comment">//#define _RAISE(x) ::std:: _Throw(x) 抛出nomem的异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在effective c++也提到过，第一步如果用户自定义全局operator new，那么此函数可以接管默认operator new，但是用户尽量仿照默认版本的套路，要么不断请求新的空间，要么抛出异常，要么结束程序。</p>
<p>对应的内存释放程序则十分简单了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *memoryToBeDeallocated)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意以下几点：<br> （1）对于不是类类型（class、struct 或 union）的对象，将调用全局 delete 运算符。<br> （2）于类类型的对象，如果重载operator delete()，则在释放对象时默认调用重载版本，可以使用作用域运算符(::)置于delete之前，显示调用全局operator delete().<br> （3）delete运算符在释放对象之前会调用对象析构函数。</p>
<p> 验证汇编代码<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x):<span class="built_in">x</span>(x)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::ctor&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::dtor&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    A* p = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">delete</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 反汇编后：<br> <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> (gdb) disas main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   <span class="number">0x0000000000401550</span> &lt;+<span class="number">0</span>&gt;:     <span class="keyword">push</span>   <span class="built_in">rbp</span></span><br><span class="line">   <span class="number">0x0000000000401551</span> &lt;+<span class="number">1</span>&gt;:     <span class="keyword">push</span>   <span class="built_in">rsi</span></span><br><span class="line">   <span class="number">0x0000000000401552</span> &lt;+<span class="number">2</span>&gt;:     <span class="keyword">push</span>   <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401553</span> &lt;+<span class="number">3</span>&gt;:     <span class="keyword">mov</span>    <span class="built_in">rbp</span>,<span class="built_in">rsp</span></span><br><span class="line">   <span class="number">0x0000000000401556</span> &lt;+<span class="number">6</span>&gt;:     <span class="keyword">sub</span>    <span class="built_in">rsp</span>,<span class="number">0x30</span></span><br><span class="line">   <span class="number">0x000000000040155a</span> &lt;+<span class="number">10</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x401720</span> &lt;__main&gt;</span><br><span class="line">   <span class="number">0x000000000040155f</span> &lt;+<span class="number">15</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="number">0x4</span> <span class="comment">; new start</span></span><br><span class="line">   <span class="number">0x0000000000401564</span> &lt;+<span class="number">20</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x401648</span> &lt;_Znwy&gt;</span><br><span class="line">   <span class="number">0x0000000000401569</span> &lt;+<span class="number">25</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rbx</span>,<span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x000000000040156c</span> &lt;+<span class="number">28</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0xa</span></span><br><span class="line">   <span class="number">0x0000000000401571</span> &lt;+<span class="number">33</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401574</span> &lt;+<span class="number">36</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x402d20</span> &lt;A::A(<span class="keyword">int</span>)&gt;<span class="comment">;构造函数</span></span><br><span class="line">   <span class="number">0x0000000000401579</span> &lt;+<span class="number">41</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x8</span>],<span class="built_in">rbx</span> </span><br><span class="line">   <span class="number">0x000000000040157d</span> &lt;+<span class="number">45</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rbx</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x8</span>] <span class="comment">;new end</span></span><br><span class="line">   <span class="number">0x0000000000401581</span> &lt;+<span class="number">49</span>&gt;:    <span class="keyword">test</span>   <span class="built_in">rbx</span>,<span class="built_in">rbx</span> <span class="comment">; delete start</span></span><br><span class="line">   <span class="number">0x0000000000401584</span> &lt;+<span class="number">52</span>&gt;:    <span class="keyword">je</span>     <span class="number">0x40159b</span> &lt;main()+<span class="number">75</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401586</span> &lt;+<span class="number">54</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401589</span> &lt;+<span class="number">57</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x402d60</span> &lt;A::~A()&gt; <span class="comment">; 析构函数</span></span><br><span class="line">   <span class="number">0x000000000040158e</span> &lt;+<span class="number">62</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0x4</span></span><br><span class="line">   <span class="number">0x0000000000401593</span> &lt;+<span class="number">67</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401596</span> &lt;+<span class="number">70</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x401650</span> &lt;_ZdlPvy&gt;</span><br><span class="line">=&gt; <span class="number">0x000000000040159b</span> &lt;+<span class="number">75</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x0</span> <span class="comment">;delete end</span></span><br><span class="line">   <span class="number">0x00000000004015a0</span> &lt;+<span class="number">80</span>&gt;:    <span class="keyword">jmp</span>    <span class="number">0x4015bd</span> &lt;main()+<span class="number">109</span>&gt;</span><br><span class="line">   <span class="number">0x00000000004015a2</span> &lt;+<span class="number">82</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rsi</span>,<span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x00000000004015a5</span> &lt;+<span class="number">85</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0x4</span></span><br><span class="line">   <span class="number">0x00000000004015aa</span> &lt;+<span class="number">90</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x00000000004015ad</span> &lt;+<span class="number">93</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x401650</span> &lt;_ZdlPvy&gt;</span><br><span class="line">   <span class="number">0x00000000004015b2</span> &lt;+<span class="number">98</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">rsi</span></span><br><span class="line">   <span class="number">0x00000000004015b5</span> &lt;+<span class="number">101</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x00000000004015b8</span> &lt;+<span class="number">104</span>&gt;:   <span class="keyword">call</span>   <span class="number">0x402af0</span> &lt;_Unwind_Resume&gt;</span><br><span class="line">   <span class="number">0x00000000004015bd</span> &lt;+<span class="number">109</span>&gt;:   <span class="keyword">add</span>    <span class="built_in">rsp</span>,<span class="number">0x30</span></span><br><span class="line">   <span class="number">0x00000000004015c1</span> &lt;+<span class="number">113</span>&gt;:   <span class="keyword">pop</span>    <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x00000000004015c2</span> &lt;+<span class="number">114</span>&gt;:   <span class="keyword">pop</span>    <span class="built_in">rsi</span></span><br><span class="line">   <span class="number">0x00000000004015c3</span> &lt;+<span class="number">115</span>&gt;:   <span class="keyword">pop</span>    <span class="built_in">rbp</span></span><br><span class="line">   <span class="number">0x00000000004015c4</span> &lt;+<span class="number">116</span>&gt;:   <span class="keyword">ret</span>    </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) info line <span class="number">18</span></span><br><span class="line">Line <span class="number">18</span> of <span class="string">&quot;main.cpp&quot;</span> starts <span class="meta">at</span> address <span class="number">0x40155f</span> &lt;main()+<span class="number">15</span>&gt;</span><br><span class="line">   <span class="keyword">and</span> ends <span class="meta">at</span> <span class="number">0x40157d</span> &lt;main()+<span class="number">45</span>&gt;.</span><br><span class="line">Line <span class="number">19</span> of <span class="string">&quot;main.cpp&quot;</span> starts <span class="meta">at</span> address <span class="number">0x40157d</span> &lt;main()+<span class="number">45</span>&gt;</span><br><span class="line"><span class="keyword">and</span> ends <span class="meta">at</span> <span class="number">0x40159b</span> &lt;main()+<span class="number">75</span>&gt;.</span><br></pre></td></tr></table></figure><br>从汇编代码可以看出new首先申请一块内存然后调用构造函数，而delete先调用析构函数然后在释放内存。</p>
<h3 id="array-new-x2F-delete"><a href="#array-new-x2F-delete" class="headerlink" title="array new&#x2F;delete[]"></a>array new&#x2F;delete[]</h3><p>测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x):<span class="built_in">x</span>(x)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::ctor&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::dtor&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    A* p = <span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        p[i].<span class="built_in">setX</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; p[i].<span class="built_in">getX</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看内存布局</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) p p</span><br><span class="line">$<span class="number">2</span> = (A *) <span class="number">0x6e1e68</span></span><br><span class="line">(gdb) x/<span class="number">128</span>xb <span class="number">0x6e1e38</span></span><br><span class="line"><span class="number">0x6e1e38</span>:       <span class="number">0xab</span>    <span class="number">0xab</span>    <span class="number">0xab</span>    <span class="number">0xab</span>    <span class="number">0xab</span>    <span class="number">0xab</span>    <span class="number">0xab</span>    <span class="number">0xab</span></span><br><span class="line"><span class="number">0x6e1e40</span>:       <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x6e1e48</span>:       <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x6e1e50</span>:       <span class="number">0xee</span>    <span class="number">0xfe</span>    <span class="number">0xee</span>    <span class="number">0xfe</span>    <span class="number">0xee</span>    <span class="number">0xfe</span>    <span class="number">0xee</span>    <span class="number">0xfe</span>  </span><br><span class="line"><span class="number">0x6e1e58</span>:       <span class="number">0x97</span>    <span class="number">0x1a</span>    <span class="number">0x9c</span>    <span class="number">0x1e</span>    <span class="number">0xaf</span>    <span class="number">0x57</span>    <span class="number">0x00</span>    <span class="number">0x3f</span></span><br><span class="line"><span class="number">0x6e1e60</span>:       <span class="number">0x0a</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">//数组长度10</span></span><br><span class="line"><span class="number">0x6e1e68</span>:       <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x01</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">//p[0],p[1]</span></span><br><span class="line"><span class="number">0x6e1e70</span>:       <span class="number">0x02</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x03</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x6e1e78</span>:       <span class="number">0x04</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x05</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x6e1e80</span>:       <span class="number">0x06</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x07</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x6e1e88</span>:       <span class="number">0x08</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x09</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">//p[8],p[9]</span></span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure>
<p>查看delete[]的汇编代码</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">x0000000000401637 &lt;+<span class="number">231</span>&gt;:   <span class="keyword">je</span>     <span class="number">0x40168f</span> &lt;main()+<span class="number">319</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401639</span> &lt;+<span class="number">233</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x10</span>]<span class="comment">;将数组首地址移入寄存器</span></span><br><span class="line">   <span class="number">0x000000000040163d</span> &lt;+<span class="number">237</span>&gt;:   <span class="keyword">sub</span>    <span class="built_in">rax</span>,<span class="number">0x8</span><span class="comment">;向前8个字节</span></span><br><span class="line">   <span class="number">0x0000000000401641</span> &lt;+<span class="number">241</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>]<span class="comment">;数组长度</span></span><br><span class="line">   <span class="number">0x0000000000401644</span> &lt;+<span class="number">244</span>&gt;:   <span class="keyword">lea</span>    <span class="built_in">rdx</span>,[<span class="built_in">rax</span>*<span class="number">4</span>+<span class="number">0x0</span>]<span class="comment">;终点地址</span></span><br><span class="line">   <span class="number">0x000000000040164c</span> &lt;+<span class="number">252</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0x0000000000401650</span> &lt;+<span class="number">256</span>&gt;:   <span class="keyword">lea</span>    <span class="built_in">rbx</span>,[<span class="built_in">rdx</span>+<span class="built_in">rax</span>*<span class="number">1</span>]</span><br><span class="line">   <span class="number">0x0000000000401654</span> &lt;+<span class="number">260</span>&gt;:   <span class="keyword">cmp</span>    <span class="built_in">rbx</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0x0000000000401658</span> &lt;+<span class="number">264</span>&gt;:   <span class="keyword">je</span>     <span class="number">0x401668</span> &lt;main()+<span class="number">280</span>&gt;</span><br><span class="line">   <span class="number">0x000000000040165a</span> &lt;+<span class="number">266</span>&gt;:   <span class="keyword">sub</span>    <span class="built_in">rbx</span>,<span class="number">0x4</span> <span class="comment">;从最后一个开始析构，因此减sizeof(A) = 4</span></span><br><span class="line">   <span class="number">0x000000000040165e</span> &lt;+<span class="number">270</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401661</span> &lt;+<span class="number">273</span>&gt;:   <span class="keyword">call</span>   <span class="number">0x402ed0</span> &lt;A::~A()&gt;</span><br><span class="line">   <span class="number">0x0000000000401666</span> &lt;+<span class="number">278</span>&gt;:   <span class="keyword">jmp</span>    <span class="number">0x401654</span> &lt;main()+<span class="number">260</span>&gt;<span class="comment">;循环析构</span></span><br><span class="line">   <span class="number">0x0000000000401668</span> &lt;+<span class="number">280</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0x000000000040166c</span> &lt;+<span class="number">284</span>&gt;:   <span class="keyword">sub</span>    <span class="built_in">rax</span>,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x0000000000401670</span> &lt;+<span class="number">288</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>]</span><br><span class="line">   <span class="number">0x0000000000401673</span> &lt;+<span class="number">291</span>&gt;:   <span class="keyword">add</span>    <span class="built_in">rax</span>,<span class="number">0x2</span></span><br><span class="line">   <span class="number">0x0000000000401677</span> &lt;+<span class="number">295</span>&gt;:   <span class="keyword">lea</span>    <span class="built_in">rdx</span>,[<span class="built_in">rax</span>*<span class="number">4</span>+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x000000000040167f</span> &lt;+<span class="number">303</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0x0000000000401683</span> &lt;+<span class="number">307</span>&gt;:   <span class="keyword">sub</span>    <span class="built_in">rax</span>,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x0000000000401687</span> &lt;+<span class="number">311</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x000000000040168a</span> &lt;+<span class="number">314</span>&gt;:   <span class="keyword">call</span>   <span class="number">0x401780</span> &lt;_ZdaPvy&gt;</span><br><span class="line">   <span class="number">0x000000000040168f</span> &lt;+<span class="number">319</span>&gt;:   <span class="keyword">lea</span>    <span class="built_in">rcx</span>,[<span class="built_in">rip</span>+<span class="number">0x298a</span>]        # <span class="number">0x404020</span> &lt;_ZStL6ignore+<span class="number">23</span>&gt;</span><br></pre></td></tr></table></figure>
<p>delete[]获得对象数组的地址后，向前8个字节获得数组长度然后从最后一个对象开始析构，完成后释放整个空间。</p>
<h3 id="operator-new-x2F-operator-delete重载"><a href="#operator-new-x2F-operator-delete重载" class="headerlink" title="operator new&#x2F;operator delete重载"></a>operator new&#x2F;operator delete重载</h3><p>当我们需要在new的时候增加一些特殊的动作，比如输出一些调试信息等，我们需要自己对operator进行重载。例如假如我们重写了下面这个版本，输出一些信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size,string&amp; info)</span><span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; info;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p, string&amp; info)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">delete</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;info&quot;</span>)</span></span>;</span><br><span class="line">A* p = <span class="built_in">new</span> (s) <span class="built_in">A</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">delete</span>(p);</span><br></pre></td></tr></table></figure>
<p>看看汇编层面：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) info line <span class="number">26</span></span><br><span class="line">Line <span class="number">26</span> of <span class="string">&quot;main.cpp&quot;</span> starts at address <span class="number">0x4015fb</span> &lt;<span class="built_in">main</span>()+<span class="number">65</span>&gt; <span class="keyword">and</span> ends at <span class="number">0x40162d</span> &lt;<span class="built_in">main</span>()+<span class="number">115</span>&gt;.</span><br><span class="line"></span><br><span class="line">(gdb) info line <span class="number">27</span></span><br><span class="line">Line <span class="number">27</span> of <span class="string">&quot;main.cpp&quot;</span> starts at address <span class="number">0x40162d</span> &lt;<span class="built_in">main</span>()+<span class="number">115</span>&gt; <span class="keyword">and</span> ends at <span class="number">0x401639</span> &lt;<span class="built_in">main</span>()+<span class="number">127</span>&gt;.</span><br></pre></td></tr></table></figure>

<p>placement new:</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">0x00000000004015fb</span> &lt;+<span class="number">65</span>&gt;:    <span class="keyword">lea</span>    <span class="built_in">rax</span>,[<span class="built_in">rbp</span>-<span class="number">0x30</span>]</span><br><span class="line"><span class="number">0x00000000004015ff</span> &lt;+<span class="number">69</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rdx</span>,<span class="built_in">rax</span></span><br><span class="line"><span class="number">0x0000000000401602</span> &lt;+<span class="number">72</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="number">0x4</span></span><br><span class="line"><span class="number">0x0000000000401607</span> &lt;+<span class="number">77</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x401550</span> &lt;operator new(unsigned long long, <span class="keyword">std</span>::__cxx11::basic_string&lt;char, <span class="keyword">std</span>::char_traits&lt;char&gt;, <span class="keyword">std</span>::allocator&lt;char&gt; &gt;&amp;)&gt;</span><br><span class="line"><span class="number">0x000000000040160c</span> &lt;+<span class="number">82</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rbx</span>,<span class="built_in">rax</span></span><br><span class="line"><span class="number">0x000000000040160f</span> &lt;+<span class="number">85</span>&gt;:    <span class="keyword">test</span>   <span class="built_in">rbx</span>,<span class="built_in">rbx</span></span><br><span class="line"><span class="number">0x0000000000401612</span> &lt;+<span class="number">88</span>&gt;:    <span class="keyword">je</span>     <span class="number">0x401626</span> &lt;main()+<span class="number">108</span>&gt;</span><br><span class="line"><span class="number">0x0000000000401614</span> &lt;+<span class="number">90</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0xa</span></span><br><span class="line"><span class="number">0x0000000000401619</span> &lt;+<span class="number">95</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line"><span class="number">0x000000000040161c</span> &lt;+<span class="number">98</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x402e50</span> &lt;A::A(<span class="keyword">int</span>)&gt;</span><br><span class="line"><span class="number">0x0000000000401621</span> &lt;+<span class="number">103</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">rbx</span></span><br><span class="line"><span class="number">0x0000000000401624</span> &lt;+<span class="number">106</span>&gt;:   <span class="keyword">jmp</span>    <span class="number">0x401629</span> &lt;main()+<span class="number">111</span>&gt;</span><br><span class="line"><span class="number">0x0000000000401626</span> &lt;+<span class="number">108</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">rbx</span></span><br><span class="line"><span class="number">0x0000000000401629</span> &lt;+<span class="number">111</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x38</span>],<span class="built_in">rax</span></span><br><span class="line"><span class="number">0x000000000040162d</span> &lt;+<span class="number">115</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rbx</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x38</span>]</span><br></pre></td></tr></table></figure>
<p>placement delete:</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">   <span class="number">0x0000000000401631</span> &lt;+<span class="number">119</span>&gt;:   <span class="keyword">test</span>   <span class="built_in">rbx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401634</span> &lt;+<span class="number">122</span>&gt;:   <span class="keyword">je</span>     <span class="number">0x40164b</span> &lt;main()+<span class="number">145</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401636</span> &lt;+<span class="number">124</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401639</span> &lt;+<span class="number">127</span>&gt;:   <span class="keyword">call</span>   <span class="number">0x402e90</span> &lt;A::~A()&gt;</span><br><span class="line">   <span class="number">0x000000000040163e</span> &lt;+<span class="number">132</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0x4</span></span><br><span class="line">   <span class="number">0x0000000000401643</span> &lt;+<span class="number">137</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rcx</span>,<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000401646</span> &lt;+<span class="number">140</span>&gt;:   <span class="keyword">call</span>   <span class="number">0x401748</span> &lt;_ZdlPvy&gt;</span><br><span class="line">=&gt; <span class="number">0x000000000040164b</span> &lt;+<span class="number">145</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>系统就会使用我们定义的版本进行内存分配。<br>既然默认new 和 delete工作的很好，问什么需要重载？</p>
<ul>
<li>可以用来检测运用上的错误</li>
<li>可以提高效率，节省不必要的内存，提高回收和分配的速度（比如针对某一对象的内存池）</li>
<li>可以收集对内存使用的数据统计</li>
<li>operator delete主要为了处理异常，一般情况下delete会调用全局operator delete释放内存。</li>
</ul>
<h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><p>placement new是重载operator new的一个标准、全局的版本，它不能被自定义的版本代替（不像普通的operator new和operator delete能够被替换成用户自定义的版本）。<br>它的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="type">size_t</span>, <span class="type">void</span> *p )</span> <span class="title">throw</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=orange>它不能够被自定义的版本代替（不像普通版本的operator new和operator delete能够被替换）</font>。如果你想在已经分配的内存中创建一个对象，使用new是不行的。也就是说placement new允许你在一个已经分配好的内存中（栈或堆中）构造一个新的对象。原型中void*p实际上就是指向一个已经分配好的内存缓冲区的的首地址。</p>
<ul>
<li><p>我们为什么需要placement new？</p>
<p>  1.用placement new 解决buffer的问题</p>
<p>  问题描述：用new分配的数组缓冲时，由于调用了默认构造函数，因此执行效率上不佳。若没有默认构造函数则会发生编译时错误。如果你想在预分配的内存上创建对象，用缺省的new操作符是行不通的。要解决这个问题，你可以用placement new构造。它允许你构造一个新对象到预分配的内存上。</p>
<p>  2.增大时空效率的问题</p>
<p>  使用new操作符分配内存需要在堆中查找足够大的剩余空间，显然这个操作速度是很慢的，而且有可能出现无法分配内存的异常（空间不够）。placement new就可以解决这个问题。我们构造对象都是在一个预先准备好了的内存缓冲区中进行，不需要查找内存，内存分配的时间是常数；而且不会出现在程序运行中途出现内存不足的异常。所以，placement new非常适合那些对时间要求比较高，长时间运行不希望被打断的应用程序。</p>
</li>
<li><p>placement new使用步骤</p>
<ul>
<li><p>第一步  缓存提前分配<br>  有三种方式：<br>  1.为了保证通过placement new使用的缓存区的memory alignment(内存队列)正确准备，使用普通的new来分配它：在堆上进行分配class Task。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * buff = <span class="keyword">new</span> [<span class="built_in">sizeof</span>(Task)]; <span class="comment">//分配内存</span></span><br></pre></td></tr></table></figure>
<p>  (请注意auto或者static内存并非都正确地为每一个对象类型排列，所以，你将不能以placement new使用它们。)</p>
<p>  2.在栈上进行分配</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> ;</span><br><span class="line"><span class="type">char</span> buf[<span class="function">N*<span class="title">sizeof</span><span class="params">(Task)</span>]</span>; <span class="comment">//分配内存</span></span><br></pre></td></tr></table></figure>
<p>  3.还有一种方式，就是直接通过地址来使用。(必须是有意义的地址)</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* buf = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt; (<span class="number">0xF00F</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步：对象的分配 </p>
<p>  在刚才已分配的缓存区调用placement new来构造一个对象。<br>  Task *ptask &#x3D; new (buf) Task</p>
</li>
<li><p>第三步：使用</p>
<p>  按照普通方式使用分配的对象：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ptask-&gt;<span class="built_in">memberfunction</span>();</span><br><span class="line">ptask-&gt; member;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></li>
<li><p>第四步：对象的析构</p>
<p>  一旦你使用完这个对象，你必须调用它的析构函数来毁灭它。按照下面的方式调用析构函数：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ptask-&gt;~<span class="built_in">Task</span>(); <span class="comment">//调用外在的析构函数</span></span><br></pre></td></tr></table></figure></li>
<li><p>第五步：释放</p>
<p>  你可以反复利用缓存并给它分配一个新的对象（重复步骤2，3，4）如果你不打算再次使用这个缓存，你可以象这样释放它：delete [] buf;</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>c++小知识点汇总</title>
    <url>/2021/08/20/c++%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="能不能使用struct代替模板的class-x2F-typename"><a href="#能不能使用struct代替模板的class-x2F-typename" class="headerlink" title="能不能使用struct代替模板的class&#x2F;typename"></a>能不能使用struct代替模板的class&#x2F;typename</h3><p>答： c++保留struct主要为了兼容c语言，但是在c语言中是不存在模板的，所有没有必要在模板中支持struct声明模板形参。</p>
<h3 id="重复free会发生什么"><a href="#重复free会发生什么" class="headerlink" title="重复free会发生什么"></a>重复free会发生什么</h3><p>答：编译通过，运行时出错。由于free之后没有立即初始化，可能会被注入病毒。<a href="http://d0m021ng.github.io/2017/02/24/PWN/Linux%E5%A0%86%E6%BC%8F%E6%B4%9E%E4%B9%8BDouble-free/">http://d0m021ng.github.io/2017/02/24/PWN/Linux%E5%A0%86%E6%BC%8F%E6%B4%9E%E4%B9%8BDouble-free/</a></p>
<h3 id="nullptr解决了什么问题"><a href="#nullptr解决了什么问题" class="headerlink" title="nullptr解决了什么问题"></a>nullptr解决了什么问题</h3><p>在c语言中，0可以用来表示空指针，在c++中，不允许void指针隐式转换为其他类型指针，但是允许0作为指针类型的字面值常量。因此会遇到下面这种问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用的是void func(int)这个函数，在编译时也有可能报二义性错误。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++设计模式：单例模式</title>
    <url>/2021/09/02/c++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>参考<a href="https://github.com/liu-jianhao/Cpp-Design-Patterns">github</a><br><a href="https://refactoringguru.cn/design-patterns/">这个网站</a>也非常生动。</p>
<h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><ol>
<li><p>非线程安全(懒汉)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">static</span> Single* instance;</span><br><span class="line">    <span class="built_in">Single</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Single* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    Single&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Single</span>(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Single* <span class="title">Single::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="built_in">Single</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    Single* singleton = Single::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f1 addr:&quot;</span> &lt;&lt; singleton &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    Single* singleton = Single::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f2 addr:&quot;</span> &lt;&lt; singleton &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">Single* Single::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func2)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程安全懒汉(获得单例的时候加锁)</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">static</span> Single* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex s_mutex;</span><br><span class="line">    <span class="built_in">Single</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Single* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    Single&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Single</span>(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Single* <span class="title">Single::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(s_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="built_in">Single</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    Single* singleton = Single::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f1 addr:&quot;</span> &lt;&lt; singleton &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    Single* singleton = Single::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f2 addr:&quot;</span> &lt;&lt; singleton &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::mutex Single::s_mutex;</span><br><span class="line">Single* Single::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func2)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>线程安全懒汉（c++11局部静态变量）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Single</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Single</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Single</span>(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Single</span>(Single&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single&amp; <span class="keyword">operator</span>=(Single&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Single* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Single* <span class="title">Single::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> Single instance &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> &amp;instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    Single* singleton = Single::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f1 addr:&quot;</span> &lt;&lt; singleton &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    Single* singleton = Single::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f2 addr:&quot;</span> &lt;&lt; singleton &lt;&lt; std::endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func2)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>线程安全饿汉式(直接显式申请)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">static</span> Single* instance;</span><br><span class="line">    <span class="built_in">Single</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Single* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    Single&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Single</span>(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">freeSingle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Single* <span class="title">Single::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="built_in">Single</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Single::freeSingle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">delete</span>(instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    Single* singleton = Single::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f1 addr:&quot;</span> &lt;&lt; singleton &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    Single* singleton = Single::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f2 addr:&quot;</span> &lt;&lt; singleton &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">Single* Single::instance = <span class="keyword">new</span> <span class="built_in">Single</span>();</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func2)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    Single::<span class="built_in">freeSingle</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>懒汉式是以时间换空间，适应于访问量较小时；推荐使用内部静态变量的懒汉单例，代码量少</li>
<li>饿汉式是以空间换时间，适应于访问量较大时，或者线程比较多的的情况</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>c++内存管理系列：tcmalloc</title>
    <url>/2021/08/29/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%9Atcmalloc/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>参考tcmalloc <a href="https://github.com/google/tcmalloc/blob/master/docs/design.md">github官方文档</a><br>TCMalloc 是一种内存分配器，旨在替代系统默认分配器，具有以下特点：</p>
<ul>
<li>可以实现大多数对象的快速、无竞争的分配和释放。 对象被缓存，具体取决于模式，每个线程或每个逻辑 CPU。 大多数分配不需要锁定，因此多线程应用程序争用少，扩展性好。</li>
<li>灵活使用内存，因此释放的内存可以重新用于不同的对象大小，或返回给操作系统。</li>
<li>通过分配相同大小的对象的“页面”来降低每个对象的内存开销。小对象的空间损耗很少。</li>
<li>低开销采样，可以详细了解应用程序内存使用情况。<br>下面的框图显示了 TCMalloc 的粗略内部结构：<br><img src="/images/tcmalloc-1.png"></li>
</ul>
<p>我们可以将 TCMalloc 分解为三个组件。前端、中端和后端。职责的粗略分解是：</p>
<ul>
<li>前端是一个缓存，为应用程序提供快速的内存分配和释放。  </li>
<li>中端负责重新填充前端缓存。</li>
<li>后端处理从操作系统获取内存。<br>请注意，前端可以在 per-CPU 或 legacy per-thread 模式下运行，后端可以支持大页面感知 pageheap 或 legacy pageheap。</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>freelist是tcmalloc的实现基础，只不过tcmalloc采用了三层的架构：TreadCache、CentralCache、PageHeap。每一级的分配单元的粒度不一样。基本的原理就是：分配内存和释放内存都是按照从前到后的顺序，在各个层次中进行尝试，前面的层次分配内存失败，则从下一层分配一批补充上来；前面的层次释放了过多的内存，则回收一批到下一层次。</p>
<ul>
<li>tcmalloc有三个层次:<ul>
<li>TreadCache, 这个内存池是线程私有的, 每个线程一份. 每个线程首先会从这里请求内存. 由于是线程私有的, 不需要加锁同步, 所以非常高效. TreadCache维护一组不同类型的freelist, 基本单位是object, 为了实现变长内存的申请, object预设了一些规格(class), 比如8, 16, 32, 80等等</li>
<li>CentralCache, 这是第二层线程池, 这是全局的, 当线程在本地请求失败时会从这里请求object. CentralCache也维护一组关联obejct规格的freelist, 基本单位是span, span由多个连续page(物理单位)组成, 可以分隔为多个object(逻辑单位)。</li>
<li>Pageheap, 这是第三层, 当无法从CentralCache获取到内存时, 会从Pageheap中请求span. 如果PageHeap也没有内存, 则向操作系统请求. Pageheap根据page的数量维护一组freelist, 基本单位是span. 另外还维护这page到span的映射关系.</li>
</ul>
</li>
<li>小对象和大对象: 大于256kb的称为大对象, 大对象会直接向Pageheap申请span, 小对象的申请则需要经过TreadCache申请。</li>
<li>粒度: tcmalloc, 有两种粒度的内存, object和span. TreadCache维护的粒度是object, PageHeap维护的粒度是span. 而CentralCache是一个中间者, 维护span到object的映射关系.</li>
</ul>
<p>数据结构概览如图所示：<br><img src="/images/tcmalloc-3.png"></p>
<ul>
<li>TreadCache<br>线程本地缓存, 比较简单, 维护一组freelist, 尺寸小于256K的小对象, 均由它进行分配. 分配过程中不需要加锁<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadCache</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">     FreeList      list_[kNumClasses];    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>CentralCache<br>对应不同class的object, CentralCache中有多个CentralFreeList. CentralFreeList维护的是span链表, 每个span下有根据object的大小切割组成一个object链. objects链表示未被分配的object, 分配出去的object数量使用span.refcount_ 记录. span 的结构如下:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Span</span> &#123;</span></span><br><span class="line">  PageID        start;          <span class="comment">// Span描述的内存的起始地址</span></span><br><span class="line">  Length        length;        <span class="comment">// Span页面数量</span></span><br><span class="line">  Span*         next;           <span class="comment">// Span由双向链表组成，PageHeap和CentralFreeList中都用的到</span></span><br><span class="line">  Span*         prev;           <span class="comment">//</span></span><br><span class="line">  <span class="type">void</span>*         objects;        <span class="comment">// Span会在CentralFreeList中拆分成由object组成的free list</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  refcount : <span class="number">16</span>;  <span class="comment">// Span的object被引用次数，当refcount=0时，表示此Span没有被使用</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  sizeclass : <span class="number">8</span>;  <span class="comment">// Span属于的size class</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  location : <span class="number">2</span>;   <span class="comment">// Span在的位置IN_USE？normal？returned？</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  sample : <span class="number">1</span>;     <span class="comment">// Sampled object?</span></span><br><span class="line">  <span class="comment">// What freelist the span is on: IN_USE if on none, or normal or returned</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
CentralFreeList的结构:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CentralFreeList</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    SpinLock lock_;     <span class="comment">//控制线程访问的锁</span></span><br><span class="line">    <span class="type">size_t</span> size_class_;  <span class="comment">// span对应object的size class, 同上</span></span><br><span class="line">    Span empty_;         <span class="comment">// 放置没有空闲空间的span, 可以避免查找这部分span</span></span><br><span class="line">    Span nonempty_;  <span class="comment">// 和empty相对</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
CentralFreeList里有两个span链表：nonempty_和empty_，根据span的objects链是否有空闲，放入对应链表。</li>
</ul>
<p>CentralFreeList里面还有一个cache（tc_slots_），回收回来的一批object先放进cache，存不下了再回收进span的objects链。分配object给ThreadCache时也是先尝试在cache里面拿，没了再去span里面分配。</p>
<p>TreadCache一般都是以batch_size为一个批次像CentralCache请求, 而为了cache的简单高效，如果批次个数不等于batch_size，则会绕过cache。</p>
<ul>
<li>Pageheap</li>
</ul>
<p>整体结构如下图所示：<br><img src="/images/tcmalloc-6.png"></p>
<p>数组中第256个元素是所有大于255个页面都挂到该链表中.用多种定长 Page 来实现变长 Page 的分配，初始时只有 255 Page 的 Span，如果要分配 1 个 Page 的 Span，就把这个 Span 分裂成两个，1 + 254，把254再记录下来。对于 Span 的回收，需要考虑Span的合并问题，否则在分配回收多次之后，就只剩下很小的 Span 了，也就是带来了外部碎片 问题。</p>
<ul>
<li>page维护了两样东西: page -&gt; span的映射关系和空闲的span伙伴系统.</li>
</ul>
<ol>
<li><p>page -&gt; span 映射<br> page到span的映射关系通过radix 树来实现, 当释放一段内存时, 通过内存偏移和对齐, 就能计算出对应的page, 拿到page在radix树中查找到对应的span, 拿到span就拿到了sizeclass, 从而可以在CentralCache定位span, 将释放的object添加到span的objects链表. 另外通过radix树还可以找到span的相邻span, 如果相邻的span空闲, 则会合并他们。</p>
</li>
<li><p>伙伴系统(span freelist)<br> span的尺寸有从1个page到255个page的所有规格, 大于255个page的span单独归为一类，不作细分. PageHeap维护了这些不同规格的freelist:</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SpanList</span> &#123;</span></span><br><span class="line">Span        normal;</span><br><span class="line">Span        returned;</span><br><span class="line">&#125;;</span><br><span class="line">SpanList large_;                    <span class="comment">// 超过256k的span链表</span></span><br><span class="line">SpanList free_[kMaxPages]</span><br></pre></td></tr></table></figure>

<p> 在内存分配时, 会根据span的大小在伙伴系统中查找, 如果没有空闲的span时, 会向上层更大尺寸的span链表请求, 再没有, 就需要向系统申请了. span可以根据需要不断组合和分割.   </p>
<p> freelist其实是有两个链，normal和returned，以区别活跃跟不活跃的内存。    </p>
<p> PageHeap并不会将内存释放给kernel，因为它们之间的交互都是针对一批连续page的，要想回收到整批的page，可能性很小。在PageHeap里面，多余的内存会放到returned里面去，跟normal做一下隔离。这样一来，normal的内存总是优先被使用，kernel倾向于一直保留它们。而returned的内存则不常被使用，kernel在内存不够的时候会优先将它们swap掉。span进入returned时，tcmalloc还附加了一个操作，madvise(MADV_DONTNEED)，试图告诉kernel这个内存已经不用了</p>
<p> 其实不用returned也能完成这样的事情，因为normal是个链表，每次分配回收总是作用在链表头上，那么链表内的span本身就按从热到冷的顺序排序了。链表尾部的span如果长期不被使用，不管是否移动到returned链，kernel都会倾向于将它们swap掉</p>
<p> 为减少查询radix tree的开销，PageHeap还维护了一个最近最常使用的若干个page到class（span.sizeclass）的对应关系cache。为了保持cache的效率，cache只提供64K个固定坑位，旧的对应关系会被新来的对应关系替换掉。</p>
</li>
</ol>
<h3 id="分配和回收流程"><a href="#分配和回收流程" class="headerlink" title="分配和回收流程"></a>分配和回收流程</h3><p>一图胜千言<br><img src="/images/tcmalloc-4.png"></p>
<p><img src="/images/tcmalloc-5.png"></p>
<h3 id="与ptmalloc对比的优点"><a href="#与ptmalloc对比的优点" class="headerlink" title="与ptmalloc对比的优点"></a>与ptmalloc对比的优点</h3><p>优点：</p>
<ul>
<li>分配更快.小对象几乎无锁， &gt;32KB的对象从CentralCache中分配使用自旋锁。 并且&gt;32KB对象都是页面对齐分配，多线程的时候应尽量避免频繁分配，否则也会造成自旋锁的竞争和页面对齐造成的浪费。</li>
<li>占用额外空间少(例如，分配N个8字节对象可能要使用大约8N * 1.01字节的空间。即，多用百分之一的空间。Ptmalloc2使用最少8字节描述一个chunk。)</li>
<li>碎片化控制优越.ThreadCache会阶段性的回收内存到CentralCache里。 解决了ptmalloc2中arena之间不能迁移的问题。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>effective c++系列：const详解</title>
    <url>/2021/08/16/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9Aconst%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><ul>
<li>const名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。</li>
</ul>
<h3 id="const和-define的区别"><a href="#const和-define的区别" class="headerlink" title="const和#define的区别"></a>const和#define的区别</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> b 200</span></span><br></pre></td></tr></table></figure>
<ul>
<li>编译器处理方式不同<ul>
<li>#define在预处理阶段展开。<br>const在编译期间使用。</li>
</ul>
</li>
<li>类型和安全检查方式不同<ul>
<li>#define宏没有类型，不做任何类型检查，仅仅是展开。<br>  const常量有具体的类型，在编译阶段会执行类型检查。</li>
</ul>
</li>
<li>存储方式不同<ul>
<li>define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。<br>  const常量会在内存中分配(可以是堆中也可以是栈中)。</li>
</ul>
</li>
<li>作用域<ul>
<li>#define只能定义全局变量 const可以定义类内专属常量。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line">&#125;;</span><br><span class="line">A obj;</span><br><span class="line">cout &lt;&lt; obj.a &lt;&lt; endl;<span class="comment">//ok</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//error！only visible in class</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>const的几个优点<ul>
<li>编译器可以检查const类型 #define只是进行替换。</li>
<li>调试器可以对const进行调试，但不能对宏变量进行调试。</li>
</ul>
</li>
<li><font color=orange>对于常量，尽量使用const、enum代替#define</font></li>
<li><font color=orange>对于函数宏定义，尽量使用inline函数代替#define</font></li>
</ul>
<h3 id="const的内存分配"><a href="#const的内存分配" class="headerlink" title="const的内存分配"></a>const的内存分配</h3><ul>
<li>对于基础类型（整数，浮点数，字符） 系统不会给const变量开辟空间，会将其放到符号表中。  </li>
<li>对const变量取地址的时候 系统就会给它开辟空间。</li>
<li>当用变量给const变量赋值时，系统直接为其开辟空间而不会把它放入符号表中。  </li>
<li>const 自定义数据类型(结构体、对象) 和数组系统会分配空间。</li>
</ul>
<h3 id="主要功能和用法"><a href="#主要功能和用法" class="headerlink" title="主要功能和用法"></a>主要功能和用法</h3><ul>
<li>在class外部修饰全局变量  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)(&amp;a);</span><br><span class="line">    *p = <span class="number">8</span>;<span class="comment">//error!Exception has occurred.Segmentation fault</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修饰namespace作用域中的常量  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> hqin&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// namespace hqin</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hqin::a = <span class="number">1</span>; <span class="comment">//error: assignment of read-only variabl &#x27;hqin::a&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修饰文件、函数或者作用域中被声明为static的对象<ul>
<li>不希望改变static变量时使用。</li>
</ul>
</li>
<li>通常情况下如果不希望改变文件指针、函数内部等更改数据，就命名为const类型  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//不希望改变x,y，函数内部也不希望改变data</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sum</span> <span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">A&lt;complex&lt;<span class="type">int</span>&gt;&gt; test = A&lt;complex&lt;<span class="type">int</span>&gt;&gt;();</span><br><span class="line"><span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; test.<span class="built_in">sum</span>(a,b);</span><br></pre></td></tr></table></figure></li>
<li>修饰class内部的static和non-static成员变量  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure></li>
<li>修饰指针、指针所指物  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> p1; <span class="comment">// p1:只读  *p1:变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2; <span class="comment">// p2:变量 *p2:只读</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p3; <span class="comment">// p3:变量 *p3:只读</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * <span class="type">const</span> p4; <span class="comment">// p4:只读 *p4:只读</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p5; <span class="comment">// p5:只读 *p5:只读</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="const初始化"><a href="#const初始化" class="headerlink" title="const初始化"></a>const初始化</h3><ul>
<li><p>在c++ 11 之前，普通变量、常量（const）、静态（static）、静态常量（static const)的初始化和声明如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">声明时初始化</th>
<th align="center">初始化列表初始化</th>
<th align="center">构造函数内初始化</th>
<th align="center">类外初始化</th>
</tr>
</thead>
<tbody><tr>
<td align="center">普通变量</td>
<td align="center">x</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">x <font color=green>(整型除外)</font></td>
</tr>
<tr>
<td align="center">const</td>
<td align="center">x</td>
<td align="center">√</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">static</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">static const</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">√</td>
</tr>
</tbody></table>
</li>
<li><p>c++ 11之后，如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">声明时初始化</th>
<th align="center">初始化列表初始化</th>
<th align="center">构造函数内初始化</th>
<th align="center">类外初始化</th>
</tr>
</thead>
<tbody><tr>
<td align="center">普通变量</td>
<td align="center"><font color=orange>√</font></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">x <font color=green>(整型除外)</font></td>
</tr>
<tr>
<td align="center">const</td>
<td align="center">x</td>
<td align="center">√</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">static</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">static const</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">√</td>
</tr>
</tbody></table>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>effective c++</tag>
      </tags>
  </entry>
  <entry>
    <title>effective-c++系列：public继承注意事项</title>
    <url>/2021/08/23/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9Apublic%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="public继承-x3D-x3D-is-a关系"><a href="#public继承-x3D-x3D-is-a关系" class="headerlink" title="public继承&#x3D;&#x3D;is_a关系"></a>public继承&#x3D;&#x3D;is_a关系</h3><ul>
<li><p>如果<font color=green>class D </font>以public形式继承<font color=green>class B</font>，那么相当于告诉c++编译器，每一个类型为D的对象同时也是一个类型为B的对象，反之不成立。 </p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> Person&#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果任何函数期望获得Person，那么也能接受一个Student</p>
</li>
<li><p>继承带来的问题</p>
<ul>
<li>子类可能不具有父类的某些行为（emmm, 个人觉得一方面因为抽象的层次不够高，或者继承范围太模糊）</li>
<li>父类的一些函数会破坏子类的性质（例如父类是一个矩形，子类是一个正方形，扩展长方形的长宽函数应用在子类会破坏正方形的性质。</li>
</ul>
</li>
</ul>
<h3 id="命名遮盖规则"><a href="#命名遮盖规则" class="headerlink" title="命名遮盖规则"></a>命名遮盖规则</h3><ul>
<li><p>对于下面的代码  </p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<font color=orange>dosomething() </font>函数中，cin的对象是<font color=green>double x</font>变量，这遵从c++的名称遮掩规则，即内层作用域会遮盖外层作用域。</p>
</li>
<li><p>同理而言，在继承关系中也是这样</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  <font color=orange>class Base</font>包含了纯虚函数，虚函数和普通成员函数，以此来说明命名遮盖和只和函数名有关而与其他无关。<br>  假设<font color=orange>f4()</font>实现代码如下  </p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::f4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  当编译器遇到<font color=orange>f2()</font>函数时，会查找作用域，首先看<font color=orange>f4()</font>函数内部，没有找到，于是朝赵<font color=orange>class Derived</font>作用域也没有找到，最后查找<font color=orange>class Base</font>作用域找到<font color=orange>f2()</font>。假如<font color=orange>class Base</font>中也没有，那就在<font color=orange>class Base</font>所在<font color=orange>namespace</font>中查找，最后在全局作用域 找。  </p>
<p>  下面看一个更复杂的例子</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> )</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f1 - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f2 - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f3 - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">double</span>)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f3 - b - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f1 - d&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f3 - d&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f4 - d&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">d.<span class="built_in">f1</span>(); <span class="comment">//ok</span></span><br><span class="line">d.<span class="built_in">f1</span>(x); <span class="comment">//error! Base::f1()被覆盖</span></span><br><span class="line">d.<span class="built_in">f2</span>(); <span class="comment">//ok Base::f2()</span></span><br><span class="line">d.<span class="built_in">f3</span>(); <span class="comment">//ok</span></span><br><span class="line">d.<span class="built_in">f3</span>(x); <span class="comment">//error! Base::f3(int)被Derived::f3()遮盖</span></span><br></pre></td></tr></table></figure>
<p>  子类的<font color=orange>f3()</font>函数将父类的<font color=orange>f3()和f3(int)</font>都覆盖掉。<br>  如果想避免这种情况，可以像下面这样  </p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> )</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f1 - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f2 - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f3 - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">double</span>)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f3 - b - b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::f1;</span><br><span class="line">    <span class="keyword">using</span> Base::f3;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f1 - d&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f3 - d&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f4 - d&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">d.<span class="built_in">f1</span>(); <span class="comment">//ok</span></span><br><span class="line">d.<span class="built_in">f1</span>(x); <span class="comment">//ok</span></span><br><span class="line">d.<span class="built_in">f2</span>(); <span class="comment">//ok Base::f2()</span></span><br><span class="line">d.<span class="built_in">f3</span>(); <span class="comment">//ok</span></span><br><span class="line">d.<span class="built_in">f3</span>(x); <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<p>  那假如我们只想继承父类的一部分函数呢？这时候<font color=orange>using</font>就不管用了，因为一旦声明using，父类同名所有函数可见。这时候可以采用<font color=orange>转交函数（forwarding function）</font>完成。  </p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//virtual void f1() = 0; effective c++ 160页为纯虚函数？此处存疑。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base::<span class="built_in">f1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="接口继承和实现继承"><a href="#接口继承和实现继承" class="headerlink" title="接口继承和实现继承"></a>接口继承和实现继承</h3><ul>
<li>成员函数的接口总是会被继承。</li>
<li>声明一个纯虚函数的目的是为了让子类只继承函数接口。<font color=orange>纯虚函数对象不能被实例化</font>。</li>
<li>声明一个虚函数（非纯虚函数）的目的是让子类继承该函数的接口和缺省实现。</li>
<li>声明一个非虚函数的目的是为了让子类继承函数的接口和一份强制性实现。非虚函数是<font color=orange>不变性（invariant）和凌驾特异性（specialization）</font>的。所以它不该在子类中被重新定义。</li>
</ul>
<h3 id="默认参数的继承"><a href="#默认参数的继承" class="headerlink" title="默认参数的继承"></a>默认参数的继承</h3><ul>
<li><p>考虑下面默认参数继承的代码</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Option</span> &#123;First, Second, Third&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(Option op = First)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(Option op = Second)</span> <span class="type">const</span></span>;<span class="comment">//赋予不同的默认值，这很糟糕</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(Option op)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 如果这么写，用户以对象调用一定要指定参数值，</span></span><br><span class="line">    <span class="comment">// 因为静态绑定下不从基类继承默认值</span></span><br><span class="line">    <span class="comment">// 如果使用指针或者引用调用，可以不指定因为动态绑定下这个函数会从基类</span></span><br><span class="line">    <span class="comment">// 继承默认值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>静态类型：变量声明的时候指定的类型名。</p>
</li>
<li><p>动态类型：目前所指对象的类型。  </p>
<pre><code class="cpp">Base* b;             //静态类型为Base*,无动态类型
Base* d1 = new D1;   //静态类型为Base*,动态类型为D1*
Base* d2 = new D2;   //静态类型为Base*,动态类型为D2*
b = d1;              //静态类型为Base*,动态类型为D1*
d1 = d2;             //静态类型为Base*,动态类型为D2*
</code></pre>
</li>
<li><p><font color=orange>virtual函数动态绑定，默认参数却是静态绑定</font>  </p>
<pre><code class="cpp">D2 -&gt; f1(); //使用的是D2的函数，参数却是Base的。
</code></pre>
<p>  问：为什么要采用这种方式运行呢？<br>  答：提高运行期效率。在编译器直接决定，不在运行期动态确定（降低编译器实现难度，增加速度）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>effective c++</tag>
      </tags>
  </entry>
  <entry>
    <title>effective-c++系列：private继承和多继承</title>
    <url>/2021/08/25/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9Aprivate%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="private继承"><a href="#private继承" class="headerlink" title="private继承"></a>private继承</h3><ul>
<li><p>如果class之间的继承关系是private，那么编译器不会自动将一个子类对象转换为父类对象。</p>
</li>
<li><p>使用private继承的所有父类成员，在子类中都是private类型的，即使成员在父类中是public或者protected的。</p>
</li>
<li><p>private意味着只有实现部分被继承，接口部分应略去。</p>
</li>
<li><p>private继承可以造成empty base最优化，如下代码  </p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    Empty e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(A);<span class="comment">//8</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>);<span class="comment">//4</span></span><br><span class="line">```  </span><br><span class="line">使用私有继承可以避免</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">private</span> Empty&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(A);<span class="comment">//4</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>);<span class="comment">//4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul>
<li><p>多重继承中的歧义<br>看下面的代码  </p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: </span><br><span class="line">    <span class="keyword">public</span> A,</span><br><span class="line">    <span class="keyword">public</span> B&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">d.<span class="built_in">f1</span>(); <span class="comment">//ambiguous! A::f1() or B::f1()</span></span><br></pre></td></tr></table></figure>
<p>  在基类中定义命名相同的函数很容易造成这种问题，即使继承方式可能是私有或者方法名是私有，都会造成歧义。可以使用作用域+函数的方式显示声明要调用的函数，如A::f1();</p>
</li>
<li><p>菱形继承</p>
</li>
</ul>
<p><img src="/images/002.png"></p>
<center>菱形继承</center>  

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span>&#123;</span><br><span class="line">    string filename;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span> : <span class="keyword">public</span> File&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span> : <span class="keyword">public</span> File&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile,</span><br><span class="line">              <span class="keyword">public</span> OutputFile&#123;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是一个典型的菱形继承，假设File类有个成员变量Filename，那么IOFile内有多少个Filename呢？有两种说法。<br>  IOFile从InputFile和OutputFile均复制了一份，存在两份filename。<br>  IOFile只应该有一份。<br>  c++默认的做法是第一种，产生两个filename成员。</li>
<li>解决方式是<font color=orange>virtual继承</font>，也就是说File类必须是virtual base class</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span>&#123;</span><br><span class="line">    string filename;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> File&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> File&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile,</span><br><span class="line">              <span class="keyword">public</span> OutputFile&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这样在IOFile内部就只有一份filename副本。<br>那么虚继承是怎么实现这个功能的呢。具体在虚继承内存布局章节会讨论。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>effective c++</tag>
      </tags>
  </entry>
  <entry>
    <title>effective-c++系列：对象模型杂谈（1）</title>
    <url>/2021/08/20/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="编译器版本的默认构造-x2F-析构-x2F-赋值-x2F-拷贝构造函数"><a href="#编译器版本的默认构造-x2F-析构-x2F-赋值-x2F-拷贝构造函数" class="headerlink" title="编译器版本的默认构造&#x2F;析构&#x2F;赋值&#x2F;拷贝构造函数"></a>编译器版本的默认构造&#x2F;析构&#x2F;赋值&#x2F;拷贝构造函数</h3><ul>
<li><p>当用户没有在类内声明上述三个函数时，如果程序中需要调用，编译器会为用户自动编写<font color=green>默认构造&#x2F;析构&#x2F;拷贝构造</font>这三个重要的函数，即所谓的Big Three，和拷贝构造函数，并且这些函数都是<font color=orange>inline</font>的。在c++ 11后编译器新增了move构造和move赋值两个函数：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Handle</span> &#123;</span><br><span class="line">        T* p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Handle</span>(T* pp) : p&#123;pp&#125; &#123;&#125;</span><br><span class="line">        <span class="comment">// 用户定义构造函数： 没有隐式的拷贝和移动操作</span></span><br><span class="line">        ~<span class="built_in">Handle</span>() &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">        <span class="built_in">Handle</span>(Handle&amp;&amp; h) :p&#123;h.p&#125;<span class="comment">//移动拷贝</span></span><br><span class="line">            &#123; h.p=<span class="literal">nullptr</span>; &#125;; </span><br><span class="line">        Handle&amp; <span class="keyword">operator</span>=(Handle&amp;&amp; h) <span class="comment">//移动赋值</span></span><br><span class="line">            &#123; <span class="keyword">delete</span> p; p=h.p; h.p=<span class="literal">nullptr</span>; &#125; </span><br><span class="line">        <span class="built_in">Handle</span>(<span class="type">const</span> Handle&amp;) = <span class="keyword">delete</span>;  <span class="comment">//禁用拷贝构造函数</span></span><br><span class="line">        Handle&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Handle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ```  </span><br><span class="line">- 一旦我们显式地指明（ 声明, 定义, =<span class="keyword">default</span>, 或者 =<span class="keyword">delete</span> ）了上述五个函数之中的任意一个，编译器将不会默认自动生成move操作。  </span><br><span class="line">- 一旦我们显式地指明（ 声明, 定义, =<span class="keyword">default</span>, 或者 =<span class="keyword">delete</span> ）了上述五个函数之中的任意一个，编译器将默认自动生成所有的拷贝操作。但是，我们应该尽量避免这种情况的发生，不要依赖于编译器的默认动作。</span><br><span class="line"></span><br><span class="line">### 使用默认版本函数会发生什么？</span><br><span class="line">- 编译器产生的析构函数是none-<span class="keyword">virtual</span>的，除非<span class="keyword">class</span>的base <span class="keyword">class</span>自身声明有<span class="keyword">virtual</span>构造函数。</span><br><span class="line">- 编译器产生的构造函数和拷贝构造函数只是单纯将non-<span class="type">static</span>成员变量拷贝到目标对象，考虑一个对象内部如果存在指针，那么只是单纯地复制指针，对于指针所指的内存区域不进行拷贝，这样的浅拷贝技术可能在后续使用过程中酿成大祸。</span><br><span class="line"></span><br><span class="line">### 如何避免使用编译器自动生成的函数？</span><br><span class="line">- 如果你不想让类支持拷贝构造或者拷贝赋值函数  </span><br><span class="line">    使用<span class="keyword">private</span>关键字</span><br><span class="line">    ```cpp</span><br><span class="line">    <span class="keyword">class</span> A&#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">const</span> A&amp;);</span><br><span class="line">        A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp;);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>  继承一个不可拷贝赋值和拷贝构造的类</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  c++11后可以使用delete关键字</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;) =<span class="keyword">delete</span>;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp;) =<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基类析构函数可以是none-virtual的吗？"><a href="#基类析构函数可以是none-virtual的吗？" class="headerlink" title="基类析构函数可以是none-virtual的吗？"></a>基类析构函数可以是none-virtual的吗？</h3><ul>
<li>当基类析构函数带有多态性质，也就是使用基类指针调用子类函数的时候，析构函数必须是virtual类型的。<ul>
<li>当需要多态的时候，一般情况下需要在堆中分配内存，这样在delete的时候就存在问题：delete的是一个父类指针，但是父类析构函数不是虚函数，那么这个子类对象中子类的部分就无法释放，这样就会存在局部销毁的情况，会导致严重的资源泄露。</li>
</ul>
</li>
<li>凡是一个类中带有virtual字样的函数，一般情况下析构函数都要是虚函数。</li>
<li>当一个类不是父类的时候，析构函数尽量不要设置成虚函数。<ul>
<li>因为一个类只要有虚函数，就携带虚表指针，占用额外的内存，当类内数据量很小的时候，虚表指针就回造成很大比例的内存浪费。</li>
</ul>
</li>
</ul>
<h3 id="析构函数可以抛出异常吗？"><a href="#析构函数可以抛出异常吗？" class="headerlink" title="析构函数可以抛出异常吗？"></a>析构函数可以抛出异常吗？</h3><ul>
<li>一般情况下不要在析构函数中抛异常<br>比如在析构函数中释放多个资源，但是在释放过程中出现异常，那么剩余资源就无法被释放，就会造成内存泄露。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        <span class="comment">// throws...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;A&gt; resource;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//dtor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>异常处理<br>  捕捉异常，结束程序  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//do delete</span></span><br><span class="line">        &#125;<span class="built_in">catch</span>()&#123;</span><br><span class="line">            std::<span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  捕捉异常，不执行任何操作  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//do delete</span></span><br><span class="line">        &#125;<span class="built_in">catch</span>()&#123;</span><br><span class="line">            <span class="comment">//记录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>effective c++</tag>
      </tags>
  </entry>
  <entry>
    <title>effective-c++系列：对象模型杂谈（2）</title>
    <url>/2021/08/20/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%9D%82%E8%B0%88%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="在构造函数和析构函数中能调用虚函数吗？"><a href="#在构造函数和析构函数中能调用虚函数吗？" class="headerlink" title="在构造函数和析构函数中能调用虚函数吗？"></a>在构造函数和析构函数中能调用虚函数吗？</h3><ul>
<li><p>严禁在构造函数中调用虚函数</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dosome</span><span class="params">()</span><span class="type">const</span></span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        <span class="built_in">dosome</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">B b;<span class="comment">//往往会出现意想不到的错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果在父类的构造函数中调用虚函数，当使用子类对象的时候，会首先调用父类的构造函数。  </li>
<li>在父类构造函数执行过程中，this指针为base class对象，因此在dosome()函数中的操作是在父类对象中完成的。</li>
<li><font color=orange>由于虚函数dosome()在父类对象中完成，往往达不到多态（延迟绑定）的目的。</font></li>
</ul>
</li>
<li><p>严禁在析构函数中调用虚函数</p>
<ul>
<li>在子类对象析构时顺序为先将自身的local data释放，然后调用父类的析构函数，如果父类析构存在虚函数，那么编译器会有两种选择：调用虚函数的基类版本或者调用虚函数的派生类版本。</li>
<li>如果调用派生类版本的函数，此时子类部分已经释放，会导致严重错误。</li>
<li><font color=orange>实际情况是编译器会调用基类版本的虚函数，那么和构造函数一样，不会发生多态。</font></li>
</ul>
</li>
<li><p>解决方式</p>
<ul>
<li>将在构造或析构函数中调用的函数设置为non-virtual，要求子类对象在构造时传递必要的信息。</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dosome</span><span class="params">(<span class="type">const</span> string&amp; info)</span><span class="type">const</span></span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> string&amp; info)&#123;</span><br><span class="line">        <span class="built_in">dosome</span>(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> string <span class="title">createParamter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">B</span>():<span class="built_in">A</span>(<span class="built_in">createParamter</span>())&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="如果new、delete、delete-没有成对使用会发生什么？"><a href="#如果new、delete、delete-没有成对使用会发生什么？" class="headerlink" title="如果new、delete、delete[]没有成对使用会发生什么？"></a>如果new、delete、delete[]没有成对使用会发生什么？</h3><p><img src="/images/001.png">  </p>
<center>单个对象和对象数组的内存布局</center>

<ul>
<li><p>使用delete释放对象数组</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string* s = <span class="keyword">new</span> string[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="keyword">delete</span> s;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述情况下，只会调用第一个s的函数，其余99个对象不执行任何操作，后面程序也不会再拿到其句柄，从而会造成内存泄露。</li>
<li>实际上，对于一组对象，delete[]会寻找数组前的一个count计数来获取数组长度。</li>
</ul>
</li>
<li><p>使用delete[]释放单个对象</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string* s = <span class="keyword">new</span> string;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="keyword">delete</span>[] s;<span class="comment">// Exception has occurred.Segmentation fault</span></span><br></pre></td></tr></table></figure>
<ul>
<li>delete[]在内存中读取s指针前4字节内存作为数组长度，这样做显然是非法的。</li>
</ul>
</li>
</ul>
<h3 id="设计一个class需要注意什么？"><a href="#设计一个class需要注意什么？" class="headerlink" title="设计一个class需要注意什么？"></a>设计一个class需要注意什么？</h3><ul>
<li>对象创建和销毁（构造、析构函数、内存分配）</li>
<li>对象初始化和赋值</li>
<li>对象如果pass by value应该怎么做？（如果对象内存在指针，是否需要深拷贝）</li>
<li>定义class约束（数据类型检查）</li>
<li>继承或者被继承</li>
<li>类型转换（隐式类型转换）</li>
<li>操作符重载</li>
<li>标准函数是否适用（拷贝赋值，拷贝构造）</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>effective c++</tag>
      </tags>
  </entry>
  <entry>
    <title>effective-c++系列：引用浅析</title>
    <url>/2021/08/20/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9A%E5%BC%95%E7%94%A8%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>引用不是新定义一个变量，而是给一个已经存在的变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul>
<li>引用变量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = data; <span class="comment">//可读可写</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>常引用变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>&amp; ref = data;<span class="comment">//只读</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常引用常量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = data;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;data;</span><br><span class="line"><span class="type">int</span>* &amp;ref = p;</span><br><span class="line">cout &lt;&lt; data &lt;&lt; endl; <span class="comment">//0</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//0</span></span><br><span class="line">cout &lt;&lt; *ref &lt;&lt; endl; <span class="comment">//0</span></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;<span class="comment">//0x61fe14</span></span><br><span class="line">cout &lt;&lt; ref &lt;&lt; endl;<span class="comment">//0x61fe14</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用变量的类型必须与它的实体类型一致（因为取别名要符合引用实体的身份，如果类型不一致则会报错）</p>
</li>
<li><p>引用变量使用必须要进行初始化（不然没有实体都不知道给谁取别名）</p>
</li>
<li><p>一个变量可以有多个引用（就相当于一个变量有好几个别名，这是可以的）</p>
</li>
</ul>
<h3 id="以pass-by-reference-to-const替换pass-by-value"><a href="#以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="以pass-by-reference-to-const替换pass-by-value"></a>以pass-by-reference-to-const替换pass-by-value</h3><ul>
<li>通常情况下c++使用值传递，传递对象都是由拷贝构造函数产生，这样做会产生非常昂贵的成本。每对一个对象进行值传递，就会进行一次拷贝构造函数和析构函数。</li>
<li>考虑上述情况，可以使用<font color=orange>引用传递</font>来避免不必要的运行和内存开销。同时，如果希望在函数中不对对象进行任何改变，可以使用const关键字避免。</li>
<li><font color=orange>在c++底层，引用是通过指针实现的</font>，因此对于内置类型如int,double,float等使用值传递会有更高的效率。</li>
</ul>
<h3 id="必须返回对象时，不要使用引用"><a href="#必须返回对象时，不要使用引用" class="headerlink" title="必须返回对象时，不要使用引用"></a>必须返回对象时，不要使用引用</h3><ul>
<li><p>考虑如下的例子，考虑在函数内生成一个对象</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">A</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">A</span><span class="params">(<span class="type">int</span> x)</span>:val(x)&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getVal</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> A&amp; <span class="keyword">operator</span>*(<span class="type">const</span> A&amp; lhs, <span class="type">const</span> A&amp; rhs)&#123;</span><br><span class="line">    A* res = <span class="keyword">new</span> <span class="built_in">A</span>(lhs.<span class="built_in">getVal</span>() * rhs.<span class="built_in">getVal</span>());</span><br><span class="line">    <span class="keyword">return</span> *res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  operator*函数内生成了一个对象，并在heap上分配了内存，那么这块内存永远不会再外部释放，因为离开函数作用域这个指针将自动销毁。<br>  那么使用下面这个函数生成临时对象也一样不可取，因为离开函数作用域，这个对象将被销毁。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> A&amp; <span class="keyword">operator</span>*(<span class="type">const</span> A&amp; lhs, <span class="type">const</span> A&amp; rhs)&#123;</span><br><span class="line">    <span class="function">A <span class="title">res</span><span class="params">(lhs.getVal() * rhs.getVal())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  能不能像下面这样声明一个静态对象来保存结果呢？</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> A&amp; <span class="keyword">operator</span>*(<span class="type">const</span> A&amp; lhs, <span class="type">const</span> A&amp; rhs)&#123;</span><br><span class="line">    <span class="type">static</span> A res;</span><br><span class="line">    res = <span class="built_in">A</span>(lhs.<span class="built_in">getVal</span>() * rhs.<span class="built_in">getVal</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  表面上看没有太大问题，但是在使用中我们常常会像一下这样来使用：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> A&amp; lhs, <span class="type">const</span> A&amp; rhs);</span><br><span class="line">A r, s, t, x;</span><br><span class="line"><span class="keyword">if</span>((r * s) == (t * x))&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  如果保存的是静态对象，那么这个表达式永远为真。表达式展开的结果是</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">operator</span>==(<span class="keyword">operator</span>*(r, s), <span class="keyword">operator</span>*(t, x)))&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>  在比较时永远比较的是静态对象值，不管执行顺序是什么，对象自身永远相等。</p>
</li>
<li><p>正确的做法</p>
<ul>
<li>让函数返回一个新对象</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">const</span> A <span class="keyword">operator</span>*(<span class="type">const</span> A&amp; lhs, <span class="type">const</span> A&amp; rhs)&#123;</span><br><span class="line">    <span class="function">A <span class="title">res</span><span class="params">(lhs.getVal() * rhs.getVal())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>effective c++</tag>
      </tags>
  </entry>
  <entry>
    <title>effective-c++系列：深入探析swap</title>
    <url>/2021/08/22/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%85%A5%E6%8E%A2%E6%9E%90swap/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="swap介绍"><a href="#swap介绍" class="headerlink" title="swap介绍"></a>swap介绍</h3><ul>
<li><p>swap作为STL的一部分，在算法、容器、迭代器中被广泛使用。<br>c++为用户定义了算法的默认形式如下：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; x, T&amp; y)</span></span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">tmp</span><span class="params">(x)</span></span>;</span><br><span class="line">        x = y;</span><br><span class="line">        y = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  如果类型T支持拷贝构造和拷贝赋值就可以完成交换。</p>
</li>
</ul>
<h3 id="内含指针的类型交换"><a href="#内含指针的类型交换" class="headerlink" title="内含指针的类型交换"></a>内含指针的类型交换</h3><ul>
<li><p>从上面可以看出，默认版本需要执行一次拷贝构造，两次拷贝赋值才能完成交换，如果类型内部像下面这种pimpl（内含指针，指向数据）的形式，显然只需要交换指针即可，如果采用默认版本就回降低效率。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A_impl</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    A_impl* p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; rhs)&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        *p = *(rhs.p);</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">A</span><span class="params">(<span class="type">const</span> A&amp; rhs)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>很自然地，我们可以通过函数重载来在类内自定义swap函数：</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A_impl</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">A_impl</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    A_impl* p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">A</span><span class="params">(<span class="type">const</span> A&amp; rhs)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">A</span><span class="params">(A_impl* p)</span>:p(p)&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span></span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(p, rhs.p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getVal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p -&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;A&gt;(A&amp; lhs, A&amp; rhs)&#123;</span><br><span class="line">        lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A* d1 = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="keyword">new</span> <span class="built_in">A_impl</span>(<span class="number">0</span>));</span><br><span class="line">A* d2 = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="keyword">new</span> <span class="built_in">A_impl</span>(<span class="number">3</span>));</span><br><span class="line">cout &lt;&lt; d1-&gt;<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//0</span></span><br><span class="line">cout &lt;&lt; d2-&gt;<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//3</span></span><br><span class="line"><span class="built_in">swap</span>(d1, d2);</span><br><span class="line">cout &lt;&lt; d1-&gt;<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//3</span></span><br><span class="line">cout &lt;&lt; d2-&gt;<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="swap函数重载和特化"><a href="#swap函数重载和特化" class="headerlink" title="swap函数重载和特化"></a>swap函数重载和特化</h3><ul>
<li>对于模板类，如何设计swap<br>假如我们现在有个模板类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    T val;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span></span>&#123;</span><br><span class="line">        T tmp = val;</span><br><span class="line">        val = rhs.val;</span><br><span class="line">        rhs.val = tmp;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getVal</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们希望写出它的特化版本,但是很不幸会报错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">void</span> swap&lt;A&lt;T&gt;&gt;(A&lt;T&gt;&amp; lhs, A&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">        lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//error: non-class, non-variable partial specialization &#x27;swap&lt;A&lt;T&gt; &gt;&#x27; is not allowed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下我们是偏特化一个函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(A&lt;T&gt;&amp; lhs, A&lt;T&gt;&amp; rhs)</span></span>&#123;</span><br><span class="line">        lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">d1</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; d1.<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//0</span></span><br><span class="line">cout &lt;&lt; d2.<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//3</span></span><br><span class="line"><span class="built_in">swap</span>(d1, d2);</span><br><span class="line">cout &lt;&lt; d1.<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//3</span></span><br><span class="line">cout &lt;&lt; d2.<span class="built_in">getVal</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl; <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>但是c++的std命名空间很特殊，如果不必要，尽量不要在其中添加自定义的操作。那么我们该怎么让程序调用我们自己的版本呢？很简单，定义一个非成员swap，并置于某个命名空间中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> hqin&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(A&lt;T&gt;&amp; lhs, A&lt;T&gt;&amp; rhs)</span></span>&#123;</span><br><span class="line">        lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看看我们在调用下面这个函数时会发生肾么事</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(T&amp; lhs, T&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(lhs, rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行到swap后编译器有很多不同版本可以选择：</p>
<ul>
<li>std一般化版本</li>
<li>std特化版本</li>
<li>某个命名空间中的T专属版本</li>
</ul>
<p>事实情况是编译器会优先匹配global空间或T所在命名空间中的所有T专属的版本，如果不存在就使用std特化版本，最后使用一般版本。</p>
<h3 id="swap异常"><a href="#swap异常" class="headerlink" title="swap异常"></a>swap异常</h3><ul>
<li>成员版的swap绝不可抛出异常。因为swap的一个最好的应用就是帮助class提供强烈的一场安全性保障。</li>
<li>非成员版本可以抛出异常。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>effective c++</tag>
      </tags>
  </entry>
  <entry>
    <title>effective-c++系列：单继承、多继承、虚函数、虚继承内存布局</title>
    <url>/2021/08/27/effective-cpp%E7%B3%BB%E5%88%97%EF%BC%9A%E8%99%9A%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="虚函数内存模型"><a href="#虚函数内存模型" class="headerlink" title="虚函数内存模型"></a>虚函数内存模型</h3><ul>
<li>我们可以用基类型A的引用或者指针持有实际类型为派生类B的对象，这意味着，编译时我们无法通过其声明类型来确定其实际类型，也就无法确定应该调用哪个具体的虚函数。考虑到程序中的每个函数都在内存中有着唯一的地址，我们可以将具体函数的地址作为成员变量，存放在对象之中，这样就可以在运行时，通过访问这个成员变量，获取到实际类型虚函数的地址。</li>
</ul>
<h3 id="单继承的内存模型"><a href="#单继承的内存模型" class="headerlink" title="单继承的内存模型"></a>单继承的内存模型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>&#125;</span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    A a;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; endl; </span><br><span class="line">    <span class="comment">// 16 = 虚函数指针（8） + int（4）+ 对齐（4）</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 24 = Base虚函数指针（8）+ Base int(4) + padding（4）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用gdb调试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o main -g</span><br><span class="line">gdb main</span><br></pre></td></tr></table></figure>

<p>内存布局为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类内存</span></span><br><span class="line">(gdb) p b</span><br><span class="line">$<span class="number">1</span> = &#123;</span><br><span class="line">  _vptr.Base = <span class="number">0x404580</span> &lt;vtable <span class="keyword">for</span> Base+<span class="number">16</span>&gt;,</span><br><span class="line">  x = <span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line">(gdb) p &amp;b</span><br><span class="line">$<span class="number">4</span> = (Base *) <span class="number">0x61fe10</span></span><br><span class="line">(gdb) x/<span class="number">16</span>xb <span class="number">0x61fe10</span></span><br><span class="line"><span class="number">0x61fe10</span>:       <span class="number">0x40</span>    <span class="number">0x45</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x61fe18</span>:       <span class="number">0x10</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="comment">// 子类内存</span></span><br><span class="line">(gdb) p a</span><br><span class="line">$<span class="number">2</span> = &#123;</span><br><span class="line">  &lt;Base&gt; = &#123;</span><br><span class="line">    _vptr.Base = <span class="number">0x404520</span> &lt;vtable <span class="keyword">for</span> A+<span class="number">16</span>&gt;, </span><br><span class="line">    x = <span class="number">20</span></span><br><span class="line">  &#125;, &lt;No data fields&gt;&#125;</span><br><span class="line">(gdb) p &amp;a</span><br><span class="line">$<span class="number">5</span> = (A *) <span class="number">0x61fe00</span></span><br><span class="line">(gdb) x/<span class="number">16</span>xb <span class="number">0x61fe00</span></span><br><span class="line"><span class="number">0x61fe00</span>:       <span class="number">0x20</span>    <span class="number">0x45</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x61fe08</span>:       <span class="number">0x14</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<p>可以看出子类中含有父类的成员变量和一个虚函数指针，虚函数表指针在前。<br>子类覆盖了父类的函数f1()，因此在子类的虚函数表中会将Base::f1()覆盖为A::f1().</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) p b.f1</span><br><span class="line">$<span class="number">2</span> = &#123;<span class="built_in">void</span> (Base * <span class="type">const</span>)&#125; <span class="number">0x402d80</span> &lt;Base::<span class="built_in">f1</span>()&gt;</span><br><span class="line">(gdb) p b</span><br><span class="line">$<span class="number">3</span> = &#123;_vptr.Base = <span class="number">0x404540</span> &lt;vtable <span class="keyword">for</span> Base+<span class="number">16</span>&gt;, x = <span class="number">16</span>&#125;</span><br><span class="line">(gdb) x/<span class="number">16</span>xb <span class="number">0x404540</span> <span class="comment">//Base虚函数表</span></span><br><span class="line"><span class="comment">//f1()函数地址</span></span><br><span class="line"><span class="number">0x404540</span> &lt;_ZTV4Base+<span class="number">16</span>&gt;:        <span class="number">0x80</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x404548</span> &lt;_ZTV4Base+<span class="number">24</span>&gt;:        <span class="number">0x90</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">gdb) p a</span><br><span class="line">$<span class="number">4</span> = &#123;&lt;Base&gt; = &#123;_vptr.Base = <span class="number">0x404520</span> &lt;vtable <span class="keyword">for</span> A+<span class="number">16</span>&gt;, x = <span class="number">20</span>&#125;, &lt;No data fields&gt;&#125;</span><br><span class="line">(gdb) x/<span class="number">16</span>xb <span class="number">0x404520</span> <span class="comment">//A虚函数表</span></span><br><span class="line"><span class="comment">//f1()函数</span></span><br><span class="line"><span class="number">0x404520</span> &lt;_ZTV1A+<span class="number">16</span>&gt;:   <span class="number">0x20</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x404528</span> &lt;_ZTV1A+<span class="number">24</span>&gt;:   <span class="number">0x90</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<p>在线性继承关系中，子类只需包含一个虚函数指针和直接父类的所有成员函数即可。  </p>
<h3 id="多继承内存模型"><a href="#多继承内存模型" class="headerlink" title="多继承内存模型"></a>多继承内存模型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f0</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">public</span> Base1,</span><br><span class="line">        <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::f1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::f2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(Base1);<span class="comment">//16</span></span><br><span class="line"><span class="built_in">sizeof</span>(Base2);<span class="comment">//16</span></span><br><span class="line"><span class="built_in">sizeof</span>(A);<span class="comment">//32</span></span><br></pre></td></tr></table></figure>
<p>同样使用gdb调试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) p a</span><br><span class="line">$<span class="number">2</span> = &#123;</span><br><span class="line">  &lt;Base1&gt; = &#123;</span><br><span class="line">    _vptr.Base1 = <span class="number">0x404560</span> &lt;vtable <span class="keyword">for</span> A+<span class="number">16</span>&gt;,</span><br><span class="line">    x = <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &lt;Base2&gt; = &#123;</span><br><span class="line">    _vptr.Base2 = <span class="number">0x404580</span> &lt;vtable <span class="keyword">for</span> A+<span class="number">48</span>&gt;,</span><br><span class="line">    x = <span class="number">16</span></span><br><span class="line">  &#125;, &lt;No data fields&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出Base1作为A的主基类，虚函数表从Base1的函数地址开始。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) p &amp;a    </span><br><span class="line">$<span class="number">3</span> = (A *) <span class="number">0x61fe00</span></span><br><span class="line">(gdb) x/<span class="number">32</span>xb <span class="number">0x61fe00</span></span><br><span class="line"><span class="number">0x61fe00</span>:       <span class="number">0x60</span>    <span class="number">0x45</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x61fe08</span>:       <span class="number">0x14</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x61fe10</span>:       <span class="number">0x80</span>    <span class="number">0x45</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x61fe18</span>:       <span class="number">0x10</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<p>A中存在Base1的虚表指针，Base2的虚表指针。可以看到两个虚表是相连的，如果重写Base1的函数会直接在虚表中覆盖，Base2同理。<br>下面在内存中查看下两个虚表的布局</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) x/<span class="number">64</span>xb <span class="number">0x404550</span></span><br><span class="line"><span class="number">0x404550</span> &lt;_ZTV1A&gt;:      <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> </span><br><span class="line"><span class="number">0x404558</span> &lt;_ZTV1A+<span class="number">8</span>&gt;:    <span class="number">0xc0</span>    <span class="number">0x44</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">// RTTI:运行时类型信息(Run-Time Type Identification, RTTI)</span></span><br><span class="line"><span class="number">0x404560</span> &lt;_ZTV1A+<span class="number">16</span>&gt;:   <span class="number">0xa0</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">// Base1::f0()</span></span><br><span class="line"><span class="number">0x404568</span> &lt;_ZTV1A+<span class="number">24</span>&gt;:   <span class="number">0xf0</span>    <span class="number">0x2c</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">// A::f1()</span></span><br><span class="line"><span class="number">0x404570</span> &lt;_ZTV1A+<span class="number">32</span>&gt;:   <span class="number">0xf0</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span> <span class="comment">//offeset</span></span><br><span class="line"><span class="number">0x404578</span> &lt;_ZTV1A+<span class="number">40</span>&gt;:   <span class="number">0xc0</span>    <span class="number">0x44</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">// RTTI</span></span><br><span class="line"><span class="number">0x404580</span> &lt;_ZTV1A+<span class="number">48</span>&gt;:   <span class="number">0x00</span>    <span class="number">0x2e</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">//chunk A::f1()</span></span><br><span class="line"><span class="number">0x404588</span> &lt;_ZTV1A+<span class="number">56</span>&gt;:   <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<p>A将Base1作为主基类，也就是将它虚函数“并入”Base1的虚函数表之中，并将Base1的虚指针作为A的内存起始地址。</p>
<p>而类型Base2的虚指针_vptr.Base2并不能直接指向虚表中的第4个实体，这是因为_vptr.Base2所指向的虚表区域，在格式上必须也是一个完整的虚表。因此，需要为_vptr.Base2创建对应的虚表放在虚表Base1的部分之后。 </p>
<p>在多继承中，由于不同的基类起点可能处于不同的位置，因此当需要将它们转化为实际类型时，this指针的偏移量也不相同。由于实际类型在编译时是未知的，这要求偏移量必须能够在运行时获取。实体offset表示的就是实际类型起始地址到当前这个形式类型起始地址的偏移量。在向上动态转换到实际类型时，让this指针加上这个偏移量即可得到实际类型的地址。需要注意的是，由于一个类型即可以被单继承，也可以被多继承，因此即使只有单继承，实体offset也会存在于每一个多态类型之中。</p>
<p>而实体Thunk又是什么呢？如果不考虑这个Thunk，这里应该存放函数A::f1()的地址。然而，从内存分配可以看出，Thunk A::f1()和A::f1()的地址并不一样。</p>
<p>为了弄清楚Thunk是什么，我们首先要注意到，如果一个类型Base2 的引用持有了实际类型为A的变量，这个引用的起始地址在A+16处。当它调用由类型A重写的函数f1()时，如果直接使用this指针调用A::f1()会由于this指针的地址多出16字节的偏移量导致错误。 因此在调用之前，this指针必须要被调整至正确的位置 。这里的Thunk起到的就是这个作用：首先将this 指针调整到正确的位置，即减少16字节偏移量，然后再去调用函数A::f1()。 </p>
<p><font color=orange>简单来说，offerset的作用是编译器绑定对象，如果是Base1指针，就加上Base1对应的偏移量，如果是Base2，就加上Base2的偏移量。<br>而thunk的作用类似于重定位，当用户申请Base2指针指向A对象，并且调用f1()函数，在内存中首先是从0x404580开始找，找到thunk后，里面是一个代码段，首先将this指针向上指，然后再调用this-&gt;f1()</font>。</p>
<h3 id="虚继承的内存模型"><a href="#虚继承的内存模型" class="headerlink" title="虚继承的内存模型"></a>虚继承的内存模型</h3><p>上述的模型中，对于派生类对象，它的基类相对于它的偏移量总是确定的，因此动态向下转换并不需要依赖额外的运行时信息。</p>
<p>而虚继承破坏了这一条件。它表示虚基类相对于派生类的偏移量可以依实际类型不同而不同，且仅有一份拷贝，这使得虚基类的偏移量在运行时才可以确定。因此，我们需要对继承了虚基类的类型的虚表进行扩充，使其包含关于虚基类偏移量的信息。</p>
<p><font color=orange>虚继承最常用的场景是解决菱形继承的问题</font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> ax;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;                                     </span><br><span class="line">    <span class="type">int</span> bx;                          </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f0</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;             </span><br><span class="line">&#125;;                                     </span><br><span class="line">                                      </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;                                     </span><br><span class="line">    <span class="type">int</span> cx;                          </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f0</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;             </span><br><span class="line">&#125;;                                    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line">    <span class="type">int</span> dx;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f0</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl; <span class="comment">// 16 虚指针A + int + pad</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; endl; <span class="comment">// 32 A + 虚指针B + int + pad</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; endl; <span class="comment">// 32 A + 虚指针C + int + pad</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(D) &lt;&lt; endl; <span class="comment">// 48 A + 虚指针D + int + pad</span></span><br></pre></td></tr></table></figure>
<p>A的内存布局和虚表没有太多变化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) p a</span><br><span class="line">$<span class="number">6</span> = &#123;</span><br><span class="line">  _vptr.A = <span class="number">0x4056c0</span> &lt;vtable <span class="keyword">for</span> A+<span class="number">16</span>&gt;,</span><br><span class="line">  x = <span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line">(gdb) x/<span class="number">16</span>xb <span class="number">0x4056c0</span></span><br><span class="line"><span class="number">0x4056c0</span> &lt;_ZTV1A+<span class="number">16</span>&gt;:   <span class="number">0x70</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">// A::f0()</span></span><br><span class="line"><span class="number">0x4056c8</span> &lt;_ZTV1A+<span class="number">24</span>&gt;:   <span class="number">0x80</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">// A::f1()</span></span><br></pre></td></tr></table></figure>

<p>B&#x2F;C的内存布局</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$<span class="number">7</span> = &#123;</span><br><span class="line">  &lt;A&gt; = &#123;</span><br><span class="line">    _vptr.A = <span class="number">0x405710</span> &lt;vtable <span class="keyword">for</span> B+<span class="number">64</span>&gt;,</span><br><span class="line">    x = <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">  members of B:</span><br><span class="line">  _vptr.B = <span class="number">0x4056e8</span> &lt;vtable <span class="keyword">for</span> B+<span class="number">24</span>&gt;,</span><br><span class="line">  y = <span class="number">4199705</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B&#x2F;C的虚表内存为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) x/<span class="number">72</span>xb <span class="number">0x4056d0</span></span><br><span class="line"><span class="number">0x4056d0</span> &lt;_ZTV1B&gt;:      <span class="number">0x10</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span> <span class="comment">// vbase_offset</span></span><br><span class="line"><span class="number">0x4056d8</span> &lt;_ZTV1B+<span class="number">8</span>&gt;:    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>  <span class="comment">//offset_to_top</span></span><br><span class="line"><span class="number">0x4056e0</span> &lt;_ZTV1B+<span class="number">16</span>&gt;:   <span class="number">0x70</span>    <span class="number">0x55</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   <span class="comment">// RTTI of B</span></span><br><span class="line"><span class="number">0x4056e8</span> &lt;_ZTV1B+<span class="number">24</span>&gt;:   <span class="number">0xd0</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   <span class="comment">// B.f0()</span></span><br><span class="line"><span class="number">0x4056f0</span> &lt;_ZTV1B+<span class="number">32</span>&gt;:   <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   <span class="comment">//vcall_offset</span></span><br><span class="line"><span class="number">0x4056f8</span> &lt;_ZTV1B+<span class="number">40</span>&gt;:   <span class="number">0xf0</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>   <span class="comment">//vcall_offset</span></span><br><span class="line"><span class="number">0x405700</span> &lt;_ZTV1B+<span class="number">48</span>&gt;:   <span class="number">0xf0</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>   <span class="comment">//offset_to_top</span></span><br><span class="line"><span class="number">0x405708</span> &lt;_ZTV1B+<span class="number">56</span>&gt;:   <span class="number">0x70</span>    <span class="number">0x55</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   <span class="comment">//RTTI for B</span></span><br><span class="line"><span class="number">0x405710</span> &lt;_ZTV1B+<span class="number">64</span>&gt;:   <span class="number">0xb0</span>    <span class="number">0x2f</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   <span class="comment">//Thunk B::f0()</span></span><br><span class="line"><span class="number">0x405718</span> &lt;_ZTV1B+<span class="number">72</span>&gt;:   <span class="number">0x80</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   <span class="comment">//A::f1()</span></span><br></pre></td></tr></table></figure>
<p>可以表示为下面这个结构</p>
<p><img src="/images/003.png"></p>
<center>B的内存布局</center>
对于形式类型为B的引用，在编译时，无法确定它的基类A它在内存中的偏移量。 因此，需要在虚表中额外再提供一个实体，表明运行时它的基类所在的位置，这个实体称为vbase_offset，位于offset_to_top上方。  

<p>除此之外，如果在B中调用A声明且B没有重写的函数，由于A的偏移量无法在编译时确定，而这些函数的调用由必须在A的偏移量确定之后进行， 因此这些函数的调用相当于使用A的引用调用。也因此，当使用虚基类A的引用调用重载函数时 ，每一个函数对this指针的偏移量调整都可能不同，它们被记录在镜像位置的vcall_offset中。例如，调用A::bar()时，this指针指向的是vptr_A，正是函数所属的类A的位置，因此不需要调整，即vcall_offset(0)；而B::f0()是由类型B实现的， 因此需要将this指针向前调整16字节。</p>
<p>D的内存布局 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) p d</span><br><span class="line">$<span class="number">8</span> = &#123;</span><br><span class="line">  &lt;B&gt; = &#123;</span><br><span class="line">    &lt;A&gt; = &#123;</span><br><span class="line">      _vptr.A = <span class="number">0x4057d0</span> &lt;vtable <span class="keyword">for</span> D+<span class="number">96</span>&gt;,</span><br><span class="line">      x = <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    members of B:</span><br><span class="line">    _vptr.B = <span class="number">0x405788</span> &lt;vtable <span class="keyword">for</span> D+<span class="number">24</span>&gt;,</span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &lt;C&gt; = &#123;</span><br><span class="line">    members of C:</span><br><span class="line">    _vptr.C = <span class="number">0x4057a8</span> &lt;vtable <span class="keyword">for</span> D+<span class="number">56</span>&gt;,</span><br><span class="line">    z = <span class="number">-605902202</span></span><br><span class="line">  &#125;,</span><br><span class="line">  members of D:</span><br><span class="line">  d = <span class="number">32763</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚表内存为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) x/<span class="number">176</span>xb <span class="number">0x405770</span></span><br><span class="line"><span class="number">0x405770</span> &lt;_ZTV1D&gt;:      <span class="number">0x20</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x405778</span> &lt;_ZTV1D+<span class="number">8</span>&gt;:    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x405780</span> &lt;_ZTV1D+<span class="number">16</span>&gt;:   <span class="number">0xd0</span>    <span class="number">0x55</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x405788</span> &lt;_ZTV1D+<span class="number">24</span>&gt;:   <span class="number">0x10</span>    <span class="number">0x2f</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x405790</span> &lt;_ZTV1D+<span class="number">32</span>&gt;:   <span class="number">0x10</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x405798</span> &lt;_ZTV1D+<span class="number">40</span>&gt;:   <span class="number">0xf0</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>   </span><br><span class="line"><span class="number">0x4057a0</span> &lt;_ZTV1D+<span class="number">48</span>&gt;:   <span class="number">0xd0</span>    <span class="number">0x55</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x4057a8</span> &lt;_ZTV1D+<span class="number">56</span>&gt;:   <span class="number">0xa0</span>    <span class="number">0x2f</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x4057b0</span> &lt;_ZTV1D+<span class="number">64</span>&gt;:   <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x4057b8</span> &lt;_ZTV1D+<span class="number">72</span>&gt;:   <span class="number">0xe0</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span></span><br><span class="line"><span class="number">0x4057c0</span> &lt;_ZTV1D+<span class="number">80</span>&gt;:   <span class="number">0xe0</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>    <span class="number">0xff</span>   </span><br><span class="line"><span class="number">0x4057c8</span> &lt;_ZTV1D+<span class="number">88</span>&gt;:   <span class="number">0xd0</span>    <span class="number">0x55</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x4057d0</span> &lt;_ZTV1D+<span class="number">96</span>&gt;:   <span class="number">0xd0</span>    <span class="number">0x2f</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="number">0x4057d8</span> &lt;_ZTV1D+<span class="number">104</span>&gt;:  <span class="number">0x80</span>    <span class="number">0x2d</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>   </span><br><span class="line"><span class="comment">//下面为调试信息</span></span><br><span class="line"><span class="number">0x4057e0</span> &lt;_ZTV1D+<span class="number">112</span>&gt;:  <span class="number">0x47</span>    <span class="number">0x43</span>    <span class="number">0x43</span>    <span class="number">0x3a</span>    <span class="number">0x20</span>    <span class="number">0x28</span>    <span class="number">0x78</span>    <span class="number">0x38</span></span><br><span class="line"><span class="number">0x4057e8</span> &lt;_ZTV1D+<span class="number">120</span>&gt;:  <span class="number">0x36</span>    <span class="number">0x5f</span>    <span class="number">0x36</span>    <span class="number">0x34</span>    <span class="number">0x2d</span>    <span class="number">0x70</span>    <span class="number">0x6f</span>    <span class="number">0x73</span>   </span><br><span class="line"><span class="number">0x4057f0</span> &lt;_ZTV1D+<span class="number">128</span>&gt;:  <span class="number">0x69</span>    <span class="number">0x78</span>    <span class="number">0x2d</span>    <span class="number">0x73</span>    <span class="number">0x65</span>    <span class="number">0x68</span>    <span class="number">0x2d</span>    <span class="number">0x72</span>   </span><br><span class="line"><span class="number">0x4057f8</span> &lt;_ZTV1D+<span class="number">136</span>&gt;:  <span class="number">0x65</span>    <span class="number">0x76</span>    <span class="number">0x30</span>    <span class="number">0x2c</span>    <span class="number">0x20</span>    <span class="number">0x42</span>    <span class="number">0x75</span>    <span class="number">0x69</span>   </span><br><span class="line"><span class="number">0x405800</span> &lt;_ZTV1D+<span class="number">144</span>&gt;:  <span class="number">0x6c</span>    <span class="number">0x74</span>    <span class="number">0x20</span>    <span class="number">0x62</span>    <span class="number">0x79</span>    <span class="number">0x20</span>    <span class="number">0x4d</span>    <span class="number">0x69</span>   </span><br><span class="line"><span class="number">0x405808</span> &lt;_ZTV1D+<span class="number">152</span>&gt;:  <span class="number">0x6e</span>    <span class="number">0x47</span>    <span class="number">0x57</span>    <span class="number">0x2d</span>    <span class="number">0x57</span>    <span class="number">0x36</span>    <span class="number">0x34</span>    <span class="number">0x20</span></span><br><span class="line"><span class="number">0x405810</span> &lt;_ZTV1D+<span class="number">160</span>&gt;:  <span class="number">0x70</span>    <span class="number">0x72</span>    <span class="number">0x6f</span>    <span class="number">0x6a</span>    <span class="number">0x65</span>    <span class="number">0x63</span>    <span class="number">0x74</span>    <span class="number">0x29</span>   </span><br><span class="line"><span class="number">0x405818</span> &lt;_ZTV1D+<span class="number">168</span>&gt;:  <span class="number">0x20</span>    <span class="number">0x38</span>    <span class="number">0x2e</span>    <span class="number">0x31</span>    <span class="number">0x2e</span>    <span class="number">0x30</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<p>可以表示为下面这个结构</p>
<p><img src="/images/004.png">  </p>
<center>D的虚表结构</center>

<p>与非虚继承相似，通过虚继承产生的派生类在构造和析构时，所调用的虚函数只是当前阶段的的虚表中对应的函数。一个问题也就由此产生，由于在虚基类的不同的派生类中，虚基类相对于该类型的偏移量是可以不同的，如果直接使用2.3中的方法，直接用继承虚基类的类型自身的虚表作为构建该类时使用的虚表，会由于偏移量的不同，导致无法正确获取虚基类中的对象。<br>这个描述比较抽象拗口，我们通过3.1中的菱形继承的例子进行解释。四个类型A，B，C和D的继承关系如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> ax;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;                                     </span><br><span class="line">    <span class="type">int</span> bx;                          </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f0</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;             </span><br><span class="line">&#125;;                                     </span><br><span class="line">                                      </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;                                     </span><br><span class="line">    <span class="type">int</span> cx;                          </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f0</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;             </span><br><span class="line">&#125;;                                    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line">    <span class="type">int</span> dx;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f0</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>观察实际类型为B和实际类型为D对象的内存布局可以发现，如果实际类型为B，虚基类A对B的首地址的偏移量为16；若实际类型为D，则其中A对B首地址的偏移量为32。这明显与B自身的虚表冲突。如果构建D::B时还采用的是B自身的虚表，会由于偏移量的不同导致错误。</p>
<p>这一问题的解决方法其实很粗暴，那就是在对象构造、析构阶段，会用到多少种虚表，会用到多少种虚指针就生成多少种虚指针。在构造或析构时，“按需分配”。</p>
<p>例如，这里的类型D是类型B和C的子类，而B和C虚继承了类型A。 这种继承关系会导致D内部含有的B(称作B-in-D)、C(称作C-in-D)的虚表与B、C的虚表不同。 因此，这需要生成两张新的虚表，即B-in-D和C-in-D的虚表。</p>
<p>由于B-in-D也是B类型的一种布局，B的一个虚表对应两个虚指针，分别是vptr_B和vptr_A，因此它也有两个着两个虚指针。在构造或析构D::B时，其对象的内存布局和虚表布局如图所示：</p>
<p><img src="/images/005.png">  </p>
<p>同样的，在C-in-D中也会有两个虚指针，分别是vptr_C和vptr_A。此外，在最终的D中还有三个虚指针，总计7个不同的虚指针，它们指向3张虚表的7个不同位置。因此编译器为类型D总共生成了3个不同的虚表，和7个不同的虚指针。将这7个虚指针合并到一个表中，这个表就是虚表的表(Virtual Table Table, VTT)。显然，只有当一个类的父类是继承了虚基类的类型时，编译器才会为它创建VTT。</p>
<p>在构造和析构过程中，子类的构造函数或析构函数向基类传递一个合适的、指向VTT某个部分指针，使得父类的构造函数或析构函数获取到正确的虚表。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>effective c++</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB系列：事务</title>
    <url>/2021/11/06/innodb%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="扁平事务"><a href="#扁平事务" class="headerlink" title="扁平事务"></a>扁平事务</h2><p>由begin开始，其中的操作是原子的，要么都执行，要么都回滚。</p>
<ul>
<li>缺点：代价大，若中间某个条件不满足，需要全部回滚。</li>
</ul>
<h2 id="带有保存点的事务"><a href="#带有保存点的事务" class="headerlink" title="带有保存点的事务"></a>带有保存点的事务</h2><p><a href="/images/mysql-9.png"></a><br>如图所示，保存点是递增的。</p>
<h2 id="链事务"><a href="#链事务" class="headerlink" title="链事务"></a>链事务</h2><p><a href="/images/mysql-10.png"></a><br>保存点事务的一种变种，带有保存点的扁平事务，当系统发生崩溃时，所有的保存点都将消失，因此在进行恢复时，事务需要从开始处重新执行。<br>链事务：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐士传递给下一个要开始的事务。</p>
<h2 id="嵌套事务"><a href="#嵌套事务" class="headerlink" title="嵌套事务"></a>嵌套事务</h2><p><a href="/images/mysql-11.png"></a><br>如上图所示，嵌套事务是一个层次结构框架，由一个顶层事务控制各个层次的事务，类似一个树形结构。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>分布式场景下运行扁平事务，需要根据数据所在位置访问网络中的不同节点。</p>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><ol>
<li>redo</li>
</ol>
<ul>
<li>基本概念：用来实现事务的持久性，由两部分组成：内存中的重做日志缓冲（易失性）和重做日志文件（持久性）。每次事务提交之后，需要将所有日志写入重做日志文件中进行持久化，并且写完要调用fsync操作进行磁盘同步。</li>
<li>存储方式：以512字节的块进行保存（也成为重做日志块），日志块有头12字节，尾8字节的标志位。</li>
<li>注：redo记录的是物理页上的变化。</li>
</ul>
<ol start="2">
<li>undo</li>
</ol>
<ul>
<li>基本概念：undo存放在数据库内部的一个特殊段中，成为undo段，undo段位于共享表空间中。当存储引擎回滚时，做的是与之前相反的工作，insert对应delete，update对应相反的update。</li>
<li>存储方式：使用段的方式，每个回滚段中记录1024个undo log 段。</li>
<li>注：undo记录的是逻辑结构上的变化。<strong>undo log的产生也会造成redo log的产生，因为undo log需要持久性的保护。</strong></li>
</ul>
<ol start="3">
<li>purge</li>
</ol>
<p>delete和update可能并不直接删除原有数据，InnoDB存储引擎支持MVCC，所以记录不能再事务提交时立即进行处理，可能其他事务正在引用这行。是否可以删除某条记录可以通过purge来进行判断。</p>
<p><a href="https://baijiahao.baidu.com/s?id=1662096005584873447&wfr=spider&for=pc">这个连接文章</a>写的非常好，讲了四种隔离级别和并发控制。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB系列：体系结构</title>
    <url>/2021/11/06/innodb%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><p><a href="/images/mysql-1.png"></a></p>
<p>从上图可以看出，主要是这几个</p>
<ul>
<li>连接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓冲组件</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ul>
<p>其中比较重要的就是这个插件式的存储引擎，这个引擎完全是基于表的，而不是基于整个数据库。</p>
<h2 id="InnoDB的优点"><a href="#InnoDB的优点" class="headerlink" title="InnoDB的优点"></a>InnoDB的优点</h2><ul>
<li>插入缓冲：对于非聚集索引的插入或更新操作不是每次直接插入到索引页，先判断插入的非聚集索引页是否在缓冲池中，若在，直接插入，若不在，先放入插入缓冲对象中。再用一定的频率对插入缓冲和辅助索引页进行合并操作。</li>
<li>MVCC高并发：支持行锁，每次删除不直接删除数据，而是去标记这个数据无效。</li>
<li>next-key locking 避免幻读。</li>
<li>支持事务，保证ACID。</li>
<li>支持崩溃后的安全恢复。</li>
</ul>
<h2 id="InnoDB体系结构"><a href="#InnoDB体系结构" class="headerlink" title="InnoDB体系结构"></a>InnoDB体系结构</h2><p><a href="/images/mysql-2.png"></a></p>
<p>一图胜千言，上面就是Innodb存储引擎的体系架构。</p>
<ul>
<li><p>后台线程</p>
<ul>
<li>刷新内存池中的数据，保证缓冲池中的内存缓冲是最近的数据。</li>
</ul>
</li>
<li><p>内存池</p>
<ul>
<li>存储所有进程&#x2F;线程需要访问的多个内部数据结构</li>
<li>缓存磁盘上的数据，方便快速读取</li>
<li>redo log的缓冲</li>
</ul>
</li>
</ul>
<ol>
<li>后台线程</li>
</ol>
<ul>
<li><p>Master Thread<br> 主线程，用于将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。</p>
</li>
<li><p>IO Thread</p>
</li>
</ul>
<p>使用大量Async IO来提高数据库性能。这些线程的主要工作就是负责IO请求的回调。1.0.x版本之后，分别有4个write和read，1个insert buffer和1个log thread。</p>
<ul>
<li><p>Purge Thread<br>事务提交之后其undolog可能不在需要，因此需要PurgeThread来回收已经使用并分配的undo页。</p>
</li>
<li><p>Page Cleaner Thread<br>1.2版本引入，目的是减轻主线程的工作量。</p>
</li>
</ul>
<ol start="2">
<li>内存池</li>
</ol>
<ul>
<li>缓冲池<br>其实就是一块内存区域，按照页的方式进行管理。在数据库读取页的时候，首先判断此页是否在缓冲池中，若没有，则读取的时候顺便把它放到缓冲池中。而脏页的回写遵循checkpoint机制。<br>缓冲池中不光是数据和索引，更有自适应哈希索引，所信息，数据字典信息等等。</li>
<li>LRU List&#x2F;Free List&#x2F;Flush List</li>
</ul>
<p>需要注意的是在进行LRU的时候，每次新的页不是直接插在表头，而是5&#x2F;8的位置，为什么？因为某些SQL操作例如数据的扫描和索引等，需要访问表中的甚至全部页，而这些都不是热点数据，如果插在头部会淘汰热点数据。<br>还有一个问题，什么时候会认为这些数据是热点数据？mysql设置了一个参数，只要超过这个时间，就会被移到热端。  </p>
<p>还有一点是脏页可同时存在于LRU list和Flush list中。</p>
<ul>
<li><p>redo log缓冲</p>
</li>
<li><p>额外的内存池<br>对一些数据和结构本身的存储，必要的时候需要设置大一点</p>
</li>
</ul>
<ol start="3">
<li>checkpoint技术</li>
</ol>
<p>设置这个技术的目的就是为了协调cpu和磁盘的速度，刷新频率不能太快，太快导致性能变差，并且如果从缓冲刷到磁盘宕机了，数据就丢失了。为了避免这个情况，使用Write Ahead Log策略，事务提交时，先写重做日志，再修改页，这样可以通过redo log来恢复。<strong>这也是事务ACID中D的要求。</strong><br>综合来看，checkpoint技术解决下面几个问题：</p>
<ul>
<li>缩短数据库恢复时间（只需redo 检查点之后的数据）。</li>
<li>缓冲池不够时，将脏页刷新到磁盘。</li>
<li>redo log不可用时，刷新脏页（redo log满了）。</li>
</ul>
<p>checkpoint分为sharp和fuzzy两种，第一种是把所有脏页刷回磁盘，第二种有下面好几种情况：</p>
<ul>
<li>主线程检查点：每秒或者没十秒从缓冲池刷一定比例的脏页回磁盘。</li>
<li>Flush&#x2F;LRU 检查点：保证列表有一定比例的空闲项。</li>
<li>Async&#x2F;Sync checkpoint：redo日志不可用时刷新。</li>
</ul>
<ol start="4">
<li>主线程工作方式<br>主线程内部由几个循环组成</li>
</ol>
<ul>
<li>主循环<ul>
<li>每1s<ul>
<li>日志缓冲刷新到磁盘</li>
<li>合并插入缓冲</li>
<li>至多100个脏页回写（后面版本改成以磁盘IO吞吐量来定）</li>
<li>如果没有活动，切换到后台循环</li>
</ul>
</li>
<li>每10s<ul>
<li>刷新100个脏页</li>
<li>合并5个插入缓冲</li>
<li>日志缓冲回写</li>
<li>删除无用undo页</li>
<li>刷新100个或10个脏页</li>
</ul>
</li>
</ul>
</li>
<li>后台循环<ul>
<li>删除无用undo</li>
<li>合并20个插入缓冲</li>
<li>跳回主循环</li>
<li>不断刷新100个页，跳转刷新循环</li>
</ul>
</li>
<li>刷新循环</li>
<li>暂停循环</li>
</ul>
<ol start="5">
<li>插入缓冲</li>
</ol>
<p>对于非聚集索引的插入或者更新，不是直接插入到索引页， 而是先放入插入缓冲对象中。再按照一定的频率对插入缓冲和非聚集索引节点进行合并操作。</p>
<ol start="6">
<li>两次写（double write）</li>
</ol>
<p><a href="/images/mysql-3.png"></a><br>两次写由两个部分组成，一部分是内存中的doublewrite buffer（2MB）。另一部分是物理磁盘上共享表空间中连续的128页（2MB）。<br>对缓冲池脏页刷新时：</p>
<ul>
<li>不立马写磁盘，使用memcpy将脏页复制到buffer中</li>
<li>分两次，每次先将buffer的1MB写入共享表空间，调用fsync函数同步磁盘</li>
</ul>
<ol start="7">
<li>自适应哈希索引（AHI）<br>InnoDB会监控对表上索引页的查询，如果观察到简历哈希索引可以带来速度提升，会建立哈希索引。<br>建立哈希索引的条件是：</li>
</ol>
<ul>
<li>通过某模式访问100次</li>
<li>页通过该模式访问了（页中记录&#x2F;16）次</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB系列：索引</title>
    <url>/2021/11/06/innodb%E7%B3%BB%E5%88%97%EF%BC%9A%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><ul>
<li>聚集索引</li>
<li>非聚集索引（辅助索引）</li>
<li>Cardinality<ul>
<li>获取B+树叶子节点的数据，记为A<br>  随机获得B+树索引中8个叶子节点。统计每个页不同记录的个数，分别记为P1,P2…P8<br>  计算cardinality &#x3D; (P1+P2+…P8)A&#x2F;8</li>
</ul>
</li>
</ul>
<h2 id="OLAP-和-OLTP"><a href="#OLAP-和-OLTP" class="headerlink" title="OLAP 和 OLTP"></a>OLAP 和 OLTP</h2><p><a href="/images/mysql-5.png"></a></p>
<ul>
<li><p>OLTP，也叫联机事务处理（Online Transaction Processing），表示事务性非常高的系统，一般都是高可用的在线系统，以小的事务以及小的查询为主，评估其系统的时候，一般看其每秒执行的Transaction以及Execute SQL的数量。<br>OLTP系统最容易出现瓶颈的地方就是CPU与磁盘子系统。</p>
</li>
<li><p>OLAP，也叫联机分析处理（Online Analytical Processing）系统，有的时候也叫DSS决策支持系统，就是我们说的数据仓库。<br>在这样的系统中，考核的标准往往是磁盘子系统的吞吐量（带宽），如能达到多少MB&#x2F;s的流量。</p>
</li>
</ul>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>对表上多个列进行索引。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>就是能从辅助索引中得到所有查询信息的记录。</p>
<h2 id="Multi-Range-Read优化"><a href="#Multi-Range-Read优化" class="headerlink" title="Multi-Range Read优化"></a>Multi-Range Read优化</h2><p>当表的数据非常多以至于无法放入缓存时，基于二级索引的范围扫描读取数据会造成较多的硬盘随机读。如果启用了MRR优化，MySQL首先会基于索引进行数据定位并收集满足条件的keys，然后再对这些keys进行排序，这样可以以主键的顺序进行表行的读取，能够减少随机读的数量。MRR优化的目的就是通过对keys排序后的一定程度的顺序读减少随机读的数量。</p>
<h3 id="ICP优化"><a href="#ICP优化" class="headerlink" title="ICP优化"></a>ICP优化</h3><p>在不启用 ICP 的情况下利用二级索引查找数据的过程：</p>
<ol>
<li>用二级索引查找数据的主键；</li>
<li>用主键回表读取完整的行记录；</li>
<li>利用 where 语句的条件对行记录进行过滤。</li>
</ol>
<p>启用 ICP 的情况下利用二级索引查找数据的过程为：</p>
<ol>
<li>用二级索引查找数据的主键；</li>
<li>如果二级索引记录的元组里的列出现在 where 条件里，那么对元组进行过滤；</li>
<li>对索引元组的主键回表读取完整的行记录；</li>
<li>利用 where 语句的剩余条件对行记录进行过滤；</li>
</ol>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>使用full inverted index实现，表现形式为{单词，（单词所在文档的ID，在具体文档中的位置）}</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB系列：表结构</title>
    <url>/2021/11/06/innodb%E7%B3%BB%E5%88%97%EF%BC%9A%E8%A1%A8/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h2><p><a href="/images/mysql-4.png"></a><br>如图所示，Innodb表结构由表空间，段，区，页组成。<br>默认所有数据在共享表空间ibdata1.</p>
<ol>
<li>段<br>常见的段有数据段，索引段，回滚段等等，在Innodb中存储引擎表由索引组织，数据就是索引，索引就是数据，因此数据段就是B+树的叶子节点，索引段就是B+树的非叶子节点。</li>
<li>区</li>
</ol>
<p>每个区的大小是1MB。一个页的大小是16K，因此一般一个区中有64个连续的页。</p>
<ol start="3">
<li>页</li>
</ol>
<p>也成为块（block），常见的页类型有：</p>
<ul>
<li>数据页（B-tree Node）</li>
<li>undo页（undo Log page）</li>
<li>系统页</li>
<li>事务数据页</li>
<li>插入缓冲位图页</li>
<li>插入缓冲空闲链表页</li>
<li>未压缩的二进制大对象页</li>
<li>压缩的二进制大对象页</li>
</ul>
<ol start="4">
<li>行</li>
</ol>
<p>每个页存放的行记录也是有硬性定义的，最多允许存放16KB&#x2F;2 - 200 &#x3D; 7992行的记录。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB系列：锁</title>
    <url>/2021/11/06/innodb%E7%B3%BB%E5%88%97%EF%BC%9A%E9%94%81/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="lock-和-latch的不同"><a href="#lock-和-latch的不同" class="headerlink" title="lock 和 latch的不同"></a>lock 和 latch的不同</h2><p><a href="/images/mysql-6.png"></a></p>
<h2 id="InnoDB锁的类型"><a href="#InnoDB锁的类型" class="headerlink" title="InnoDB锁的类型"></a>InnoDB锁的类型</h2><ul>
<li>共享锁（S Lock）：允许事务读一行数据。</li>
<li>排他锁（X Lock）：允许事务删除或更新一行数据。</li>
</ul>
<p>持有共享锁后还能获得共享锁，持有共享不能获得排他，持有排他不能获得其他锁。</p>
<p>还有两种意向锁</p>
<ul>
<li>意向共享锁（IS Lock）：事务想获得一张表中某几行的共享锁</li>
<li>意向排它锁（IX Lock）：事务想要获得一张表中某几行的排他锁<br><a href="/images/mysql-7.png"></a></li>
</ul>
<h2 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h2><p>如果读取的行正在执行update或者delete操作，读取操作不会等待行上的锁释放，而是读取行的以个快照数据。</p>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><ol>
<li>Record Lock：单个行记录的锁</li>
<li>Gap Lock：间隙锁，锁定一个范围，不包含本身</li>
<li>Next-Key Lock：1+2，锁定一个范围，包含本身</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s系列：pod</title>
    <url>/2022/02/17/k8s%E7%B3%BB%E5%88%97%EF%BC%9Apod%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><ul>
<li>概念：多个docker的集合，有一个pause容器，其他容器共享这个容器的网络栈和存储，这样多个应用可以实现本地访问其他应用。</li>
<li>分类<ul>
<li>自主式pod（不是被控制器管理的pod）</li>
<li>控制器管理的pod</li>
</ul>
</li>
</ul>
<h3 id="Pod控制器"><a href="#Pod控制器" class="headerlink" title="Pod控制器"></a>Pod控制器</h3><ul>
<li>Replication Controller&#x2F; ReplicaSet &#x2F; Deployment</li>
</ul>
<p>RC保证容器应用的副本始终保持在用户定义的副本数，如果容器异常，自动创建新的pod替代，异常多出来的容器也会自动回收。  </p>
<p>RS相比RC多了集合式的selector。  </p>
<p>Deployment支持滚动更新。</p>
<ul>
<li>StatefullSet<br><a href="/images/k8s-5.png"></a></li>
<li>DaemonSet<br><a href="/images/k8s-6.png"></a></li>
</ul>
<h3 id="pod网络通讯模式"><a href="#pod网络通讯模式" class="headerlink" title="pod网络通讯模式"></a>pod网络通讯模式</h3><ul>
<li>同个pod多个容器之间：同过共享pause容器，使用lo回环网卡即可。</li>
<li>pod之间：overlay network。</li>
<li>pod与service之间：节点之间的iptable规则。</li>
</ul>
<p>下图展示了利用flann eld组件进行转发的原理图，flanneld可以使整个网络扁平化：<br><a href="/images/k8s-7.png"></a></p>
<ol>
<li>假如webapp2想要访问backend，怎么同过内网ip进行通信？</li>
</ol>
<ul>
<li>首先webApp2发送数据到docker0</li>
<li>docker0数据经过flannel0网桥转发</li>
<li>flanneld存放有etcd的数据信息，会对数据包进行封装，如右图所示，首先写入目标主机mac地址，然后写入目标主机和本机的内网ip，通过udp协议传输到目标主机。</li>
<li>目标flanneld接受到数据包，进行逆向解封</li>
</ul>
<p>Q：etcd想flannel提供了什么数据？<br>A：1.存储管理flannel可分配的ip地址段资源。2.flannel监控每个pod的实际地址，在内存中建立维护pod节点路由表。</p>
<ol start="2">
<li><p>pod到Service的网络<br>目前基于性能考虑。全部为LVS维护和转发。</p>
</li>
<li><p>pod到外网</p>
</li>
</ol>
<p>pod向外网发送请求，查找路由表，转发数据包到宿主机网卡，宿主机网卡完成路由选择后，iptables执行masquerade，把源ip更改为宿主网卡的ip，然后向往往服务器发送请求。</p>
<ol start="4">
<li>外网访问pod：通过Service</li>
</ol>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s系列：基础概念</title>
    <url>/2022/02/17/k8s%E7%B3%BB%E5%88%97%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="borg系统"><a href="#borg系统" class="headerlink" title="borg系统"></a>borg系统</h3><p><a href="/images/k8s-1.png"></a></p>
<p>Master节点为奇数，scheduler向paxos写入数据，然后borglet监听到右自己的消息，就会执行命令。</p>
<h3 id="k8s架构"><a href="#k8s架构" class="headerlink" title="k8s架构"></a>k8s架构</h3><p><a href="/images/k8s-2.png"></a></p>
<p>和borg一样，但是中间加了一个apiserver层，etcd约等于paxos。</p>
<ul>
<li>scheduler：负责接收任务，选择合适的节点进行分配任务.</li>
<li>replication controller：负责控制node的副本数量，也就是删除或者创建pod.</li>
<li>apiserver：所有外界输入的入口，包括kubelet、kube proxy、replication controller、scheduler.</li>
<li>etcd：可信赖的分布式键值对数据库，存储k8s集群的所有重要信息，其内部结构如下图所示：<br><a href="/images/k8s-3.png"></a></li>
</ul>
<p>etcd使用http协议的c&#x2F;s架构，WAL是一种持久化策略，简单来说就是增量+完整备份，每一小段时间进行一个增量备份，每隔一大段时间进行完整备份，数据写入store中.</p>
<ul>
<li>kubelet：(CRI：container runtime interface)，操作docker，维护Pod的生命周期（pod运行在docker中）.</li>
<li>kube proxy：负责写入ipvs和iptables，执行负载均衡，实现pod和pod之间的通信.</li>
</ul>
<h3 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h3><ul>
<li>coreDNS：为集群中的SVC创建一个域名IP的对应关系解析。</li>
<li>dashboard：给k8s集群提供的B&#x2F;S访问体系。</li>
<li>ingress controller：官方只实现四层代理，ingress实现七层代理。</li>
<li>federation：提供一个可以跨集群中心多k8s统一管理功能。</li>
<li>prometheus：提供k8s集群的监控能力。</li>
<li>ELK：提供k8s日志统一管理平台。</li>
</ul>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s系列：资源和声明周期</title>
    <url>/2022/02/17/k8s%E7%B3%BB%E5%88%97%EF%BC%9A%E8%B5%84%E6%BA%90%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="集群资源分类"><a href="#集群资源分类" class="headerlink" title="集群资源分类"></a>集群资源分类</h3><ol>
<li>名称空间级别：默认为default</li>
<li>集群级别：role</li>
<li>元数据</li>
</ol>
<h3 id="pod资源清单"><a href="#pod资源清单" class="headerlink" title="pod资源清单"></a>pod资源清单</h3><p>定义一个pod需要下面这些信息：<br><a href="/images/k8s-8.png"></a></p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><a href="/images/k8s-8.png"></a></p>
<ol>
<li>初始化pause容器</li>
<li>init C 初始化容器，init容器总是运行到成功为止，并且后面的容器要等到前面的容器运行结束之后才运行。</li>
<li>进入容器，执行start操作。</li>
<li>readiness：就绪检测，如果服务就绪，可以暴露给外围。</li>
<li>liveness：生存检测，发现容器内部有假死（例如僵尸进程）时，进行重启或其他操作。</li>
<li>stop：结束时执行的一些操作。</li>
</ol>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>调度器负责管理pod的生命周期，在必要的时候重启pod，下图是deployment滚动更新的管理方式，称为命令式管理，在后台其实是通过管理RS来达到目的。<br><a href="/images/k8s-10.png"></a></p>
<p>这样存在一个问题，假如其中一个pod挂掉，RS重新启动一个pod替代，但是ip地址变了，那么其他pod访问不到怎么办？这个时候需要在pod和上层服务比如nginx中加入一个中间件SVC，SVC会自动进行服务发现，通过标签匹配策略自动获取其关联的pod的信息，然后同步给需要使用的pod。</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux启动全过程</title>
    <url>/2021/07/03/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<span id="more"></span>
<ol>
<li><p>BIOS启动</p>
<ul>
<li>上电自检，对设备的硬件进行一系列测试。</li>
<li>初始化硬件设备。</li>
<li>搜索一个操作系统来启动。</li>
<li>找到一个有效的设备，就把第一个扇区的内容拷贝到RAM中，从物理地址0x00007c00开始的位置，跳转到这个地址上，开始执行刚才装载的代码。</li>
</ul>
</li>
<li><p>从磁盘启动linux</p>
<ul>
<li>引导装入程序叫做linux loader（LILO），调用BIOS过程显示loading信息。</li>
<li>调用BIOS过程从磁盘装入内核映像的初始部分，即将内核映像的第一个512字节从地址0x00090000开始装入RAM，将setup代码从0x00092000装入RAM</li>
<li>调用BIOS过程从磁盘装载其余的内核映像。</li>
<li>调转到setup代码</li>
</ul>
</li>
<li><p>执行setup函数</p>
<ul>
<li>初始化物理内存分布表</li>
<li>初始化各种硬件设备</li>
<li>建立IDT和GDT</li>
<li>重新编写可编程中断控制器</li>
<li>跳转到startup_32 汇编函数</li>
</ul>
</li>
<li><p>startup_32函数</p>
<ul>
<li>初始化段寄存器和一个临时堆栈</li>
<li>解压内核映像</li>
<li>初始化内核页表</li>
<li>为进程0创建内核态堆栈，把从BIOS获得的系统参数和从做系统的参数放入第一个页框中。</li>
<li>填充GDTr和IDTr寄存器。</li>
<li>跳转到start_kernel</li>
</ul>
</li>
<li><p>start_kernel函数</p>
<ul>
<li>各种初始化（调度程序，内存管理，伙伴系统，软中断，系统日期和时间，slab分配器，CPU时钟速度）</li>
<li>为进程1创建内核线程。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo网络库：并发服务器设计</title>
    <url>/2021/09/14/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="常见并发服务器方案"><a href="#常见并发服务器方案" class="headerlink" title="常见并发服务器方案"></a>常见并发服务器方案</h3><ol>
<li>循环式&#x2F;迭代式服务器<br><img src="/images/muduo-1.png"></li>
</ol>
<p>整个服务器的流程是</p>
<ul>
<li>创建套接字，绑定监听。</li>
<li>在一个循环中执行：<ul>
<li>接受客户端连接</li>
<li>读</li>
<li>解码 处理 编码</li>
<li>写</li>
<li>关闭连接</li>
</ul>
</li>
<li>关闭连接</li>
</ul>
<p>这种连接方式实际上是短链接，而循环式服务器只能是短连接。整个程序是一个单线程的应用程序，不能是长连接的原因是因为如果需要进行长链接持续读，那么需要在写后在进行读，此时如果来一个新的连接请求就得不到响应。<br>另外整个连接处理过程不能太长，如果太长就会影响用户的响应时间。<br>总的来说这种方式具有下面几个缺点：</p>
<ul>
<li>不能进行长连接</li>
<li>不能处理复杂的业务请求</li>
<li>不能利用cpu多核优势</li>
</ul>
<ol start="2">
<li>cocurrent服务器<br><img src="/images/muduo-2.png"></li>
</ol>
<p>这个服务器的流程如上图所示，通过多进程的方式来处理多个客户端请求，并且可以处理长连接。</p>
<ol start="3">
<li><p>pre-fork or pre threaded<br><img src="/images/muduo-3.png"><br>这种称为预先创建线程或者进程的方式，每个进程或者线程负责一个客户端的请求。这种方式的一个缺点是会出现“惊群”现象。<br>所谓惊群现象，就是父进程创建socket，bind、listen后，通过fork创建多个子进程，每个子进程继承了父进程的socket，调用accpet开始监听等待网络连接。这个时候有多个进程同时等待网络的连接事件，当这个事件发生时，这些进程被同时唤醒，就是“惊群”。这样会导致什么问题呢？我们知道进程被唤醒，需要进行内核重新调度，这样每个进程同时去响应这一个事件，而最终只有一个进程能处理事件成功，其他的进程在处理该事件失败后重新休眠或其他。</p>
</li>
<li><p>reactor模式<br><img src="/images/muduo-4.png"></p>
</li>
</ol>
<ul>
<li>reactor可以使用select&#x2F;poll&#x2F;epoll来实现。</li>
<li>我们首先注册我们关注的监听套接字；</li>
<li>用客户端发来请求，acceptor来接受连接，然后将对应的文件描述符加入reactor中关注可读事件；</li>
<li>如果发生可读事件，开始dispatch（分派）；</li>
<li>然后进行业务逻辑的处理。</li>
</ul>
<p>以上所有的操作都是在单线程上完成的，因此不能处理较复杂的业务逻辑，也不能利用多核cpu的优势。</p>
<ol start="5">
<li>过渡方案</li>
</ol>
<ul>
<li>reactor + thread per request<br>每来一个请求，创建一个线程，在请求较多的情况下系统的负载显著上升。</li>
<li>reactor + worker thread<br>每个连接在一个工作者线程中完成，这种方式不如cocurrent方式，因为多了reactor。</li>
</ul>
<ol start="6">
<li><p>reactor + threadpool<br><img src="/images/muduo-5.png"><br>与reactor不同的地方是，将业务代码通过线程池来实现。<br>这种模式适用于计算密集型的业务。</p>
</li>
<li><p>mutiple reactors<br><img src="/images/muduo-5.png"><br>如上图所示，拥有一个mainReactor，当acceptor返回已连接套接字，就将活跃的套接字分配给subReactor。如果分配的顺序是按顺序，那么就叫做“轮叫”(round robin)，这种方式能够保证每个reactor都有均匀的任务数量。<br>每个进程或者线程拥有一个事件循环。（reactors in threads or reactors in process）。<br>这种方式能够应对更大的突发IO。<br>一个reactor能够应对一个千兆网卡，我们可以根据网卡数量来设计线程池或者进程池的容量。</p>
</li>
<li><p>mutiple reactors + thread pool<br><img src="/images/muduo-7.png"><br>这种方式也叫做one loop per thread + thread pool。<br>实际上在这种模式下，一共有两个线程池，一个是reactor的线程池，一个是业务线程的线程池。</p>
</li>
<li><p>proactor服务器（基于异步IO)<br>这种异步方式linux支持不够，暂不考虑。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>muduo</category>
      </categories>
      <tags>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>ndpi原理</title>
    <url>/2022/01/17/ndpi%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="整体原理"><a href="#整体原理" class="headerlink" title="整体原理"></a>整体原理</h2><ol>
<li>整体框架</li>
</ol>
<ul>
<li>包处理， 解析ip和基础端口信息</li>
<li>解析器插件，负责检测协议</li>
</ul>
<h2 id="nDPI改进机制"><a href="#nDPI改进机制" class="headerlink" title="nDPI改进机制"></a>nDPI改进机制</h2><ul>
<li>支持的协议越多，解析的参数越多，检测的时间越久。</li>
<li>在检测开始时一次性将所有协议初始化，无需运行过程的penalty。</li>
<li>流只解析一次，若第一次匹配不成功，保留流的解析信息。</li>
<li>针对未解析的流，nDPI先根据传输层协议类型和端口号，来猜测匹配的协议，提升匹配速度。</li>
<li>如果存在一个已经登记号的针对包的端口和协议的解析器，那就优先使用那个。</li>
<li>如果没有协议匹配这个包，那么后面的包页不会被检测。</li>
<li>一旦有协议匹配，那么就停止检测。</li>
<li>每个流需要检测的包的个数根据协议来确定，大多数是2~3个包，最多8个包。</li>
<li>使用Aho-Corasick算法来处理字符匹配。</li>
<li>内存使用：内存主要用于ndpi的配置和字符串的自动匹配，无自定义配置的情况下，使用210K内存，使用自定义配置时，会上升25KB。</li>
<li>记录每个流的信息，每个流大约占用1KB。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>redis系列：RDB &amp; AOF</title>
    <url>/2021/09/14/redis%E7%B3%BB%E5%88%97%EF%BC%9ARDB&amp;AOF/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><ol>
<li>文件结构<br><img src="/images/redis-ar-1.png"><br>一个完整的RDB文件包含上面各部分。</li>
</ol>
<ul>
<li>REDIS：5字节，检查是否为RDB文件。</li>
<li>db_version:4字节，字符串表示的整数，记录版本号。</li>
<li>database：0或n个数据库的键值对数据。</li>
<li>EOF：1字节，表示正文结束。</li>
<li>check_sum：8字节长无符号整数，保存一个校验和，根据前面四个部分计算得到。</li>
</ul>
<p>如下是一个有两个数据库的RDB文件。<br><img src="/images/redis-rdb-1.png"><br>每个数据库里面包含下面几个部分：<br><img src="/images/redis-rdb-2.png"></p>
<ul>
<li>SELECTDB：1字节，表示接下来是一个数据库号码；</li>
<li>db_number：数据库号码，1&#x2F;2&#x2F;5字节，当读入时，服务器根据select切换；</li>
<li>key_value_pairs：保存数据库中所有键值对数据。</li>
</ul>
<ol start="2">
<li>key_value_pairs<br>下图展示了一个不带过期时间的键值对：<br><img src="/images/redis-rdb-3.png"></li>
</ol>
<ul>
<li><p>TYPE：1字节类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Dup object types to RDB object types. Only reason is readability (are we</span></span><br><span class="line"><span class="comment"> * dealing with RDB types or with in-memory object types?). */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_RDB_TYPE_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_RDB_TYPE_LIST   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_RDB_TYPE_SET    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_RDB_TYPE_ZSET   3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_RDB_TYPE_HASH   4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object types for encoded objects. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_RDB_TYPE_HASH_ZIPMAP    9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_RDB_TYPE_LIST_ZIPLIST  10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_RDB_TYPE_SET_INTSET    11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_RDB_TYPE_ZSET_ZIPLIST  12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_RDB_TYPE_HASH_ZIPLIST  13</span></span><br></pre></td></tr></table></figure>
<p>带有过期时间的键值对：<br><img src="/images/redis-rdb-3.png"></p>
</li>
<li><p>EXPIRETIME_MS：1字节，表示接下来是一个时间。</p>
</li>
<li><p>ms：8字节带符号整数，过期时间，一个毫秒单位UNIX时间戳。</p>
</li>
</ul>
<ol start="3">
<li>value的编码</li>
</ol>
<ul>
<li><p>字符串对象：<br>存在压缩版<br><img src="/images/redis-rdb-6.png"><br>无压缩版<br><img src="/images/redis-rdb-5.png"></p>
</li>
<li><p>列表对象<br><img src="/images/redis-rdb-7.png"></p>
</li>
<li><p>集合对象<br><img src="/images/redis-rdb-8.png"></p>
</li>
<li><p>哈希表对象<br><img src="/images/redis-rdb-9.png"></p>
</li>
<li><p>有序集合对象<br><img src="/images/redis-rdb-10.png"></p>
</li>
<li><p>压缩列表<br>保存这种文件的方法是：（1）将压缩列表转换成一个字符串对象（2）将字符串对象保存到RDB文件。</p>
</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>简单来说AOF就是讲命令按顺序写入文件来持久化。<br>总的来说分为三个步骤：命令追加，文件写入，文件同步。</p>
<ul>
<li><p>命令追加<br>在redisServer结构体重有一个aof_buf缓冲区：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>AOF文件中是以命令请求协议格式保存的，因此命令追加是如下形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">redis&gt;SET KEY VALUE</span><br><span class="line"></span><br><span class="line">*<span class="number">3</span>\r\n$<span class="number">3</span>\r\nSET\r\nKEY\r\n$<span class="number">5</span>\r\nVALUE\r\n</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件写入<br>在服务器进程每次时间循环结束之前，可以考虑将aof缓冲区的数据写入文件。写入策略有：（1）always:将缓冲区所有内容写入并同步到AOF文件（2）everysec：将缓冲区所有内存写入AOF，如果上次同步AOF文件的时间超过1s，那么再次对AOF同步，并且由一个线程专门负责执行（3）写入AOF但不同步。<br>所谓同步，就是讲aof_buf拷贝到内核缓冲区，写入就是讲内核缓冲区的数据写入磁盘。这三种方式第一种最耗时但是最安全，第二种保证出现故障最多丢失1s的数据，最后一种方式写入最快但是不安全。</p>
</li>
<li><p>载入和数据还原<br>因为本身存的是命令，只需要再执行一遍命令就可以了，在读取AOF文件之后，redis创建一个伪客户端发出命令。</p>
</li>
<li><p>AOF重写<br>由于AOF文件记录所有命令，因此文件体积会迅速膨胀，因此redis提供对AOF文件重写功能。<br>核心思想就是，直接从数据库读取键值对，生成一条命令，来替代所记录的所有相关命令。<br>例如：<br><img src="/images/redis-aof-1.png"><br>可以用下面命令代替：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SELECT 0</span><br><span class="line">RPUSH alphabet &quot;a&quot; &quot;b&quot; &quot;c&quot;</span><br><span class="line">EXPIREAT alphabet 1385877600000</span><br><span class="line">HMSET book &quot;name&quot; &quot;Redisin Action&quot; &quot;author&quot; &quot;Josiah L. Carison&quot; &quot;publisher&quot; &quot;Manning&quot;</span><br><span class="line">EXPIREAT book 1388556000000</span><br><span class="line">SET message &quot;hello world&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果直接使用主线程来重写，势必会造成主线程长时间繁忙，无法处理用户请求，因此在实际实现中使用子进程来写。<br>使用子进程写的过程中，如果父进程对数据库进行修改，就回造成数据不一致问题，针对这个问题，redis设置了AOF重写缓冲区。<br><img src="/images/redis-aof-2.png"><br>在子进程执行重写的过程中，需要执行下面三个工作：<br>1）执行客户端的命令<br>2）将执行后的命令追加到AOF缓冲区<br>3）执行后的写命令追加到AOF重写缓冲区  </p>
<p>当子进程完成AOF重写，给父进程发一个信号，父进程接受信号之后，调用信号处理函数：<br>1)将AOF重写缓冲区所有内容写入新AOF，这时新AOF文件与当前数据库数据一致。<br>2）对新的AOF改名，原子性覆盖现有AOF文件。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis系列：动态字符串</title>
    <url>/2021/09/14/redis%E7%B3%BB%E5%88%97%EF%BC%9A%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="3-0版本"><a href="#3-0版本" class="headerlink" title="3.0版本"></a>3.0版本</h3><p>redis的动态字符串在3.0中的实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中len代表字符串的实际长度，free代表剩余可分配的长度，buf是一个动态数组。<br>redis之所以这么封装，有以下几点好处：</p>
<ol>
<li>常数复杂度获得字符串长度，即直接sdshdr.len即可；</li>
<li>有效防止缓冲区溢出，也就是说sdshdr记录了字符串长度和可用长度，在对字符进行拼接的时候，可以检查实际空间大小。</li>
<li>内存分配采用空间预分配和惰性释放策略，能够减少申请和释放内存的操作，减少系统负载。</li>
<li>buf存储的字符串是二进制安全的（所谓二进制安全，就是不访问不修改存储的二进制串，而传统的c字符串是通过判断’\0’字符来断定字符串结束，必然涉及到了字符串的访问，是不安全的。）。</li>
<li>兼容c字符串函数，可以将sdshr -&gt; buf作为字符串输入到c函数中。</li>
</ol>
<h3 id="5-0-版本"><a href="#5-0-版本" class="headerlink" title="5.0 版本"></a>5.0 版本</h3><p>在3.2版本之前的字符串都如上章节所示，这样能够满足基本的使用了，但是还有没有更好的改进空间呢？<br>我们从一个简单的问题开始思考：不同长度的字符串是否有必要占用相同大小的头部？一个int占4字节，在实际应用中，存放于Redis中的字符串往往没有这么长，每个字符串都用4字节存储未免太浪费空间了。我们考虑三种情况：短字符串，len和free的长度为1字节就够了；长字符串，用2字节或4字节；更长的字符串，用8字节。<br>这样确实更省内存，但依然存在以下问题。</p>
<p>问题1：如何区分这3种情况？  </p>
<p>问题2：对于短字符串来说，头部还是太长了。以长度为1字节的<br>字符串为例，len和free本身就占了2个字节，能不能进一步压缩呢？<br>对于问题1，我们考虑增加一个字段flags来标识类型，用最小的1<br>字节来存储，且把flags加在柔性数组buf之前，这样虽然多了1字节，<br>但通过偏移柔性数组的指针即能快速定位flags，区分类型，也可以接<br>受；对于问题2，由于len已经是最小的1字节了，再压缩只能考虑用位<br>来存储长度了。  </p>
<p>结合两个问题，5种type（长度1字节、2字节、4字节、8字节、小<br>于1字节）的SDS至少要用3位来存储类型（23 ＝8），1个字节8位，剩<br>余的5位存储长度，可以满足长度小于32的短字符串。在Redis 5.0<br>中，我们用如下结构来存储长度小于32的短字符串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1）len ：表示buf中已占用字节数。<br>2）alloc ：表示buf中已分配字节数，不同于free，记录的是为<br>buf分配的总长度。<br>3）flags ：标识当前结构体的类型，低3位用作标识位，高5位预<br>留。<br>4）buf ：柔性数组，真正存储字符串的数据空间。</p>
<p>sdshdr5结构如下图所示：<br><img src="/images/redis-sds-1.png"><br>设置flags成员，前三个bits来表示类型，后5个字节表示长度，最多能够表示0~31（2^5)。</p>
<p>而长度大于31的字符串，1个字节依然存不下。我们按之前的思<br>路，将len和free单独存放。sdshdr8、sdshdr16、sdshdr32和<br>sdshdr64的结构相同。下面是sds16的结构：<br><img src="/images/redis-sds-1.png"></p>
<p>这里为什么使用__attribute__ ((<strong>packed</strong>))关键字不进行内存对齐呢？</p>
<ul>
<li>节省内存</li>
<li>SDS返回给上层的，不是结构体首地址，而是指向内容的buf指针。因为此时按1字节对齐，故SDS创建成功后，无论是sdshdr8、sdshdr16还是sdshdr32，都能通过(char*)sh+hdrlen得到buf指针地址（其中hdrlen是结构体长度，通过sizeof计算得到）。修饰后，无论是sdshdr8、sdshdr16还是sdshdr32，都能通过buf[-1]找到flags，因为此时按1字节对齐。若没有packed的修饰，还需要对不同结构进行处理，实现更复杂。</li>
</ul>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>由于5.0版本的动态字符串通过不同的结构体实现，因此当涉及到修改动态字符串的相关操作时，可能需要更改类型。并且动态数组的增长也涉及了扩容机制。<br>扩容机制保留了3.0版本的惰性释放原则。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>缓存功能：String字符串是最常用的数据类型，不仅仅是Redis，各个语言都是最基本类型，因此，利用Redis作为缓存，配合其它数据库作为存储层，利用Redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。</li>
<li>计数器：许多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。</li>
<li>共享用户Session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存Cookie，但是可以利用Redis将用户的Session集中管理，在这种模式只需要保证Redis的高可用，每次用户Session的更新和获取都可以快速完成。大大提高效率。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis系列：压缩列表</title>
    <url>/2021/09/14/redis%E7%B3%BB%E5%88%97%EF%BC%9A%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>在3.0版本中基本结构如下图所示：<br><img src="/images/redis-zl-1.png"></p>
<p>源码通过宏定义来实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Utility macros */</span></span><br><span class="line"><span class="comment">//zlbytes</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"><span class="comment">// zltail</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br><span class="line"><span class="comment">//zl+8指向zllen字段</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</span></span><br><span class="line"><span class="comment">//zl+zltail指向尾元素首地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</span></span><br><span class="line"><span class="comment">//zlend</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>zlbytes： 压缩列表的字节长度，占4个字节，因此压缩列表最多有2^32 -1个字节。</li>
<li>zltail： 压缩列表尾元素相对于压缩列表起始地址的偏移量，占4个字节。</li>
<li>zllen： 压缩列表的元素个数，占2个字节。zllen无法存储元素个数超过65535（2^16 -1）的压缩列表，必须遍历整个压缩列表才能获取到元素个数。</li>
<li>entryX： 压缩列表存储的元素，可以是字节数组或者整数，长度不限。</li>
<li>zlend： 压缩列表的结尾，占1个字节，恒为0xFF。</li>
</ul>
<h3 id="节点的构成"><a href="#节点的构成" class="headerlink" title="节点的构成"></a>节点的构成</h3><p>压缩列表的节点组成如下所示：<br><img src="/images/redis-zl-2.png"></p>
<ul>
<li>previous_entry_length字段:<br>表示前一个元素的字节长度，占1个或者5个字节，当前一个元素的长度小于254字节时，用1个字节表示；当前一个元素的长度大于或等于254字节时，用5个字节来表示。而此时previous_entry_length字段的第1个字节是固定的0xFE，后面4个字节才真正表示前一个元素长度。</li>
<li>encoding字段:<br>表示当前元素的编码，即content字段存储的数据类型（整数或者字节数组），数据内容存储在content字段。</li>
<li>content字段：<br>负责保存节点的值，节点值可以是字节数组或者整数。<br>在redis中，压缩链表项如下定义：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize, prevrawlen;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize, len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>
回顾压缩列表元素的编码结构，可变因素实际上不止3个：previous_entry_length字段的长度（prevrawlensize）、previous_entry_length字段存储的内容（prevrawlen）、encoding字段的长度（lensize）、encoding字段的内容（len表示元素数据内容的长度，encoding表示数据类型）和当前元素首地址（p）；而headersize则表示当前元素的首部长度，previous_entry_length字段长度与encoding字段长度之和.</li>
</ul>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p><img src="/images/redis-zl-2.png"><br>简单来说就是增加或者删除元素的时候，对应的previous_entry_length会发生变化，当元素长度处于临界值的时候 </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis系列：raft一致性算法</title>
    <url>/2021/09/14/redis%E7%B3%BB%E5%88%97%EF%BC%9Araft%E5%92%8C%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h3><ol>
<li>基本概念<br>在任何时刻，服务器节点都处于三个状态之一：leader、follower或者candidate。</li>
</ol>
<ul>
<li>follwer：不会发送任何请求，只相应leader和candidate的请求；</li>
<li>leader：处理所有客户端请求，如果一个可会断和follower通信，那么follower会重定向给leader；</li>
<li>candidate：用来选举新leader。<br>下图展示了上面三种状态的转换：<br><img src="/images/redis-raft-1.png"></li>
</ul>
<p>Raft把时间分割成任意长度的任期，如下图所示：<br><img src="/images/redis-raft-2.png"></p>
<p>每一个服务器节点存储一个当前任期号，该编号随着时间单调递增。不同的服务器节点观察到的任期转换的次数可能不同，在某些情况下，一个服务器节点可能没有看到 leader 选举过程或者甚至整个任期全程。任期在 Raft 算法中充当逻辑时钟的作用，这使得服务器节点可以发现一些过期的信息比如过时的leader。</p>
<ul>
<li>如果一个服务器的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的那个值；</li>
<li>如果一个 candidate 或者 leader 发现自己的任期号过期了，它会立即回到 follower 状态；</li>
<li>如果一个节点接收到一个包含过期的任期号的请求，它会直接拒绝这个请求。</li>
</ul>
<ol start="2">
<li>Leader选举</li>
</ol>
<p>Raft 使用一种心跳机制来触发 leader 选举。<br>当服务器程序启动时，他们都是 follower。<br>如果一个 follower 在一段选举超时时间内没有接收到任何消息，它就假设系统中没有可用的 leader ，然后开始进行选举以选出新的 leader 。<br>选举的流程大概是：  </p>
<ul>
<li>follower 先增加自己的当前任期号并且转换到 candidate 状态。</li>
<li>投票给自己并且并行地向集群中的其他服务器节点发送 RequestVote RPC。</li>
<li>当一个 candidate 获得集群中过半服务器节点针对同一个任期的投票，它就赢得了这次选举并成为 leader。（投票按照先来先得的原则）。</li>
<li>在等待投票期间，candidate 可能会收到另一个声称自己是 leader 的服务器节点发来的 AppendEntries RPC 。如果这个 leader 的任期号（包含在RPC中）不小于 candidate 当前的任期号，那么 candidate 会承认该 leader 的合法地位并回到 follower 状态。 如果 RPC 中的任期号比自己的小，那么 candidate 就会拒绝这次的 RPC 并且继续保持 candidate 状态。</li>
<li>如果candidate 既没有赢得选举也没有输：如果有多个 follower 同时成为 candidate ，那么选票可能会被瓜分以至于没有 candidate 赢得过半的投票。当这种情况发生时，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，如果没有其他机制的话，该情况可能会无限重复。<br>为了避免选票瓜分，也就是follower都投票给自己，Raft使用随机选举超时时间来解决。选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后该服务器赢得选举并在其他服务器超时之前发送心跳。每个 candidate 在开始一次选举的时候会重置一个随机的选举超时时间，然后一直等待直到选举超时。</li>
</ul>
<h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>Leader 一旦被选举出来，就开始为客户端请求提供服务。客户端的每一个请求都包含一条将被复制状态机执行的指令。Leader 把该指令作为一个新的条目追加到日志中去，然后并行的发起 AppendEntries RPC 给其他的服务器，让它们复制该条目。  </p>
<p>每个日志条目存储一条状态机指令和 leader 收到该指令时的任期号。如下图所示：<br><img src="/images/redis-raft-3.png"><br>Leader 决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为已提交的。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。一旦创建该日志条目的 leader 将它复制到过半的服务器上，该日志条目就会被提交（例如在图中的条目 7）。<br>正常操作期间，leader 和 follower 的日志保持一致，所以 AppendEntries RPC 的一致性检查从来不会失败。然而，leader 崩溃的情况会使日志处于不一致的状态：<br><img src="/images/redis-raft-4.png"><br>Follower 可能缺少一些在新 leader 中有的日志条目，也可能拥有一些新 leader 没有的日志条目，或者同时发生。缺失或多出日志条目的情况可能会涉及到多个任期。  </p>
<ul>
<li>要使得 follower 的日志跟自己一致，leader 必须找到两者达成一致的最大的日志条目（索引最大），删除 follower 日志中从那个点之后的所有日志条目，并且将自己从那个点之后的所有日志条目发送给 follower。</li>
<li>Leader 针对每一个 follower 都维护了一个 nextIndex ，表示 leader 要发送给 follower 的下一个日志条目的索引。当选出一个新 leader 时，该 leader 将所有 nextIndex 的值都初始化为自己最后一个日志条目的 index 加1。如果 follower 的日志和 leader 的不一致，那么下一次 AppendEntries RPC 中的一致性检查就会失败。在被 follower 拒绝之后，leaer 就会减小 nextIndex 值并重试 AppendEntries RPC 。最终 nextIndex 会在某个位置使得 leader 和 follower 的日志达成一致。此时，AppendEntries RPC 就会成功，将 follower 中跟 leader 冲突的日志条目全部删除然后追加 leader 中的日志条目（如果有需要追加的日志条目的话）。一旦 AppendEntries RPC 成功，follower 的日志就和 leader 一致，并且在该任期接下来的时间里保持一致。</li>
</ul>
<h3 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h3><ol>
<li>选举限制<br>Raft 使用投票的方式来阻止 candidate 赢得选举除非该 candidate 包含了所有已经提交的日志条目。候选人为了赢得选举必须与集群中的过半节点通信，这意味着至少其中一个服务器节点包含了所有已提交的日志条目。如果 candidate 的日志至少和过半的服务器节点一样新（接下来会精确地定义“新”），那么他一定包含了所有已经提交的日志条目。RequestVote RPC 执行了这样的限制： RPC 中包含了 candidate 的日志信息，如果投票者自己的日志比 candidate 的还新，它会拒绝掉该投票请求。<br>Raft 通过比较两份日志中最后一条日志条目的索引值和任期号来定义谁的日志比较新。如果两份日志最后条目的任期号不同，那么任期号大的日志更新。如果两份日志最后条目的任期号相同，那么日志较长的那个更新。</li>
<li>提交之前任期内的日志条目<br>一旦当前任期内的某个日志条目已经存储到过半的服务器节点上，leader 就知道该日志条目已经被提交了。如果某个 leader 在提交某个日志条目之前崩溃了，以后的 leader 会试图完成该日志条目的复制。然而，如果是之前任期内的某个日志条目已经存储到过半的服务器节点上，leader 也无法立即断定该日志条目已经被提交了。图 8 展示了一种情况，一个已经被存储到过半节点上的老日志条目，仍然有可能会被未来的 leader 覆盖掉。<br><img src="/images/redis-raft-4.png"><br>如图的时间序列展示了为什么 leader 无法判断老的任期号内的日志是否已经被提交。在 (a) 中，S1 是 leader ，部分地复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 中通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，继续复制日志。此时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。但是，在崩溃之前，如果 S1 在自己的任期里复制了日志条目到大多数机器上，如 (e) 中，然后这个条目就会被提交（S5 就不可能选举成功）。 在这种情况下，之前的所有日志也被提交了。<br>为了消除图中描述的问题，Raft 永远不会通过计算副本数目的方式来提交之前任期内的日志条目。只有 leader 当前任期内的日志条目才通过计算副本数目的方式来提交；一旦当前任期的某个日志条目以这种方式被提交，那么由于日志匹配特性，之前的所有日志条目也都会被间接地提交。在某些情况下，领导人可以安全地断定一个老的日志条目已经被提交（例如，如果该条目已经存储到所有服务器上），但是 Raft 为了简化问题使用了一种更加保守的方法。<br>Raft 会在提交规则上增加额外的复杂性是因为当 leader 复制之前任期内的日志条目时，这些日志条目都保留原来的任期号。在其他的一致性算法中，如果一个新的 leader 要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 的做法使得更加容易推导出（reason about）日志条目，因为他们自始至终都使用同一个任期号。另外，和其他的算法相比，Raft 中的新 leader 只需要发送更少的日志条目（其他算法中必须在它们被提交之前发送更多的冗余日志条目来给它们重新编号）。</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis系列：哨兵和集群</title>
    <url>/2021/09/14/redis%E7%B3%BB%E5%88%97%EF%BC%9A%E5%93%A8%E5%85%B5%E5%92%8C%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>基本概念和详细流程见《Redis设计与实现》、《Redis5设计与源码分析》，只说下自己的理解。<br>下图是一个基本的主从复制的哨兵系统：<br><img src="/images/sen-1.png"><br>主要有三种角色：哨兵、主服务器，从服务器。</p>
<ul>
<li>哨兵：一种特殊的redis服务端，使用哨兵专用命令。用来监控主从状态，执行故障转移等。</li>
<li>主服务器：执行客户端请求，同步自身数据到从服务器。</li>
<li>从服务器：从主服务器同步数据。</li>
</ul>
<p>系统的重要逻辑点有：</p>
<ol>
<li>哨兵读入用户指定的配置文件，对每个要被监视的主服务器建立一个示例结构，然后创建连向主服务器的命令连接和订阅连接，命令用来向主服务器发送命令请求，订阅用来接受指定频道的消息。</li>
<li>哨兵向服务器发送INFO命令来获得主服务器及所有从服务器的地址信息，然后创建对应的实例。</li>
<li>哨兵每10s向主服务器和从服务器方发送INFO命令，如果判定主服务器下线，或者正在执行故障转移，频率增大到1s一次。</li>
<li>哨兵会对和自己同时监视主服务器的哨兵每2s通信一次（通信通过服务器的__sentinel__:hello中转传播），表示自己存在，同时也会接受其他哨兵的消息。</li>
<li>哨兵之间只有命令连接，哨兵和服务器之间有命令和订阅连接。</li>
<li>哨兵1s一次向主服务器，从服务器，哨兵节点发PING命令，根据回复判断在线状态，如果收到无效回复或没有回复，就判断此节点为主观下线。</li>
<li>判断主观下线之后，向其他哨兵询问，如果超过半数确认则判定为客观下线。</li>
<li>哨兵通过raft一致性算法选举出头哨兵，头哨兵执行故障转移操作。</li>
<li>故障转移通过在下线的主服务器的从服务器列表中来选择，选择状态良好，和主服务器通信时间最新，复制偏移量更大，ID更小的节点。</li>
<li>将此从服务器置为主服务器，原主服务器若上线则置为从服务器。</li>
</ol>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>基本概念和详细流程见《Redis设计与实现》、《Redis5设计与源码分析》，只说下自己的理解。<br>只阐述下主要流程：</p>
<ol>
<li>节点之间通过两两握手来讲其他节点添加到自己的集群中。其实就是在自己的数据结构上初始化节点结构体。</li>
<li>集群中的16384个槽分派给节点（<a href="https://haoqinx.github.io/2021/09/14/redis%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">为什么是16384个节点</a>）。</li>
<li>节点接受到一个命令请求，会使用CRC16(key) % 16384 来确定槽，如果不是自己负责，会自动重定向到正确的节点（怎么重定向？其实就是有一个数据，记录了每个槽对应的节点指针）。</li>
<li>重新分片的原理：见《Redis设计与实现》p266.</li>
<li>集群中的节点通过gossip协议通信，常见的消息有MEET,PING,PONG,PUBLISH,FAIL等。</li>
</ol>
<h3 id="单机模式，主从模式，哨兵模式，集群模式优缺点："><a href="#单机模式，主从模式，哨兵模式，集群模式优缺点：" class="headerlink" title="单机模式，主从模式，哨兵模式，集群模式优缺点："></a>单机模式，主从模式，哨兵模式，集群模式优缺点：</h3><ol>
<li>单机模式</li>
</ol>
<ul>
<li>优点：<ul>
<li>架构简单，部署方便</li>
<li>性价比高</li>
<li>性能高</li>
</ul>
</li>
<li>缺点：<ul>
<li>不保证数据可靠性</li>
<li>在缓存使用，进程重启之后容易丢失数据，不能解决缓存预热问题。（ps:缓存预热：新的缓存系统没有任何缓存数据，在缓存重建数据的过程中，系统性能和数据库负载都不太好，所以最好是在系统上线之前就把要缓存的热点数据加载到缓存中，这种缓存预加载手段就是预热。）</li>
</ul>
</li>
</ul>
<ol start="2">
<li>主从模式</li>
</ol>
<ul>
<li>优点：<ul>
<li>高可靠行：能够在主库主张自动切换从库</li>
<li>读写分离：从节点扩展读数据库的压力，只有主节点才能写</li>
</ul>
</li>
<li>缺点：<ul>
<li>故障恢复复杂，主节点出现异常，需要手动将从节点配置为主节点</li>
<li>主节点写能力有限，大量写容易宕机</li>
<li>主机单机存储有限</li>
<li>原生复制弊端（早期版本）：如：Redis 复制中断后，Slave 会发起 psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿;又由于 COW 机制，导致极端情况下的主库内存溢出，程序异常退出或宕机;主库节点生成备份文件导致服务器磁盘 IO 和 CPU(压缩)资源消耗;发送数 GB 大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>哨兵模式：</li>
</ol>
<ul>
<li><p>优点：</p>
<ul>
<li>Redis Sentinel 集群部署简单。</li>
<li>能够解决 Redis 主从模式下的高可用切换问题。</li>
<li>很方便实现 Redis 数据节点的线形扩展，轻松突破 Redis 自身单线程瓶颈，可极大满足 Redis 大容量或高性能的业务需求。</li>
<li>可以实现一套 Sentinel 监控一组 Redis 数据节点或多组数据节点。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>是一种中心化的集群实现方案：始终只有一个Redis主机来接收和处理写请求，写操作受单机瓶颈影响。</li>
<li>集群里所有节点保存的都是全量数据，浪费内存空间，没有真正实现分布式存储。数据量过大时，主从同步严重影响master的性能。</li>
<li>Redis主机宕机后，哨兵模式正在投票选举的情况之外，因为投票选举结束之前，谁也不知道主机和从机是谁，此时Redis也会开启保护机制，禁止写操作，直到选举出了新的Redis主机。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>集群模式</li>
</ol>
<ul>
<li><p>优点：</p>
<ul>
<li>无中心架构。数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li>
<li>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除。</li>
<li>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>Key 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 Key 分布于不同的节点上时无法使用事务功能。</li>
<li>Key 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。</li>
<li>不支持多数据库空间，单机下的 redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis系列：复制</title>
    <url>/2021/09/14/redis%E7%B3%BB%E5%88%97%EF%BC%9A%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="完全复制"><a href="#完全复制" class="headerlink" title="完全复制"></a>完全复制</h3><ul>
<li>第一步是同步<br>1）从服务器向主服务器发送SYNC命令。<br>2）收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。<br>3）BGSAVE命令执行完毕后，将生成的RDB文件传输给从服务器，从服务器接收到开始更新。<br>4）主服务器将记录在缓冲区的所有写命令发送给从服务器，从服务器状态更新。<br>如下图示例所示：<br><img src="/images/redis-sync-1.png"></li>
<li>命令传播<br>主服务器将更改服务器状态的命令发送给从服务器。</li>
</ul>
<h3 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h3><p>完全复制在效率上比较低，应为每次都需要生成RDB文件，从服务器也需要从RDB恢复数据。因此考虑部分复制，在非第一次同步的情况下，只传播断线过程中执行的更改主服务器状态的命令。如下图所示：<br><img src="/images/redis-sync-2.png"><br>部分同步的实现有三个部分</p>
<ul>
<li>主服务器的复制偏移量和从服务器的复制偏移量。</li>
<li>主服务器的复制积压缓冲区。</li>
<li>服务器的运行ID。</li>
</ul>
<ol>
<li>复制偏移量<br>主服务器每次传输N个字节数据，就将复制偏移量+N，从服务器收到N个字节，就加N，通过复制偏移量就可以知道是否是同步状态。</li>
<li>积压缓冲区<br>复制积压缓冲区维护一个固定长度的队列，大小为1MB。固定长度就是说队列的长度是固定的，如果入队后队列长度超过固定值，就将多余的值弹出。队列会保存字节的复制偏移量和字节内容。<br><img src="/images/redis-sync-3.png"></li>
</ol>
<h3 id="复制的实现"><a href="#复制的实现" class="headerlink" title="复制的实现"></a>复制的实现</h3><p>通过向从服务器发送SLAVEOF命令，可以让从服务器复制一个主服务器。</p>
<ul>
<li>设置主服务器地址和端口<br>从服务器需要首先保存主服务器的地址和端口。</li>
<li>建立套接字连接</li>
<li>发送ping命令<br>有两个作用：<br>1）检查套接字读写是否正常。<br>2）检查主服务器是否能正产处理请求。<br>如果返回一个命令回复但从服务器无法在规定时间内读取命令回复的内容，那么表示网络连接异常。如果返回一个错误，那么主服务器无法处理。</li>
<li>身份验证  </li>
<li>发送端口数据</li>
<li>同步</li>
<li>命令传播</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis系列：字典</title>
    <url>/2021/09/14/redis%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="3-0哈希表"><a href="#3-0哈希表" class="headerlink" title="3.0哈希表"></a>3.0哈希表</h3><p>下面是哈希表结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<ul>
<li>table是一个数组</li>
<li>size记录哈希表的大小，也就是table数组的大小</li>
<li>used记录了哈希表目前已有节点的数量</li>
<li>sizemask &#x3D; size - 1<br>形式如下图所示：<br><img src="/images/redis-ht-1.png"></li>
</ul>
<p>哈希表节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<ul>
<li>key保存键</li>
<li>v保存键值对的值，可以是指针，或者uint64_t整数或者一个int64_t整数。</li>
<li>next指向另一个哈希表节点的指针，由此可以看出，redis使用链表法来解决冲突<br>下图展示了一个冲突的哈希表：<br><img src="/images/redis-ht-2.png"></li>
</ul>
<h3 id="3-0字典"><a href="#3-0字典" class="headerlink" title="3.0字典"></a>3.0字典</h3><ol>
<li>基本数据结构<br>数据结构如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数 </span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="comment">//销毁键</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁值</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>type属性和privdata是针对不同类型的键值对，为创建多态字典设置的</li>
<li>dictType是一族绑定特定类型键值对的函数族，privdata是这些函数的可选参数</li>
<li>ht是两个哈希表，ht[1]只会在ht[0]rehash的时候使用</li>
<li>rehashidx 记录rehash进度，如果没有rehash就为-1<br>下面是一个正常状态下的字典<br><img src="/images/redis-ht-3.png"></li>
</ul>
<ol start="2">
<li>插入哈希表</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hash = dict -&gt; type -&gt; hashFunction(key);</span><br><span class="line"></span><br><span class="line">index = hash &amp; dict -&gt; ht[x].sizemask;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先使用定义的哈希函数计算键的哈希值</li>
<li>然后使用与操作将hash掩码到长度范围内</li>
</ul>
<ol start="3">
<li>解决键冲突</li>
</ol>
<p>使用链表法解决冲突，一个优化是将新添加的键值对插入到链表的头部。</p>
<ol start="3">
<li>rehash</li>
</ol>
<ul>
<li>为字典的ht[1]哈希表分配空间<ul>
<li>如果是扩展操作，那么sizeof ht[1] &#x3D; min(n),2^n &gt;&#x3D; ht[0].used * 2;</li>
<li>如果是收缩操作，sizeof ht[1] &#x3D; min(n), 2^n &gt;&#x3D; ht[0].used</li>
</ul>
</li>
<li>将保存在ht[0]的所有键值对重哈希到ht[1]</li>
<li>释放ht[0]，ht[0] &#x3D; ht[1], h1 &#x3D; empty.</li>
</ul>
<ol start="4">
<li>哈希表的收缩扩张条件（满足下列条件之一即可）<br>负载因子：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>服务器没有在执行BGSAVE或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1</li>
<li>服务器目前正在执行这两个命令，并且哈希表的负载因子大于等于5.</li>
</ul>
<ol start="4">
<li>渐进式rehash</li>
</ol>
<ul>
<li>为ht[1]分配空间</li>
<li>维护rehashidx，并设置为0</li>
<li>在rehash期间，对字典添加删除，查找或者更新，都在ht[1]中进行，还需要将当前rehashidx对应的ht[0]的所有键值对rehash到ht[1]，然后rehashidx + 1</li>
<li>当所有键值对完成哈希后，rehashidx设置为-1</li>
</ul>
<h3 id="5-0版本"><a href="#5-0版本" class="headerlink" title="5.0版本"></a>5.0版本</h3><ol>
<li>hash函数</li>
</ol>
<ul>
<li>服务端的hash函数使用的是siphash算法</li>
<li>客户端使用的是times_33函数</li>
</ul>
<ol start="2">
<li>基本结构和3.0无太大变化，增加了iterators字段<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></li>
<li>迭代器遍历</li>
</ol>
<p>iterators字段，用来记录当前运行的安全迭代器数，当有安全迭代器绑定到该字典时，会暂停rehash操作。Redis很多场景下都会用到迭代器，例如：行keys命令会创建一个安全迭代器，此时iterators会加1，命令执行完毕则减1，而执行sort命令时会创建普通迭代器，该字段不会改变.<br>字典迭代器主要用于迭代字典这个数据结构中的数据，既然是迭代字典中的数据，必然会出现一个问题，迭代过程中，如果发生了数据增删，则可能导致字典触发rehash操作，或迭代开始时字典正在进行rehash操作，从而导致一条数据可能多次遍历到。那Redis如何解决这个问题呢？<br><font color = orange>普通迭代器通过指纹字段，每次迭代就会检查字典是否改变，如果改变（增删改查rehash）直接退出。安全迭代器通过设置标志位，设置完之后，rehash函数检查标志位后不会进行rehash，但是可以进行增删改查操作。</font></p>
<p>数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span></span><br><span class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></span><br><span class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></span><br><span class="line"><span class="comment"> * should be called while iterating. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="type">long</span> index;</span><br><span class="line">    <span class="type">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>
<ul>
<li>d：迭代的字典</li>
<li>index：当前迭代的索引值</li>
<li>table，safe：table为正在迭代的Hash表，即ht[0]与ht[1]，safe用于表示当前创建的是否为安全迭代器</li>
<li>entry，nextentry：当前和下一个节点</li>
<li>fingerprint：字典的指纹，随字典改变而变</li>
</ul>
<p>简单介绍完迭代器的基本结构、字段含义及API，我们来看下Redis如何解决增删数据的同时不出现读取数据重复的问题。Redis为单进程单线程模式，不存在两个命令同时执行的情况，因此只有当执行的命令在遍历的同时删除了数据，才会触发前面的问题。我们把迭代器遍历数据分为两类：</p>
<ul>
<li>普通迭代器，只遍历数据:<br>普通迭代器迭代字典中数据时，会对迭代器中fingerprint字段的值作严格的校验，来保证迭代过程中字典结构不发生任何变化，确保读取出的数据不出现重复。主要步骤如下：</li>
</ul>
<ol>
<li>调用dictGetIterator函数初始化一个普通迭代器，此时会把iter-&gt;safe值置为0，表示初始化的迭代器为普通迭代器；</li>
<li>循环调用dictNext函数依次遍历字典中Hash表的节点，首次遍历时会通过<br>dictFingerprint函数拿到当前字典的指纹值；</li>
<li>当调用dictNext函数遍历完字典Hash表中节点数据后，释放迭代器时会继续调用dictFingerprint函数计算字典的指纹值，并与首次拿到的指纹值比较，不相等则输出异常”&#x3D;&#x3D;&#x3D;ASSERTION FAILED&#x3D;&#x3D;&#x3D;”，且退出程序执行。</li>
</ol>
<ul>
<li>安全迭代器，遍历的同时删除数据：安全迭代器和普通迭代器迭代数据原理类似，也是通过循环调用dictNext函数依次遍历字典中Hash表的节点。安全迭代器确保读取数据的准确性，不是通过限制字典的部分操作来实现的，而是通过限制rehash的进行来确保数据的准确性，因此迭代过程中可以对字典进行增删改查等操作。主要步骤如下：</li>
</ul>
<ol>
<li>调用dictGetSafeIterator函数初始化一个安全迭代器，此时会把iter-&gt;safe值置为1，表示初始化的迭代器为安全迭代器；</li>
<li>循环调用dictNext函数依次遍历字典中Hash表的节点，首次遍历时会把字<br>典中iterators字段进行加1操作，确保迭代过程中渐进式rehash操作会被中断执行;</li>
<li>当调用dictNext函数遍历完字典Hash表中节点数据后，释放迭代器时会把<br>字典中iterators字段进行减1操作，确保迭代后渐进式rehash操作能正常进行。</li>
</ol>
<h3 id="间断遍历"><a href="#间断遍历" class="headerlink" title="间断遍历"></a>间断遍历</h3><p>为了解决在海量数据遍历时，造成的短暂的redis不可用。<br>函数原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">dictScan</span><span class="params">(dict *d,</span></span><br><span class="line"><span class="params">                       <span class="type">unsigned</span> <span class="type">long</span> v,</span></span><br><span class="line"><span class="params">                       dictScanFunction *fn,</span></span><br><span class="line"><span class="params">                       dictScanBucketFunction* bucketfn,</span></span><br><span class="line"><span class="params">                       <span class="type">void</span> *privdata)</span></span><br></pre></td></tr></table></figure>
<p>dictScan函数间断遍历字典过程中会遇到如下3种情况。<br>1）从迭代开始到结束，散列表没有进行rehash操作。<br>2）从迭代开始到结束，散列表进行了扩容或缩容操作，且恰好为两次迭代间隔期间完成了rehash操作。<br>3）从迭代开始到结束，某次或某几次迭代时散列表正在进行rehash操作。</p>
<ol>
<li>遍历过程中始终未遇到rehash操作</li>
</ol>
<p>每次迭代都没有遇到rehash操作，也就是遍历字典只遇到第1或第2种情况。其实第1种情况，只要依次按照顺序遍历Hash表ht[0]中节点即可，第2种情况因为在遍历的整个过程中，期间字典可能发生了扩容或缩容操作，如果依然按照顺序遍历，则可能会出现数据重复读取的现象.<br>Redis为了做到不漏数据且尽量不重复数据，统一采用了一种叫作reverse binary iteration的方法来进行间断数据迭代，接下来看下其主要源码实现，迭代的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">m0 = t0-&gt;sizemask;</span><br><span class="line">de = t0-&gt;table[v &amp; m0];<span class="comment">//避免缩容后游标超出Hash表最大值</span></span><br><span class="line"><span class="keyword">while</span> (de) &#123;<span class="comment">//循环遍历当前节点的单链表</span></span><br><span class="line">    next = de-&gt;next;</span><br><span class="line">    fn(privdata, de);<span class="comment">//依次将节点中键值对存入privdata字段中的单链表</span></span><br><span class="line">    de = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了兼容迭代间隔期间可能发生的缩容与扩容操作，每次迭代时都会对v变量（游标值）进行修改，以确保迭代出的数据无遗漏，游标具体变更算法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v |= ~m0;</span><br><span class="line">v = rev(v);<span class="comment">// 二进制逆转</span></span><br><span class="line">v++;</span><br><span class="line">v = rev(v);<span class="comment">//二进制逆转</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>遍历过程中遇到rehash操作<br>大小两表并存，所以需要从ht[0]和ht[1]中都取出数据，整个遍历过程为：先找到两个散列表中更小的表，先对小的Hash表遍历，然后对大的Hash表遍历，迭代的代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">t0 = &amp;d-&gt;ht[<span class="number">0</span>];t1 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (t0-&gt;size &gt; t1-&gt;size) &#123;</span><br><span class="line">t0 = &amp;d-&gt;ht[<span class="number">1</span>];t1 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">m0 = t0-&gt;sizemask;m1 = t1-&gt;sizemask;</span><br><span class="line">de = t0-&gt;table[v &amp; m0];</span><br><span class="line"><span class="keyword">while</span> (de) &#123;<span class="comment">/*迭代第一张小Hash表*/</span></span><br><span class="line">    next = de-&gt;next;</span><br><span class="line">    fn(privdata, de);</span><br><span class="line">    de = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;<span class="comment">/*迭代第二张大Hash表*/</span></span><br><span class="line">    de = t1-&gt;table[v &amp; m1];</span><br><span class="line">    <span class="keyword">while</span> (de) &#123;</span><br><span class="line">        next = de-&gt;next;</span><br><span class="line">        fn(privdata, de);</span><br><span class="line">        de = next;</span><br><span class="line">    &#125;</span><br><span class="line">    v |= ~m1;v = rev(v); v++; v = rev(v);</span><br><span class="line">&#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br></pre></td></tr></table></figure>
<font color = orange> 这套算法能满足这样的特点，主要是巧妙地利用了扩容及缩容正好为整数倍增长或减<br>少的原理，根据这个特征，很容易就能推导出同一个节点的数据扩容&#x2F;缩容后在新的Hash<br>表中的分布位置，从而避免了重复遍历或漏遍历。</font></li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis系列：数据库的实现</title>
    <url>/2021/09/14/redis%E7%B3%BB%E5%88%97%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="服务端数据库"><a href="#服务端数据库" class="headerlink" title="服务端数据库"></a>服务端数据库</h3><p>redis中将所有的数据库信息保存在redisServer结构体中，结构体中的变量有两百多个，这里就不写了。<br>主要的结构成员是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    redisDb* db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>db成员指向一个redisDb数组，数组长度有dbnum决定：<br><img src="/images/redis-db-1.png"><br>默认情况下，目标数据库是0号数据库。如果需要更换数据库，修改指针即可。</p>
<h3 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h3><p>redisDb结构体中保存了数据库中所有的键值对，因此将这个字典称为键空间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    dict* dict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>键空间中的键是数据库的键，每个键都是一个字符串对象</li>
<li>键空间中的值是数据库的值，每个值可以是一个字符串对象，列表对象，哈希表对象，集合对象，有序集合对象中的一种。<br>表示如下图所示：<br><img src="/images/redis-db-2.png"></li>
</ul>
<h3 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h3><ul>
<li>读取一个键之后，服务器会更新键的LRU时间，这个可以用于计算键的闲置时间。</li>
<li>如果在读取一个键时发现已经过期，服务器会删除这个过期键然后执行其他操作。</li>
<li>如果客户端使用watch命令监视了某个键，会将这个键标记为脏，从而让事务程序注意到这个键已经被修改过。</li>
<li>每次修改键之后，都会对脏键计数器加1，计数器会出发服务器的持久化和复制操作。</li>
<li>如果开启数据库通知，在对键修改之后，服务器将按配置发送相应的数据库通知。</li>
</ul>
<h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><p>redisDb结构的expires字典保存了数据库所有键的过期时间，称为过期字典。<br><img src="/images/redis-db-3.png"></p>
<ul>
<li>设置过期时间通过向过期字典添加键值对实现。</li>
<li>删除过期时间则直接在过期字典中移除，移除策略有三种：</li>
</ul>
<ol>
<li>定时删除，创建过期时间的同时创建一个定时器，让定时器在键的过期时间删除；</li>
<li>惰性删除，每次获取键的时候检查是否过期；</li>
<li>定期删除，每隔一段时间主动删除过期键。</li>
</ol>
<h3 id="AOF-x2F-RDB和复制功能对过期键的处理"><a href="#AOF-x2F-RDB和复制功能对过期键的处理" class="headerlink" title="AOF&#x2F;RDB和复制功能对过期键的处理"></a>AOF&#x2F;RDB和复制功能对过期键的处理</h3><ol>
<li>RDB</li>
</ol>
<ul>
<li>生成RDB文件时从数据库检查，过期不写入。</li>
<li>载入RDB文件时：<ul>
<li>主服务器模式下会对所有键进行检查，过期忽略。</li>
<li>从服务器模式会将所有键载入，不检查。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>AOF</li>
</ol>
<ul>
<li>生成AOF：当服务器以AOF持久化模式运行时，如果某个键过期，但还没有被删除时，不会对AOF文件产生影响。当过期键被删除之后，程序会向AOF文件追加一条DEL命令，显式地记录该键已被删除。</li>
<li>重写：进行键过期检查，过期则不写。</li>
</ul>
<ol start="3">
<li>复制</li>
</ol>
<ul>
<li>主服务器删除，向从服务器发送DEL命令。</li>
<li>从服务器执行读命令，忽略键过期。</li>
<li>从服务器接到DEL删除键。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis系列：跳跃表</title>
    <url>/2021/09/14/redis%E7%B3%BB%E5%88%97%EF%BC%9A%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">//分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">//前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p><img src="/images/redis-zlist-1.png"></p>
<ul>
<li>score是一个double类型树，跳表中所有节点按照分值排序</li>
<li>obj（5.0版本为ele）:存储一个sds类型对象</li>
</ul>
<h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><ol>
<li>节点层高</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZSKIPLIST_P 0.25 <span class="comment">/* Skiplist P = 1/4 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">zslRandomLevel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">    level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>level的初始值为1，通过while循环，每次生成一个随机值，取这个值的低16位作为x，当x小于0.25倍的0xFFFF时，level的值加1；否则退出while循环。最终返回level和ZSKIPLIST_MAXLEVEL两者中的最小值。<br>1）节点层高为1的概率为(1-p)。<br>2）节点层高为2的概率为p(1-p)。<br>3）节点层高为3的概率为p2 (1-p)。<br>4）……<br>5）节点层高为n的概率为pn-1 (1-p)。<br>节点期望层高为<font color = red> E &#x3D; 1 &#x2F; (1 - p) </font>.</p>
<ol start="2">
<li>创建跳跃表</li>
</ol>
<p>1）创建跳跃表结构体对象zsl。<br>2）将zsl的头节点指针指向新创建的头节点。<br>3）跳跃表层高初始化为1，长度初始化为0，尾节点指向NULL。  </p>
<ol start="3">
<li>插入节点</li>
</ol>
<ul>
<li>查找要插入的位置</li>
<li>调整跳跃表高度</li>
<li>插入节点</li>
<li>调整backward</li>
</ul>
<p>源代码中的大概思路就是通过for循环来对每个高度进行遍历，找到前驱和后继节点，通过rank和update两个数组记录，最后调整指针。</p>
<ol start="4">
<li>删除节点</li>
</ol>
<ul>
<li>查找需要更新的节点</li>
<li>设置span和forward</li>
</ul>
<h3 id="跳跃表应用"><a href="#跳跃表应用" class="headerlink" title="跳跃表应用"></a>跳跃表应用</h3><p>跳跃表主要应用于有序集合的底层实现（有序集合的另一种实现方式为压缩列表）。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 权限修改错误深坑</title>
    <url>/2021/09/14/ubuntu%E6%B7%B1%E5%9D%91%EF%BC%9A%E6%9D%83%E9%99%90%E5%92%8C%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="使用vim-修改了-x2F-etc-x2F-sudoers-下的sudoers，导致无法鉴权。"><a href="#使用vim-修改了-x2F-etc-x2F-sudoers-下的sudoers，导致无法鉴权。" class="headerlink" title="使用vim 修改了&#x2F;etc&#x2F;sudoers 下的sudoers，导致无法鉴权。"></a>使用vim 修改了&#x2F;etc&#x2F;sudoers 下的sudoers，导致无法鉴权。</h3><p>这两天在嵌入式linux上搞网络编程，发现ubuntu设置的防火墙把端口屏蔽了，想手动打开，普通用户提权的时候不小心用vim修改了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/sudoers</span><br></pre></td></tr></table></figure>
<p>文件，导致内核解析的时候出错了:<br><img src="/images/sudo-1.png"></p>
<p>这时候出现了一个悖论：</p>
<ol>
<li>我想把sudoers修改回去，但是需要sudo权限</li>
<li>sudoers解析错误，没办法sudo</li>
</ol>
<p>造成了死锁…. 于是求助广大网友，万能网友一个骚操作成功化解，其原理至今未解：</p>
<ol>
<li><p>使用ctrl+alt+F2 打开另外一个tty</p>
</li>
<li><p>在第一个tty执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $$</span><br></pre></td></tr></table></figure>
<p>获取tty的pid</p>
</li>
<li><p>在第二个tty执行 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkttyagent --process &#123;pid&#125; </span><br></pre></td></tr></table></figure>
<p>这时第二个会卡住</p>
</li>
<li><p>返回第一个执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkexec visudo</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，第二个终端也卡主，回到第一个终端，会提示输入当前用户密码</p>
</li>
<li><p>输入完密码，第一个终端卡主了，回到第二个终端，会发现，出现了sudoers的内容，编辑出错的地方，保存即可。</p>
</li>
<li><p>完成任务，修改完成，发现就可以继续使用sudo命令了，over</p>
</li>
</ol>
<h3 id="循环登录"><a href="#循环登录" class="headerlink" title="循环登录"></a>循环登录</h3><p>在嵌入式linux系统里面又遇到下面这种情况：输入密码进入ubuntu后不一会闪退，需要重新输入密码，然后陷入循环…</p>
<p>试了很久，猜想系统扫描某些配置文件需要sudo权限，而普通用户无权限：</p>
<ol>
<li>使用ctrl + alt + F1进入命令行界面</li>
<li>进入&#x2F;etc&#x2F;passwd 文件修改用户组为0:0，提升到root权限</li>
<li>重新登录神奇的好了，但是登录需要选择用户了(以前直接默认普通用户登录，现在可以直接root登录)</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>洗牌算法</title>
    <url>/2021/12/25/%E4%B8%89%E7%A7%8D%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>从n个元素中选出m个</p>
<h2 id="Fisher-Yates-Shuffle"><a href="#Fisher-Yates-Shuffle" class="headerlink" title="Fisher-Yates Shuffle"></a>Fisher-Yates Shuffle</h2><p>假设待选元素数组N， 此算法核心思想为每次选一个，然后把此元素从数组删除。</p>
<h2 id="Knuth-Durstenfeld-Shuffle"><a href="#Knuth-Durstenfeld-Shuffle" class="headerlink" title="Knuth-Durstenfeld Shuffle"></a>Knuth-Durstenfeld Shuffle</h2><p>是方法一的改进，由于方法一删除通常会伴随内存从新分配或者元素重新排列或者辅助空间，因此方法二将删除改为每次选一个之后，跟最后面的元素交换，然后减少选的范围。</p>
<h2 id="Inside-Out-Algorithm"><a href="#Inside-Out-Algorithm" class="headerlink" title="Inside-Out Algorithm"></a>Inside-Out Algorithm</h2><p>由于方法二需要额外的空间存储整个元素数组，此方法改进为遍历数组然后每次将i元素跟0~i元素交换。  </p>
<p>如果知道arr的lengh的话，可以改为for循环，由于是从前往后遍历，所以可以应对arr[]数目未知的情况，或者arr[]是一个动态增加的情况。</p>
<h2 id="蓄水池抽样"><a href="#蓄水池抽样" class="headerlink" title="蓄水池抽样"></a>蓄水池抽样</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reservoir_Sampling</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; arr.<span class="built_in">size</span>(); ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">		k = <span class="built_in">rand</span>() % (i + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (k &lt; M)</span><br><span class="line">			<span class="built_in">swap</span>(arr[k], arr[i]); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从伪代码很容易理解，就是从第m个元素开始，以（i + 1)为界生成随机数，如果随机数小于m,则交换两个元素。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C++的一些误解</title>
    <url>/2020/10/31/%E5%85%B3%E4%BA%8Ec++%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%AF%E8%A7%A3/</url>
    <content><![CDATA[<p>关于C++的一些误解</p>
<span id="more"></span>
<ol>
<li>关于C++默认构造函数的一些误解</li>
</ol>
<ul>
<li>当我们没有声明类的默认构造函数时，编译器会默认给我们生成默认构造函数？<ul>
<li>错误，在下面四种情况下会生成默认构造：<ul>
<li>带有默认构造函数的成员对象</li>
<li>带有默认构造函数的基类</li>
<li>带有虚函数的类</li>
<li>有虚继承的类</li>
</ul>
</li>
</ul>
</li>
<li>如果没有声明类的默认构造函数，编译器会给我们类的成员变量例如整型，指针等初始化？<ul>
<li>错误，编译器只生成其需要的用户自定义类的默认构造，对变量不初始化，这些活儿是程序员自己的事。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>C++ 初始化列表是按照列表中的顺序初始化的吗？</li>
</ol>
<ul>
<li>错误，初始化顺序是按照类中定义的顺序。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> val):<span class="built_in">j</span>(val),<span class="built_in">i</span>(j)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a.j &lt;&lt; endl;  <span class="comment">//程序输出：32767 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>redis系列：对象大总结（字符串，列表，哈希，集合，有序集合底层结构）</title>
    <url>/2021/09/14/redis%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="对象类型和编码"><a href="#对象类型和编码" class="headerlink" title="对象类型和编码"></a>对象类型和编码</h3><p>在redis中，并没有使用之前学到的数据结构来直接构建数据库，而是基于这些数据结构构建了一个对象系统，这个系统包含了字符串对象，列表对象，哈希对象，集合对象和有序集合对象五种类型。<br>在redis中，对象的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The actual Redis Object */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LRU_BITS 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LRU_CLOCK_MAX ((1<span class="string">&lt;&lt;REDIS_LRU_BITS)-1) /* Max value of obj-&gt;</span>lru */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LRU_CLOCK_RESOLUTION 1000 <span class="comment">/* LRU clock resolution in ms */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>对象宏定义如下：<br><img src="/images/redis-obj-1.png"><br>对象的ptr指针指向了这个对象的底层数据结构，这些数据结构由对象的encoding属性决定：<br><img src="/images/redis-obj-2.png"><br>不同类型的编码的对象可能有多种形式：<br><img src="/images/redis-obj-3.png"></p>
<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串的编码可以是int，raw，embstr。</p>
<ul>
<li>若为整数并且可用long表示，那么编码设置为int，（void<em>）转为（int</em>）类型。</li>
<li>若为字符串类型，且长度大于32字节，那么用动态字符串存储，编码设置为raw，调用两次内存分配。</li>
<li>如果为字符串类型且长度小于32字节，那么用embstr编码表示，与上面不同的是embstr直接调用一次内存分配，将redisObject和embstr存储在一起。<br><img src="/images/redis-obj-4.png"></li>
</ul>
<h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><ol>
<li>int编码的字符串执行append命令追加一个非整数值或者长度超过限制，那么int将变为raw类型。</li>
<li>embstr为可读类型，也就是不能执行任何更改操作，因此要更改必须转为raw类型。一旦对embstr更改将立即编程raw类型。</li>
</ol>
<h4 id="字符串命令的实现"><a href="#字符串命令的实现" class="headerlink" title="字符串命令的实现"></a>字符串命令的实现</h4><p><img src="/images/redis-obj-5.png"></p>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表对象通过ziplist或者linkedlist编码实现。<br>如果是压缩链表，在内存中的布局如下图所示：<br><img src="/images/redis-obj-6.png"><br>如果是双向队列，如下图所示：<br><img src="/images/redis-obj-7.png"><br>链表中存储的是动态字符串对象，<font color = orange>字符串对象是Redis五种对象中唯一一种会被其他四种类型对象嵌套的对象</font>。</p>
<h4 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h4><p>满足下面两个条件，使用ziplist编码：</p>
<ul>
<li>列表对象保存的所有字符串元素长度小于64字节</li>
<li>列表对象保存的元素数量小于512个<br>除此之外使用linkedlist编码。</li>
</ul>
<h4 id="列表命令实现"><a href="#列表命令实现" class="headerlink" title="列表命令实现"></a>列表命令实现</h4><p><img src="/images/redis-obj-8.png"></p>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象通过ziplist或者hashtable编码实现。  </p>
<ul>
<li>ziplist编码的哈希对象使用压缩链表作为底层实现<br>新键值对加入哈希对象是，会先将保存了键的压缩链表节点压到表尾，在将保存了值的节点压到表尾。如下图所示：<br><img src="/images/redis-obj-9.png"></li>
<li>hashtable编码使用字典作为底层实现<br>哈希对象每个键值对使用一个字典键值对来保存。每个键和值都是一个字符串对象。如下图所示：<br><img src="/images/redis-obj-10.png"></li>
</ul>
<h4 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h4><p>满足下面两个条件使用ziplist编码：</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节。</li>
<li>键值对数量小于512个。</li>
</ul>
<p>除此之外使用字典存储。</p>
<h4 id="命令的实现"><a href="#命令的实现" class="headerlink" title="命令的实现"></a>命令的实现</h4><p><img src="/images/redis-obj-11.png"></p>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象使用intset或者hashtable编码。</p>
<ul>
<li>intset使用整数集合作为底层实现。</li>
<li>hashtable使用字典作为底层实现。</li>
</ul>
<h4 id="编码转换-3"><a href="#编码转换-3" class="headerlink" title="编码转换"></a>编码转换</h4><p>集合对象满足下面两个条件使用intset编码：</p>
<ul>
<li>集合对象保存的所有元素都是整数。</li>
<li>集合对象保存的元素数量不超过512个。</li>
</ul>
<p>除此之外使用hashtable实现。</p>
<h4 id="集合命令的实现"><a href="#集合命令的实现" class="headerlink" title="集合命令的实现"></a>集合命令的实现</h4><p><img src="/images/redis-obj-12.png"></p>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>有序结合使用ziplist或者skiplist编码。</p>
<ul>
<li>ziplist使用压缩链表作为底层实现。每个集合元素使用两个紧挨在一起的压缩链表节点表示，第一个是元素成员，第二个是元素的分值。<br><img src="/images/redis-obj-13.png"></li>
<li>skiplist使用zset作为底层实现。</li>
</ul>
<h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><p>zset有一个字典和一个跳表组成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>
<p><font color = orange>其中zsl跳表按照分值从小到大保存了所有集合元素，每个跳表节点都保存了一个集合元素，具体的：跳表的obj指针指向元素，score属性保存元素分值。通过跳表可以对有序集合进行范围型操作，比如ZRANK.ZRANGE等命令。dict字典结构为有序结合创建了一个从成员到分值的映射，键保存成员，值保存分值，因此通过字典可以O(1)地查找元素的分值。</font></p>
<h4 id="为什么要用两个结构来实现zset？"><a href="#为什么要用两个结构来实现zset？" class="headerlink" title="为什么要用两个结构来实现zset？"></a>为什么要用两个结构来实现zset？</h4><p>理论上可以使用其中任何一个来实现，但是只使用字典的话，执行ZRANK,ZRANGE命令就需要O(NlogN)的复杂度，单使用跳表的话，查找复杂度会是O(logN)。<font color = orange>并且两种数据结构都使用指针来避免了额外的内存开销。</font><br><img src="/images/redis-obj-14.png"><br>上图所示为了简化，stingObject和score分开表示，但是在实际的实现中，指针都是指向同一块内存区域。</p>
<h4 id="编码转换-4"><a href="#编码转换-4" class="headerlink" title="编码转换"></a>编码转换</h4><p>同时满足下面两个条件使用压缩链表，否则使用zset：</p>
<ul>
<li>集合保存的元素数量小于128个</li>
<li>保存的元素成员的长度都小于64字节</li>
</ul>
<h4 id="命令的实现-1"><a href="#命令的实现-1" class="headerlink" title="命令的实现"></a>命令的实现</h4><p><img src="/images/redis-obj-14.png"></p>
<h3 id="内存回收、对象共享和空转时长"><a href="#内存回收、对象共享和空转时长" class="headerlink" title="内存回收、对象共享和空转时长"></a>内存回收、对象共享和空转时长</h3><ul>
<li>内存回收</li>
</ul>
<p>在对象结构体中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>有一个refcount字段用来记录对象的引用计数信息。对象的整个生命周期可以分为创建对象，操作对象，释放对象三个阶段。</p>
<ul>
<li>对象共享</li>
</ul>
<p>对象的引用计数还能带来对象共享的作用：如果键A创建”100”作为值对象，此时键B如果需要创建一个同样的值对象，就可以直接在A的值对象的引用计数上加1。<br><font color = orange>redis不共享包含字符串的对象，原因在于每次共享需要比较对象是否完全相同，如果是整数，复杂度为O(1)，如果是字符串，复杂度是O（N），如果是包含了多个值的对象，复杂度会上升为O(N^2)。</font> </p>
<ul>
<li>空转时长</li>
</ul>
<p>另外结构体中的lru记录了当前时间减去值对象最后一次被访问的时间，当程序内存超过限制，会优先清理长时间没有访问的元素。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>内存泄露</title>
    <url>/2021/12/03/%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="如何知道内存泄漏了？"><a href="#如何知道内存泄漏了？" class="headerlink" title="如何知道内存泄漏了？"></a>如何知道内存泄漏了？</h3><ol>
<li>hook函数</li>
</ol>
<p>定义malloc&#x2F;free 或者new&#x2F;delete 的hook函数，在c语言中使用dlsym。</p>
<ul>
<li>一些小技巧：如何知道是哪一行分配了资源？<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译器自带的</span></span><br><span class="line">__builtin_return_address();</span><br></pre></td></tr></table></figure>
再使用address2line</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">address2line -fe xxxxx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用宏定义或者重载</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> malloc_hook(size) malloc(size)</span></span><br></pre></td></tr></table></figure>

<p>这种方式只能定义在一个文件中，第一种方法可以在全局使用。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学</title>
    <url>/2020/10/02/%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="密码学复习下…"><a href="#密码学复习下…" class="headerlink" title="密码学复习下…"></a>密码学复习下…</h3><p><img src="/images/%E5%AF%86%E7%A0%81%E5%AD%A6_%E9%A1%B5%E9%9D%A2_1.jpg"></p>
<p><img src="/images/%E5%AF%86%E7%A0%81%E5%AD%A6_%E9%A1%B5%E9%9D%A2_2.jpg"><br><img src="/images/%E5%AF%86%E7%A0%81%E5%AD%A6_%E9%A1%B5%E9%9D%A2_3.jpg"><br><img src="/images/%E5%AF%86%E7%A0%81%E5%AD%A6_%E9%A1%B5%E9%9D%A2_4.jpg"><br><img src="/images/%E5%AF%86%E7%A0%81%E5%AD%A6_%E9%A1%B5%E9%9D%A2_5.jpg"><br><img src="/images/%E5%AF%86%E7%A0%81%E5%AD%A6_%E9%A1%B5%E9%9D%A2_6.jpg"><br><img src="/images/%E5%AF%86%E7%A0%81%E5%AD%A6_%E9%A1%B5%E9%9D%A2_7.jpg"><br><img src="/images/%E5%AF%86%E7%A0%81%E5%AD%A6_%E9%A1%B5%E9%9D%A2_8.jpg"><br><img src="/images/%E5%AF%86%E7%A0%81%E5%AD%A6_%E9%A1%B5%E9%9D%A2_9.jpg"></p>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>对称协程和非对称协程</title>
    <url>/2020/10/31/%E5%AF%B9%E7%A7%B0%E5%8D%8F%E7%A8%8B%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<p>对称协程和非对称协程</p>
<span id="more"></span>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/363775637">知乎</a></p>
]]></content>
      <categories>
        <category>协程</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv动态链接库错误</title>
    <url>/2020/10/02/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%EF%BC%9Aopencv/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/tmp/cc961U4H.o: In function `main&#x27;:</span><br><span class="line">ie.cpp:(.text+0xac): undefined reference to `cv::imread(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, int)&#x27;</span><br><span class="line">/tmp/cc961U4H.o: In function `cv::Mat::~Mat()&#x27;:</span><br><span class="line">ie.cpp:(.text._ZN2cv3MatD2Ev[_ZN2cv3MatD5Ev]+0x39): undefined reference to `cv::fastFree(void*)&#x27;</span><br><span class="line">/tmp/cc961U4H.o: In function `cv::Mat::operator=(cv::Mat const&amp;)&#x27;:</span><br><span class="line">ie.cpp:(.text._ZN2cv3MataSERKS0_[_ZN2cv3MataSERKS0_]+0x111): undefined reference to `cv::Mat::copySize(cv::Mat const&amp;)&#x27;</span><br><span class="line">/tmp/cc961U4H.o: In function `cv::Mat::create(int, int, int)&#x27;:</span><br><span class="line">ie.cpp:(.text._ZN2cv3Mat6createEiii[_ZN2cv3Mat6createEiii]+0x9d): undefined reference to `cv::Mat::create(int, int const*, int)&#x27;</span><br><span class="line">/tmp/cc961U4H.o: In function `cv::Mat::release()&#x27;:</span><br><span class="line">ie.cpp:(.text._ZN2cv3Mat7releaseEv[_ZN2cv3Mat7releaseEv]+0x47): undefined reference to `cv::Mat::deallocate()&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>


<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>在编译命令后加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`pkg-config  --cflags --libs opencv`</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -o ie ie.cpp -std=c++11 `pkg-config  --cflags --libs opencv`</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>协程框架思考</title>
    <url>/2022/01/27/%E5%8D%8F%E7%A8%8B%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="网络编程中协程的作用"><a href="#网络编程中协程的作用" class="headerlink" title="网络编程中协程的作用"></a>网络编程中协程的作用</h3><p>记住一句话即可:协程可以实现同步的编程方式，性能和多线程异步回调相似。</p>
<h3 id="实现上下文切换的方式"><a href="#实现上下文切换的方式" class="headerlink" title="实现上下文切换的方式"></a>实现上下文切换的方式</h3><ol>
<li>setjump&#x2F;long jump</li>
<li>ucontext</li>
<li>汇编代码</li>
</ol>
<h3 id="协程中需要包含哪些成员？"><a href="#协程中需要包含哪些成员？" class="headerlink" title="协程中需要包含哪些成员？"></a>协程中需要包含哪些成员？</h3><ol>
<li>寄存器组</li>
<li>入口函数</li>
<li>函数参数</li>
<li>返回值</li>
<li>栈地址（共享栈和独立栈）</li>
<li>栈大小（4K）</li>
<li>协程状态</li>
</ol>
<h3 id="协程不同状态使用什么数据结构"><a href="#协程不同状态使用什么数据结构" class="headerlink" title="协程不同状态使用什么数据结构"></a>协程不同状态使用什么数据结构</h3><ol>
<li>新建&#x2F;就绪：队列</li>
<li>等待：红黑树</li>
<li>睡眠：红黑树<br> 这里为什么不用小顶堆？小顶堆适合取出次数小的任务，红黑树是有序的，在大量超时取出的情况下效率低。</li>
</ol>
<h3 id="多核模式下调度器怎么设计？"><a href="#多核模式下调度器怎么设计？" class="headerlink" title="多核模式下调度器怎么设计？"></a>多核模式下调度器怎么设计？</h3><ol>
<li>多线程：如果多个线程公用一个调用器，使用调度器的时候需要加锁（涉及红黑树、队列的操作）</li>
<li>多进程：每个核绑定一个进程</li>
</ol>
]]></content>
      <categories>
        <category>协程</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄清尾递归</title>
    <url>/2020/10/31/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%B8%85%E5%B0%BE%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>彻底弄清尾递归</p>
<span id="more"></span>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>什么是尾递归？<br><a href="">stackoverflow</a>上有一段很好的解释</p>
<h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>场景题</title>
    <url>/2022/01/31/%E5%9C%BA%E6%99%AF%E9%A2%98/</url>
    <content><![CDATA[<p>场景题</p>
<span id="more"></span>
<h2 id="输入一个url后到出现页面发生什么？"><a href="#输入一个url后到出现页面发生什么？" class="headerlink" title="输入一个url后到出现页面发生什么？"></a>输入一个url后到出现页面发生什么？</h2><ol>
<li><p>DNS解析</p>
<ul>
<li>查询浏览器缓存</li>
<li>查询操作系统缓存</li>
<li>查询路由器缓存&#x2F;ISP服务器缓存</li>
<li>通过递归和迭代两种方式查询dns服务器</li>
</ul>
</li>
<li><p>TCP连接</p>
<ul>
<li>应用层：HTTP数据（GET&#x2F;POST）</li>
<li>传输层：TCP数据（三次握手、SYN泛洪攻击）<ul>
<li>SYN攻击是伪造tcp头，虚造一个ip，导致服务方永远无法收到ack，半连接状态消耗系统资源，一般可以设置syn timeout或者拒绝大量相同ip访问来避免。</li>
</ul>
</li>
<li>网络层：IP头（arp）</li>
<li>链路层：以太网首部（广播单播、arp攻击）<ul>
<li>arp攻击：局域网内有大量虚假arp应答</li>
</ul>
</li>
</ul>
</li>
<li><p>服务器响应</p>
<ul>
<li>协议解析</li>
<li>资源发送</li>
</ul>
</li>
<li><p>浏览器渲染</p>
</li>
</ol>
<h2 id="数据从磁盘到内存全过程？"><a href="#数据从磁盘到内存全过程？" class="headerlink" title="数据从磁盘到内存全过程？"></a>数据从磁盘到内存全过程？</h2><p>1、初始化DMA控制器并启动磁盘<br>2、从磁盘传输一块数据到内存缓冲区<br>3、DMA控制器发出中断请求<br>4、执行“DMA结束”中断服务程序</p>
<h2 id="数据从网卡到磁盘全过程？"><a href="#数据从网卡到磁盘全过程？" class="headerlink" title="数据从网卡到磁盘全过程？"></a>数据从网卡到磁盘全过程？</h2><ol>
<li>网卡收到数据包</li>
<li>将数据包从网卡硬件缓存读入内存（DMA –&gt; skb_buffer）</li>
<li>通知内核处理<ul>
<li>NIC触发硬中断，硬中断处理程序会调用驱动程序启动软中断，后续慢慢处理。</li>
<li>软中断触发NAPI，循环处理ring_buffer指向的skb_buffer</li>
</ul>
</li>
<li>经过TCP&#x2F;IP协议层逐层处理</li>
<li>应用程序通过read()从sockert buffer读取内容</li>
</ol>
<p>用一段话描述：网卡收到数据包，DMA到内核内存，中断通知内核数据有了，内核按轮次处理消耗数据包，一轮处理完成后，开启硬中断。其核心就是网卡和内核其实是生产和消费模型，网卡生产，内核负责消费，生产者需要通知消费者消费；如果生产过快会产生丢包，如果消费过慢也会产生问题。也就说在高流量压力情况下，只有生产消费优化后，消费能力够快，此生产消费关系才可以正常维持，所以如果物理接口有丢包计数时候，未必是网卡存在问题，也可能是内核消费的太慢。</p>
<h2 id="源代码到运行全过程"><a href="#源代码到运行全过程" class="headerlink" title="源代码到运行全过程"></a>源代码到运行全过程</h2><ol>
<li>预处理</li>
<li>编译（词法分析，语法分析，中间代码生成，优化）</li>
<li>汇编</li>
<li>链接</li>
<li>生成ELF文件</li>
</ol>
]]></content>
      <categories>
        <category>场景设计</category>
      </categories>
      <tags>
        <tag>场景设计</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法大总结</title>
    <url>/2020/10/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">辅助空间</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">直接插入排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">$O(n * \log(n))$</td>
<td align="center">$O(n * \log(n))$</td>
<td align="center">$O(n * \log(n))$</td>
<td align="center">$O(n)$</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">$O(n * \log(n))$</td>
<td align="center">$O(n * \log(n))$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n * \log(n))$</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">$O(n * \log(n))$</td>
<td align="center">$O(n * \log(n))$</td>
<td align="center">$O(n * \log(n))$</td>
<td align="center">$O(1)$</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">$O(n^{1.3})$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^{2})$</td>
<td align="center">$O(1))$</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">$O(n + k)$</td>
<td align="center">$O(n + k)$</td>
<td align="center">$O(n + k)$</td>
<td align="center">$O(n + k)$</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">$O(n + k))$</td>
<td align="center">$O(n + k)$</td>
<td align="center">$O(n + k)$</td>
<td align="center">$O(n + k)$</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">$O(d * (r + n))$</td>
<td align="center">$O(d * (rd + n))$</td>
<td align="center">$O(d * (r + n))$</td>
<td align="center">$O(n + rd)$</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>n代表元素长度，r代表元素的基数个数，d代表基数长度, k为辅助数组长度</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，3. 这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
<p>直接上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;T&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; -- i)&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[i]);</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><font color = orange>冒泡排序思路简单，代码也简单，特别适合小数据的排序</font>.</em></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;T&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[minIndex])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。<br>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;T&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> key = nums[i];</span><br><span class="line">            <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; key &lt; nums[j])&#123;</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                -- j;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;T&gt;&amp; nums, <span class="type">int</span> l1, <span class="type">int</span> r1, <span class="type">int</span> l2, <span class="type">int</span> r2)</span></span>&#123;</span><br><span class="line">    T temp[r2 - l1 + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> base = l1;</span><br><span class="line">    <span class="keyword">while</span>(l1 &lt;= r1 &amp;&amp; l2 &lt;= r2)&#123;</span><br><span class="line">        temp[index ++] = nums[l1] &lt; nums[l2] ? nums[l1 ++] : nums[l2 ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1 &lt;= r1) temp[index ++] = nums[l1 ++];</span><br><span class="line">    <span class="keyword">while</span>(l2 &lt;= r2) temp[index ++] = nums[l2 ++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; ++ i)&#123;</span><br><span class="line">        nums[base + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;T&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, left, mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="built_in">merge</span>(nums, left, mid, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsort</span><span class="params">(vector&lt;T&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> key = nums[l];</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] &gt;= key) -- r;</span><br><span class="line">        nums[l] = nums[r];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] &lt;= key) ++ l;</span><br><span class="line">        nums[r] = nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[l] = key;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;T&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">qsort</span>(nums, left, right);</span><br><span class="line">        <span class="built_in">quickSort</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(vector&lt;T&gt;&amp; nums, <span class="type">int</span> len, <span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = index;</span><br><span class="line">    <span class="type">int</span> lchild = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, rchild = (index &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(lchild &lt; len &amp;&amp; nums[lchild] &gt; nums[cur]) cur = lchild;</span><br><span class="line">    <span class="keyword">if</span>(rchild &lt; len &amp;&amp; nums[rchild] &gt; nums[cur]) cur = rchild;</span><br><span class="line">    <span class="keyword">if</span>(cur != index)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[index], nums[cur]);</span><br><span class="line">        <span class="built_in">adjust</span>(nums, len, cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;T&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)&#123;</span><br><span class="line">        <span class="built_in">adjust</span>(nums, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; -- i)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">        <span class="built_in">adjust</span>(nums, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;T&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> step = n / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = step; i &lt; n; i += step)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i - step; j &gt; <span class="number">0</span>; j -= step)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[j + step])&#123;</span><br><span class="line">                    <span class="built_in">swap</span>(nums[j], nums[j + step]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countSort</span><span class="params">(vector&lt;T&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxv = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), minv = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> len = maxv - minv + <span class="number">1</span>;</span><br><span class="line">    T cnt[len];</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; num : nums) ++ cnt[num - minv]; </span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt[i] --)&#123;</span><br><span class="line">            nums[index ++] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;T&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxv = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> minv = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> bucketCnt = (maxv - minv) / n + <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;T&gt;&gt; <span class="built_in">buckets</span>(bucketCnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)&#123;</span><br><span class="line">        <span class="type">int</span> bucketIdx = (num - minv) / bucketCnt;</span><br><span class="line">        <span class="keyword">if</span>(bucketIdx &gt;= bucketCnt) bucketIdx = bucketCnt - <span class="number">1</span>;</span><br><span class="line">        buckets[bucketIdx].<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    nums.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; bucket : buckets)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(bucket.<span class="built_in">begin</span>(), bucket.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; num : bucket) nums.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> minv = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;num:nums) num -= minv;</span><br><span class="line">    <span class="type">int</span> maxv = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> maxBit = <span class="number">1</span>,curNum = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(curNum &lt;= maxv)&#123;</span><br><span class="line">        ++ maxBit;</span><br><span class="line">        curNum *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, place = <span class="number">1</span>; i &lt; maxBit; ++ i, place *= <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) ++ cnt[nums[j] / place % <span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; ++ j) cnt[j] += cnt[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; -- j)&#123;</span><br><span class="line">            <span class="type">int</span> bitNum = nums[j] / place % <span class="number">10</span>;</span><br><span class="line">            tmp[cnt[bitNum] - <span class="number">1</span>] = nums[j];</span><br><span class="line">            -- cnt[bitNum];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">copy</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>(),nums.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) num += minv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库复习</title>
    <url>/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%9A%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><ul>
<li>原子性：事务内包含的所有操作要么全部成功，要么全部失败回滚；实现：日志，将所有的更新操作全部写入日志当中，若因为一些系统奔溃&#x2F;断电等原因导致事务中的部分更新操作已经执行，部分操作未执行，则通过回溯日志，将操作回滚，使系统保证原子性以及一致性；</li>
<li>一致性：不管任何时间有少个并发的事务，系统也必须保持一致；</li>
<li>隔离性：多个并发的事务的操作，在同一时间只能有一个事务执行（即串行的执行）；</li>
<li>持久性：事务正确执行后，事务中对数据的操作不会回滚；</li>
</ul>
<h2 id="四大隔离级别"><a href="#四大隔离级别" class="headerlink" title="四大隔离级别"></a>四大隔离级别</h2><ol>
<li><p>读未提交（Read Uncommitted）<br>此隔离级别容易出现数据的脏读（读到未提交的数据）。</p>
</li>
<li><p>读已提交（Read Committed）<br>此隔离级别避免了脏读，但是会造成不可重复读。<br>不可重复读：在一个事务内，多次读同一数据，在事务还没有结束时，另一个事务对该数据进行了修改，导致两次读到的数据不同。</p>
</li>
<li><p>可重复读（Repeatable Read）</p>
</li>
</ol>
<p>此隔离级别避免了不可重复读，但可能会造成幻读。<br>幻读：在一个事务内，前后查询同一范围内的数据，发现前后两次查询的数据不一样。</p>
<ol start="4">
<li>可串行化（Serialzable）</li>
</ol>
<p>最高的事务隔离级别，在此级别下，事务顺序执行，不仅可以避免脏读，不可重复读，还避免了幻读，但是，性能很低，代价高昂，一般很少使用。</p>
<h2 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h2><p>它的实现依赖于隐式字段、undo日志、快照读&amp;当前读、Read View。</p>
<ol>
<li>隐式字段</li>
</ol>
<p>每一行记录都有两个隐藏列DB_TRX_ID、DB_ROLL_PTR，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列DB_ROW_ID。</p>
<ul>
<li>DB_TRX_ID，记录每一行最近一次修改（修改&#x2F;更新）它的事务ID，大小为6字节；</li>
<li>DB_ROLL_PTR，这个隐藏列就相当于一个指针，指向回滚段的undo日志，大小为7字节；</li>
<li>DB_ROW_ID，单调递增的行ID，大小为6字节；</li>
</ul>
<ol start="2">
<li>undo 日志</li>
</ol>
<ul>
<li>事务未提交的时候，修改数据的镜像（修改前的旧版本），存到undo日志里。以便事务回滚时，恢复旧版本数据，撤销未提交事务数据对数据库的影响。</li>
<li>undo日志是逻辑日志。可以这样认为，当delete一条记录时，undo log中会记录一条对应的insert记录，当update一条记录时，它记录一条对应相反的update记录。</li>
<li>存储undo日志的地方，就是回滚段。</li>
</ul>
<ol start="3">
<li>快照读和当前读</li>
</ol>
<ul>
<li>快照读：读取的是记录数据的可见版本（有旧的版本），不加锁,普通的select语句都是快照读。</li>
<li>当前读：读取的是记录数据的最新版本，显示加锁的都是当前读。</li>
</ul>
<ol start="4">
<li>Read View</li>
</ol>
<p>Read View就是事务执行快照读时，产生的读视图。<br>事务执行快照读时，会生成数据库系统当前的一个快照，记录当前系统中还有哪些活跃的读写事务，把它们放到一个列表里。<br>Read View主要是用来做可见性判断的，即判断当前事务可见哪个版本的数据~</p>
<ul>
<li>m_ids:当前系统中那些活跃的读写事务ID,它数据结构为一个List。</li>
<li>min_limit_id:m_ids事务列表中，最小的事务ID</li>
<li>max_limit_id:m_ids事务列表中，最大的事务ID</li>
</ul>
<p>如果DB_TRX_ID &lt; min_limit_id，表明生成该版本的事务在生成ReadView前已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。<br>如果DB_TRX_ID &gt; m_ids列表中最大的事务id，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。<br>如果 min_limit_id &lt;&#x3D; PDB_TRX_ID &lt;&#x3D; max_limit_id,需要判断m_ids.contains(DB_TRX_ID)，如果在，则代表Read View生成时刻，这个事务还在活跃，还没有Commit，你修改的数据，当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，修改的结果，当前事务是能看见的。</p>
<h2 id="mysql隔离级别的实现原理"><a href="#mysql隔离级别的实现原理" class="headerlink" title="mysql隔离级别的实现原理"></a>mysql隔离级别的实现原理</h2><ol>
<li>读未提交</li>
</ol>
<p>采取读不加锁原理。</p>
<ul>
<li>事务读不加锁，不阻塞其他事务的读和写</li>
<li>事务写阻塞其他事务写，但不阻塞其他事务读；</li>
</ul>
<ol start="2">
<li>已提交读<br>已提交读就是在每次读数据的时候产生ReadView。<br><a href="https://juejin.cn/post/6844904115353436174">参考这个链接</a></li>
<li>可重复读</li>
</ol>
<p>可重复读就是在第一次读取数据的时候产生ReadView。</p>
<ol start="4">
<li>避免幻读</li>
</ol>
<p>InnoDB避免幻读的方法就是在索引上加入Next-Key Locking。<br>5. 串行化</p>
<p>读加共享锁，写加排他锁，读写互斥。如果有未提交的事务正在修改某些行，所有select这些行的语句都会阻塞。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>redis系列：常见问题</title>
    <url>/2021/09/14/redis%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="Redis常用数据结构和使用场景（Zset中跳表数据结构）"><a href="#Redis常用数据结构和使用场景（Zset中跳表数据结构）" class="headerlink" title="Redis常用数据结构和使用场景（Zset中跳表数据结构）"></a>Redis常用数据结构和使用场景（Zset中跳表数据结构）</h3><h3 id="缓存击穿-缓存穿透-缓存雪崩"><a href="#缓存击穿-缓存穿透-缓存雪崩" class="headerlink" title="缓存击穿 缓存穿透 缓存雪崩"></a>缓存击穿 缓存穿透 缓存雪崩</h3><ol>
<li>缓存击穿：<br>访问一个缓存和数据库都不存在的 key，此时会直接打到数据库上，并且查不到数据，没法写缓存，所以下一次同样会打到数据库上。<br>此时，缓存起不到作用，请求每次都会走到数据库，流量大时数据库可能会被打挂。此时缓存就好像被“穿透”了一样，起不到任何作用。<br>解决方案：</li>
</ol>
<ul>
<li>接口校验。在正常业务流程中可能会存在少量访问不存在 key 的情况，但是一般不会出现大量的情况，所以这种场景最大的可能性是遭受了非法攻击。可以在最外层先做一层校验：用户鉴权、数据合法性校验等，例如商品查询中，商品的ID是正整数，则可以直接对非正整数直接过滤等等。</li>
<li>缓存空值。当访问缓存和DB都没有查询到值时，可以将空值写进缓存，但是设置较短的过期时间，该时间需要根据产品业务特性来设置。</li>
<li>布隆过滤器。使用布隆过滤器存储所有可能访问的 key，不存在的 key 直接被过滤，存在的 key 则再进一步查询缓存和数据库。</li>
</ul>
<ol start="2">
<li>缓存穿透<br>某一个热点 key，在缓存过期的一瞬间，同时有大量的请求打进来，由于此时缓存过期了，所以请求最终都会走到数据库，造成瞬时数据库请求量大、压力骤增，甚至可能打垮数据库。<br>解决方案</li>
</ol>
<ul>
<li>加互斥锁。在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。（现在主流的方法就是加Redis分布式锁）</li>
<li>热点数据不过期。直接将缓存设置为不过期，然后由定时任务去异步加载数据，更新缓存。<br>这种方式适用于比较极端的场景，例如流量特别特别大的场景，使用时需要考虑业务能接受数据不一致的时间，还有就是异常情况的处理，不要到时候缓存刷新不上，一直是脏数据，那就凉了。</li>
</ul>
<ol start="3">
<li>缓存雪崩<br>大量的热点 key 设置了相同的过期时间，导在缓存在同一时刻全部失效，造成瞬时数据库请求量大、压力骤增，引起雪崩，甚至导致数据库被打挂。<br>缓存雪崩其实有点像“升级版的缓存击穿”，缓存击穿是一个热点 key，缓存雪崩是一组热点 key。<br>解决方案</li>
</ol>
<ul>
<li><p>过期时间打散。既然是大量缓存集中失效，那最容易想到就是让他们不集中生效。可以给缓存的过期时间时加上一个随机值时间，使得每个 key 的过期时间分布开来，不会集中在同一时刻失效。</p>
</li>
<li><p>热点数据不过期。该方式和缓存击穿一样，也是要着重考虑刷新的时间间隔和数据异常如何处理的情况。</p>
</li>
<li><p>加互斥锁。该方式和缓存击穿一样，按 key 维度加锁，对于同一个 key，只允许一个线程去计算，其他线程原地阻塞等待第一个线程的计算结果，然后直接走缓存即可。</p>
</li>
</ul>
<h3 id="Redis缓存一致性的解决方案"><a href="#Redis缓存一致性的解决方案" class="headerlink" title="Redis缓存一致性的解决方案"></a>Redis缓存一致性的解决方案</h3><p>解决的办法是，如果服务对耗时不是特别敏感可以增加重试；如果服务对耗时敏感可以通过异步补偿任务来处理失败的更新，或者短期的数据不一致不会影响业务，那么只要下次更新时可以成功，能保证最终一致性就可以。</p>
<h3 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h3><p>主要是RDB和AOF策略，<a href="https://haoqinx.github.io/2021/09/14/redis%E7%B3%BB%E5%88%97%EF%BC%9ARDB&AOF/">可以参考这篇文章</a>.</p>
<h3 id="为什么槽的个数是16384？"><a href="#为什么槽的个数是16384？" class="headerlink" title="为什么槽的个数是16384？"></a>为什么槽的个数是16384？</h3><p><a href="https://zhuanlan.zhihu.com/p/99037321">主要参考这个文章</a><br>总结下来就是：  </p>
<ol>
<li>如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。</li>
</ol>
<p>如上所述，在消息头中，最占空间的是 myslots[CLUSTER_SLOTS&#x2F;8]。 当槽位为65536时，这块的大小是: 65536÷8÷1024&#x3D;8kb因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。</p>
<ol start="2">
<li>redis的集群主节点数量基本不可能超过1000个。</li>
</ol>
<p>如上所述，集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。 那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。</p>
<ol start="3">
<li>槽位越小，节点少的情况下，压缩率高</li>
</ol>
<p>Redis主节点的配置信息中，它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中，会对bitmap进行压缩，但是如果bitmap的填充率slots &#x2F; N很高的话(N表示节点数)，bitmap的压缩率就很低。 如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。<br>而16384÷8÷1024&#x3D;2kb。</p>
<h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><h3 id="Redis为什么那么快"><a href="#Redis为什么那么快" class="headerlink" title="Redis为什么那么快"></a>Redis为什么那么快</h3><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-cs445:buffer pool</title>
    <url>/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9Abuffer%E6%B1%A0/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="buffer-pool-manager"><a href="#buffer-pool-manager" class="headerlink" title="buffer pool manager"></a>buffer pool manager</h2><pre><code>- buffer池组成
    - frame：缓冲池由frame组成，每次我们需要一个page，就吧这个page替换进frame
    - page table：用来记录page到buffer pool的映射关系
    - 其他元信息：脏页面（页面是否被修改），引用计数（页面被线程正在访问的计数）
- multiple buffer pools(多个缓冲池，每个池有其策略)
    - 减少线程竞争
    - 提供多种策略
    - 如何实现？根据Object id映射或者哈希
- pre-fetching(预取)
    - 提前把一些顺序信息读入buffer pool中  
    - 可以完成一些操作系统不能完成的预读，如index分支跳转
- scan sharing(扫描共享)
    - 查询复用计算结果
    - 允许多个查询附加到一个游标上
- buffer pool bypass
    - 给查询线程分配一小块内存，查询page的时候不经过缓存池，为了不污染缓存
    - 查询量小的时候使用
- O_DIRECT
    - 避免操作系统文件缓存
</code></pre>
<h2 id="replacement-policies"><a href="#replacement-policies" class="headerlink" title="replacement policies"></a>replacement policies</h2><pre><code>- LRU
- Clock（LRU近似算法）
- LRU-K：为了避免遍历对LRU的影响，K次才不会替换
</code></pre>
<h2 id="脏页面"><a href="#脏页面" class="headerlink" title="脏页面"></a>脏页面</h2><pre><code>- 页面有一个标识位，记录某次查询是否更改页面记录
- 后台写入（background writing）：定时将脏页面写回，避免缓存池中大量脏页面
</code></pre>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-cs445:存储引擎</title>
    <url>/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AD%98%E5%82%A8%E4%B8%80%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="存储层次"><a href="#存储层次" class="headerlink" title="存储层次"></a>存储层次</h2><p><img src="/images/db-1.png"></p>
<ul>
<li>tips：在数据库存储上尽量不要使用mmap，这会带来内存&#x2F;并发等一系列问题，会成为系统瓶颈。</li>
</ul>
<h2 id="页式存储引擎"><a href="#页式存储引擎" class="headerlink" title="页式存储引擎"></a>页式存储引擎</h2><ol>
<li>页<br> a. 数据往往存储在以页为单位的空间中，页中包含元数据&#x2F;索引&#x2F;表数据，有的数据库将元数据和对应的表数据存放在一起，为了保证其他页丢失的情况下本页不受影响。<br> b. 通常一页不会存放不同类型的数据，例如某页都是tuple，另一页全都是索引数据.<br> c. 每个page会被赋予一个唯一的内部标识符，系统会生成属于page的ID.<br> d. indirection层会吧page id映射到某个文件的某个位置（也就是记录一个相对位置，当文件整体移动后，使用相对位置+偏移量就能重新找到page）<br> e. 物理页和操作系统页都在4kb左右，数据库的页在512b～16kb</li>
<li>管理页的方式<br> a. Heap File Organization<br> b. Sequential&#x2F;sorted File Organization<br> c. Hashing File Organization</li>
<li>Heap File管理方式<br> heap file是许多页的无序集合，有两种组织形式：链表和页目录<ul>
<li>链表管理就是定义两个链表，一个数据链表表示都是存满的数据页，另一个时空闲链表，用来新写入数据。</li>
<li>页目录管理：使用一些特殊的页记录数据页page id和他的位置的映射关系，甚至可以记录页的剩余空间的大小。</li>
</ul>
</li>
<li>页头（page header）<ul>
<li>page size</li>
<li>checksum</li>
<li>DBMS version</li>
<li>transaction Visibility</li>
<li>压缩信息</li>
</ul>
</li>
<li>页内tuple布局<ul>
<li>长度固定方法：每个tuple固定长度</li>
<li>slotted pages：如下图所示，为了支持可变长度的记录作出的妥协。<br> <img src="/images/db-2.png"></li>
</ul>
</li>
<li>tuple布局<br> <img src="/images/db-3.png"><ul>
<li>header：Visibility info（并发控制信息），Bit Map for NULL values.header并不需要存储数据的元数据，因为他们都是按顺序记录的。</li>
<li>record数据按定义时顺序写入</li>
</ul>
</li>
</ol>
<h2 id="日志式文件布局"><a href="#日志式文件布局" class="headerlink" title="日志式文件布局"></a>日志式文件布局</h2><pre><code>![](/images/db-3.png)
通过追加命令的方式记录信息，有点像redis的rdb模式
比较出名的有leveldb，基于leveldb，移除其mmap的rocksdb等。
</code></pre>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-cs445:数据存储表示</title>
    <url>/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AD%98%E5%82%A8%E4%BA%8C%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2><pre><code>涉及浮点数和定点数的存储，不同的是我们需要更多的信息去记录浮点数，包括字符串形式的数据以及其他辅助信息，运算过程为字符串相加相乘类似。
</code></pre>
<h2 id="大数据表示"><a href="#大数据表示" class="headerlink" title="大数据表示"></a>大数据表示</h2><pre><code>当需要存储的数据大于单页大小，有以下解决方案
- overflow page：存储指向overflow page的指针，如果仍然无法全部存储，就形成链表结构。通常比较难以维护，包括overflow page上的元信息。
- 外部存储：数据库存一个文件路径。缺点是无法受到数据库保护。
</code></pre>
<h2 id="catalogs"><a href="#catalogs" class="headerlink" title="catalogs"></a>catalogs</h2><pre><code>存储表，列，索引，视图，用户，权限，内部的统计信息等
</code></pre>
<h2 id="workload"><a href="#workload" class="headerlink" title="workload"></a>workload</h2><pre><code>- OLTP(On-line Transaction Processing)
    简单查询，每次读取或者更新数据库中很小一部分数据

-  OLAP(On-line Analytical Processing)
复杂查询，常常读取分析大批量数据
</code></pre>
<h2 id="tuple存储形式"><a href="#tuple存储形式" class="headerlink" title="tuple存储形式"></a>tuple存储形式</h2><pre><code>- N-array tuple以行的形式存储
    - 优点:插入更新删除快，对需要整个tuple的查询友好
    - 缺点:对于全表扫描或者tuple一部分字段的查询不友好
- Column store：每页存储相同字段的值。
    - 优点:可以对数据进行压缩，降低字段查询时的系统io。
    - 缺点:小数据的增删改查比较费时
</code></pre>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-cs445:并发访问</title>
    <url>/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="latch和lock"><a href="#latch和lock" class="headerlink" title="latch和lock"></a>latch和lock</h3><p><img src="/images/db-4.png"></p>
<h3 id="latch"><a href="#latch" class="headerlink" title="latch"></a>latch</h3><ul>
<li>种类<ul>
<li>Test-and-Set Spin Latch(TAS)</li>
<li>读写锁</li>
<li>乐观&#x2F;悲观锁</li>
</ul>
</li>
<li>粒度<ul>
<li>page latch：锁少，并行度不好</li>
<li>slot latch：锁多，并行度高</li>
</ul>
</li>
<li>latch crabbing&#x2F;coupling</li>
<li>B+树的死锁问题</li>
<li>B+树insert，父节点延迟更新</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-cs445:并发控制</title>
    <url>/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul>
<li>A:原子性</li>
<li>C:如果事务是一致的，数据库是一致的，那么结束时也必须是一致的</li>
<li>I:隔离性</li>
<li>D:事务提交之后会持久化</li>
</ul>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul>
<li>Logging<br>记录所有动作到undo log</li>
<li>Shadow Paging<br>事务运行的时候，拷贝那些用到的page，然后在上面执行事务，当事务提交后，用这些page替换原来的page</li>
</ul>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><ul>
<li>数据库一致性</li>
<li>事务一致性<br><a href="https://www.zhihu.com/question/31346392">https://www.zhihu.com/question/31346392</a></li>
</ul>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>多个事务同时执行时，每个事务无法读到别的事务的中间结果。</p>
<ul>
<li>不可重复读</li>
<li>脏读</li>
<li>Overwriting Uncommited Data<br><img src="/images/db-31.png"></li>
</ul>
<p>如何判断两个事务存在冲突？</p>
<ul>
<li>依赖图</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li>锁的类型<ul>
<li>共享锁</li>
<li>排他锁</li>
</ul>
</li>
<li>锁控制协议：两阶段锁<ul>
<li>Growing（增长阶段）<br>每个事务被允许从锁管理器中获得锁。</li>
<li>Shrinking（收缩阶段）<br>事务只被允许释放前面获得的锁，不能申请新的锁。<br>两阶段锁可以消除序列化矛盾，但是会存在级联终止问题。如下图<br><img src="/images/db-32.png"><br>要解决上面这个问题，需要使用强严格两阶段锁，也就是说我们必须在事务提交的时候才能释放之前获得的锁，这样就能避main脏读和级联终止。<br>两阶段锁也会导致死锁，如下图：<br><img src="/images/db-33.png"><br>有两种方法解决死锁问题</li>
</ul>
</li>
<li>检测<br>锁管理器维护一个waits-for图，用来追踪每个事务等待要获取的锁，每个节点是一个事务，如果事务A正在等待事务B的锁，他们之间就有一个箭头，当存在环形结构就说明存在死锁。<br><img src="/images/db-34.png"><br>检测周期可以设置一个可容忍的系统值。</li>
<li>处理<br>选择一个事务，回滚，选择的标准可以是：<ul>
<li>时间戳</li>
<li>查询数</li>
<li>被锁住的item数量</li>
<li>需要回滚的事务数量</li>
</ul>
</li>
<li>预防<br>根据时间来确定优先级<ul>
<li>Wait-Die<br>如果请求锁的事务优先级高于持有锁的事务，那么等待持有锁的事务，否则终止。</li>
<li>Wound-Wait<br>如果请求锁的事务优先级高于持有锁的事务，那么持有锁的事务终止并且释放锁，否则请求锁的事务等待。<br><img src="/images/db-35.png"><br>当事务重启之后，其优先级（也就是时间戳）是它原本的时间戳，这有助于避免此事务饥饿。</li>
</ul>
</li>
<li>锁的层次<br><img src="/images/db-36.png"><br>数据库中有成千上万个tuple，我们不能直接管理这些，因此我们需要一些更高层次的抽象锁，让我们同一时间管理更少的锁。<ul>
<li>意向锁<ul>
<li>意向共享锁（IS）</li>
<li>意向排他锁（IX）</li>
<li>共享锁（S）</li>
<li>排他锁（X）</li>
<li>共享意向排他锁（SIX）<br><img src="/images/db-37.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基于时间戳顺序的控制"><a href="#基于时间戳顺序的控制" class="headerlink" title="基于时间戳顺序的控制"></a>基于时间戳顺序的控制</h3><p>基于两阶段锁是一种悲观锁，基于时间戳顺序是一种乐观锁。<br>我们需要向每个tuple添加两个时间戳：</p>
<ul>
<li>写时间戳：最近对tuple写的事务的时间戳</li>
<li>读时间戳：最近对tuple读的事务的时间戳<br>在读阶段，确保自己的时间戳不小于tuple的写时间戳，在写阶段，要确保事务的时间戳小于tuple的写时间戳和读时间戳。有一种优化叫做托马斯写入规则：<br><img src="/images/db-38.png"></li>
</ul>
<p>基于时间戳的并发控制是不可恢复的。如果事务大多时间很短并且不会发生冲突，那么可以考虑这种病发控制协议。</p>
<ul>
<li>乐观并发控制协议<br><a href="https://blog.csdn.net/BOBOyspa/article/details/121131474">偷懒，看下别人的总结</a></li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><ul>
<li>并发控制协议<ul>
<li>基于时间戳的控制</li>
<li>乐观并发控制</li>
<li>两阶段锁</li>
</ul>
</li>
<li>版本存储<br>通过版本链（version chain）存储，索引指向链表头，有三种方法：<ul>
<li>Append-Only<br><img src="/images/db-39.png"><br>每更新一次，作为一个新的tuple插入到表中，并更新链表指针。</li>
<li>Time-Traval<br><img src="/images/db-40.png"><br>每次更新将旧数据拷贝到time-travel表中，并更新指针。</li>
<li>Delta Storage<br><img src="/images/db-41.png"><br>每次更新不用将整个tuple拷贝，只需要拷贝delta值即可</li>
</ul>
</li>
<li>垃圾回收<ul>
<li>tuple级别的回收<ul>
<li>后台处理：后台线程对表进行定期扫描，查看开始时间戳和结束时间戳，不在活跃线程范围内就可以清除,一个优化是设置脏页面bitmap<br><img src="/images/db-42.png"></li>
<li>合作清理：当执行事务的线程在扫表的时候判断历史数据，只适用于从旧到新的版本数据存储方式</li>
</ul>
</li>
<li>事务级别的回收</li>
</ul>
</li>
<li>索引管理<ul>
<li>辅助索引的更新<ul>
<li>逻辑指针：每个tuple对应一个固定的id，这个id不变，我们去改变中间层，也就是将逻辑指针映射到物理指针的这一层，辅助索引保存的是主键索引的副本，每次去查找的时候实际上做两次操作，一次去查找主键，一次根据主键去查找这是的物理数据。</li>
<li>物理指针：直接修改物理指针去更新链表头</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-cs445:Undo &amp;&amp; Redo</title>
    <url>/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E6%97%A5%E5%BF%97%E5%92%8C%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="Undo-amp-Redo"><a href="#Undo-amp-Redo" class="headerlink" title="Undo &amp; Redo"></a>Undo &amp; Redo</h3><ul>
<li><p>Undo:移除一个终止的事务的影响</p>
</li>
<li><p>Redo：重新执行一个事务进行持久化</p>
</li>
<li><p>Steal Policy<br>允许未提交的事务回写到磁盘</p>
</li>
<li><p>Force Policy<br>要求所有事务提交之前必须回写到磁盘</p>
</li>
<li><p>No Steal + Force</p>
<ul>
<li>Shodow Paging<br><img src="/images/db-43.png"></li>
</ul>
</li>
<li><p>Steal + No Force</p>
<ul>
<li>write-ahead log<br><img src="/images/db-44.png"><br> 什么时间提交这些日志条目？<ul>
<li>事务提交时</li>
<li>组提交，这时会出现未提交事务的条目，但是不影响。</li>
</ul>
</li>
</ul>
</li>
<li><p>Logging Schemes</p>
<ul>
<li>Physical</li>
<li>Logical</li>
<li>Physiological<br><img src="/images/db-45.png"></li>
</ul>
</li>
<li><p>CheckPoints<br>使用预写日志，为了避免恢复时间过长，在某个时间点将所有脏页面持久化到磁盘。写入一个Checkpoint条目。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-cs445:查询优化</title>
    <url>/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><ul>
<li>Heuristics&#x2F;Rules 规则&#x2F;静态触发</li>
</ul>
<p>当查询中的某些部分满足我们的规则或者条件，我们就重写这部分.这部分需要我们去检查catelog.</p>
<ul>
<li>Cost-based Search</li>
</ul>
<p>方法的思想是使用一个模型去评估一个查询的负载，然后使用多种不同的查询计划去替换这个查询，找出最小负载的方案。</p>
<p>下面是整个查询优化过程<br><img src="/images/db-26.png"></p>
<h3 id="Relational-Algebra-Equivalences-等价关系代数"><a href="#Relational-Algebra-Equivalences-等价关系代数" class="headerlink" title="Relational Algebra Equivalences(等价关系代数)"></a>Relational Algebra Equivalences(等价关系代数)</h3><ul>
<li>predicate pushdown:在join前尽量过滤数据。</li>
<li>对过滤条件进行排序，让更具有分辨性的条件排在前面。</li>
<li>对复杂判断进行简化</li>
<li>对于行存储类型数据库，projection越早越好。</li>
</ul>
<h3 id="Plan-Cost-Estimation"><a href="#Plan-Cost-Estimation" class="headerlink" title="Plan Cost Estimation"></a>Plan Cost Estimation</h3><ul>
<li>CPU</li>
<li>磁盘</li>
<li>内存</li>
<li>网络</li>
</ul>
<p>在数据库的catelog中，会维护相关信息，并且在特定时间或者遍历表的时候更跟这些信息，在执行查询之前，将这些变量带入公式，计算出最小代价的查询。在系统中，我们定义一些统计量：</p>
<ul>
<li>$N_R$: 关系R的tuple数量</li>
<li>V(A,R):属性A不同值的数量</li>
<li>Selection Cardinality：$N_R$&#x2F;V(A,R)</li>
<li>selectivity: 选择率，给定一个条件，计算table中符合条件的tuple数量</li>
<li>Range Predicate：计算范围值的比例，有点像概率计算，因此可以引入概率论中的结论,但是为了计算方便，有下面三个前提：<br><img src="/images/db-27.png"></li>
</ul>
<h5 id="直方图法"><a href="#直方图法" class="headerlink" title="直方图法"></a>直方图法</h5><p>对于数据分布不均匀的关系，在一些高端数据库中会使用直方图来跟踪数据的分布。对于数据量极大或者属性值分布很广的情况，我们会使用相同宽度的<strong>bucket</strong>来记录值的分布，但是这种情况会导致某个桶内数据分布极不均匀的情况，我们可以使用<strong>分位数</strong>来解决这个问题，即累计一定比例的数据分桶，桶的宽度可变，但是总体占比大致相当。</p>
<h5 id="采样法"><a href="#采样法" class="headerlink" title="采样法"></a>采样法</h5><p>对于直方图，其实是对表中数据的一种缩略表达，那么在大数据量的table中，我们可以直接采样来近似代表整个表的数据分布。当表进行大规模更新或者到达一个指定时间点，我们去更新这个采样表。</p>
<h3 id="Plan-Enumeration"><a href="#Plan-Enumeration" class="headerlink" title="Plan Enumeration"></a>Plan Enumeration</h3><h5 id="单关系查询计划"><a href="#单关系查询计划" class="headerlink" title="单关系查询计划"></a>单关系查询计划</h5><ul>
<li>循序遍历</li>
<li>二分查找（对于聚集索引）</li>
<li>索引遍历</li>
</ul>
<h5 id="多关系查询计划"><a href="#多关系查询计划" class="headerlink" title="多关系查询计划"></a>多关系查询计划</h5><ul>
<li><p>left-deep join tree<br><img src="/images/db-28.png"><br>在上面三个查询树中，System R不考虑后面两个，只考虑第一种。为什么采用第一种？后面两种实现过程中会有大量结果溢出到磁盘，影响性能。</p>
</li>
<li><p>步骤（System R based）<br><img src="/images/db-29.png"></p>
</li>
<li><p>步骤（遗传算法）<br><img src="/images/db-30.png"></p>
</li>
</ul>
<h3 id="Nested-Sub-queries"><a href="#Nested-Sub-queries" class="headerlink" title="Nested Sub-queries"></a>Nested Sub-queries</h3><p>通常情况下将where作为函数，穿入参数然后返回一组值，有两种方法进行查询优化：</p>
<ul>
<li>重写查询，去除关联性，让其扁平化</li>
<li>将内部查询提取出来作为单独查询来执行，将结果缓存起来，这样不用每次执行上层查询都再执行一次子查询</li>
</ul>
<p>(<a href="https://dbdb.io/">https://dbdb.io/</a>)</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-cs445:HashTable &amp;&amp; TableIndex</title>
    <url>/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9AHashTable&amp;TableIndex/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="我们需要表示的数据"><a href="#我们需要表示的数据" class="headerlink" title="我们需要表示的数据"></a>我们需要表示的数据</h3><pre><code>- Internal Mata-data
- Core data storage
- Temporary Data Strutures
- Table Indexs
</code></pre>
<h3 id="hash-function"><a href="#hash-function" class="headerlink" title="hash function"></a>hash function</h3><pre><code>- XXHash
- CityHash
- FarmHash
</code></pre>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><pre><code>- 开放地址法
- robin 开放地址
- cuckoo hashing
- 链表法
- extendible hashing（有些复杂）
- Linear hashing（循环拆分，有点难以理解）
</code></pre>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><pre><code>- 为什么叶子结点的key和value不放在一起？
为了cpu缓存，能够快速定位key。
</code></pre>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><pre><code>- 部分索引
- 覆盖索引
- 聚集索引
- Include Columns：在建立索引的时候增加一些额外信息，能够加速查询。
- 函数式/表达式索引
- trie index
- radix tree的垂直压缩
- 倒排索引
</code></pre>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-cs445:查询引擎实现</title>
    <url>/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>数据库中的table不能完全放到内存中</li>
<li>计算得到的中间结果不能完全放入内存中</li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><ul>
<li>外部排序（多路归并排序）<ul>
<li>读取B个page到内存，对page排序并且回写到磁盘</li>
<li>使用prefetch预读加速</li>
</ul>
</li>
<li>B+树<ul>
<li>如果需要排序的key作为b+树存储，可以复用b+树</li>
<li>只能在聚簇索引（物理相邻）的b+树上使用，因为如果不是聚簇索引，每次获得数据都需要一次磁盘io</li>
</ul>
</li>
</ul>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><ul>
<li>排序聚合</li>
<li>非排序聚合<ul>
<li>external hashing aggregate<br>  <img src="/images/db-7.png"></li>
</ul>
</li>
</ul>
<h3 id="Join操作"><a href="#Join操作" class="headerlink" title="Join操作"></a>Join操作</h3><ul>
<li><p>data在查询语法树中的传递</p>
<ul>
<li>一个常规做法是将两个表所有属性拷贝到新表中，这样下面的操作不必再考虑前面的数据，也就是不用再到磁盘中进行retrieve.</li>
<li>另一种方法是指穿入我们所需的最小限度信息（join keys）.然后根据这些信息在后面的操作总从数据库中获取tuple的其他数据.这种方法叫做late materialization，对于列式存储比较友好，因为不用将其他列的信息粘合起来，这些信息通常位于不同的page中。现在这种优化很少，因为数据的获取（第一阶段）的代价通常很大。</li>
</ul>
</li>
<li><p>Nested Loop Join<br>  <img src="/images/db-8.png"><br>  <img src="/images/db-9.png"><br>  这是一种非常暴力的方法，一种优化手段是block nested loop join，这种方法把outter table的tuple缓存，减少了对inner table的io次数。<br>  <img src="/images/db-10.png"><br>  <img src="/images/db-11.png"><br>  另一种优化手段是index nested loop join，在内循环中去查询索引，这样避免了遍历操作，是O（logn）的复杂度，但是如果要查询的索引不是聚簇索引，还需要一次回表操作。<br>  <img src="/images/db-12.png"></p>
</li>
<li><p>Sort-Merge Join<br>  首先是对需要join的key(s)进行排序，然后利用两个游标在两个有序表上进行匹配。<br>  <img src="/images/db-13.png"></p>
</li>
<li><p>Hash Join<br>  原理就是对两个表中需要join的那个值进行hash操作，那么相同的值肯定会映射到一个partition中，我们每次只需要在一个partition中进行比较就行了。<br>  <img src="/images/db-14.png"><br>  在分布式场景下，可能两个表存在不同的主机上，那么传递哈希表是一个非常消耗资源的事，一个优化手段是使用布隆过滤器，布隆过滤器通常只有几kb大小，非常容易在主机之间进行网络通信，在建立第一个表的哈希表的时候填充布隆过滤器，那么我们对第二个表进行哈希的时候，可以直接判断是否存在。<br>  哈希之后的数据量可能非常大，不能放在内存中，因此我们可以使用Grace Hash Join优化。<br>  <img src="/images/db-15.png1"><br>  也就是分别对两个表进行哈希，然后对每对bucket进行Nested Loop Join，如果bucket也不能完全放到内存中，那就再进行一次哈希，递归进行。<br>  <img src="/images/db-16.png"></p>
</li>
<li><p>总结<br>  <img src="/images/db-17.png"></p>
</li>
</ul>
<h3 id="处理模型（processing-model）"><a href="#处理模型（processing-model）" class="headerlink" title="处理模型（processing model）"></a>处理模型（processing model）</h3><ul>
<li><p>迭代模型（Iterator Model）<br>  <img src="/images/db-18.png"><br>  每一个查询操作符都实现一个Next函数，函数调用其子节点的Next函数。Next每次处理一个tuple数据，需要迭代所有tuple才能完成所有操作。<br>  一些操作符必须获得所有子节点的tuple，例如Joins，Subqueries，Order By</p>
</li>
<li><p>Materialization Model<br>  不同于迭代模型，每次子节点都将整个结果传递给上层<br>  <img src="/images/db-19.png"><br>  在OLTP中进行点查询，这种方式比较高效，但是在OLAP中存在大量的中间结果，会产生锁延时，并且对于含有LIMIT的查询，如果数据量很大，每次传递给上层所有数据，这种资源消耗是不必要的。</p>
</li>
<li><p>Vectorization Model<br>  对迭代模型的优化，每次不是产生一个tuple，而是产生一个batch的tuple.<br>  <img src="/images/db-20.png"><br>  这种方式能够使用SIMD技术对数据进行分析计算，对于OLAP非常友好</p>
</li>
</ul>
<h3 id="Access-Method"><a href="#Access-Method" class="headerlink" title="Access Method"></a>Access Method</h3><ul>
<li>Sequential Scan<br>  普通遍历，对每页的tuple基于cursor做遍历，这通常效率非常低，有一些优化：预读，Buffer Pool Bypass，并行化，Zone Maps，Late Materialization，Heap CLustering<ul>
<li>Zone Maps：预先对page中的数据做聚合计算，DBMS在访问page的时候先去检查这些字段，如果不需要访问就直接跳过这个page<br>  <img src="/images/db-21.png"></li>
<li>Late Materialization：在列式存储数据库中，由于数据被按列存储到不同的page中，那么在每次opertaor之后，不用将整个tuple传给上层，直接传tuple对应的offset值，然后到root节点再到不同page中获取每一列的值。</li>
</ul>
</li>
<li>Index Scan<ul>
<li>Multi-Index Scan：通过不同的索引进行多次查找，基于我们的判断在对结果进行合并<br>  <img src="/images/db-22.png"></li>
<li>非聚簇索引的随机IO问题：对于非聚簇索引，我们可以不去一一随机IO，我们先将要访问的page id记录下来排序然后去一次访问page，拿到所有需要的tuple.</li>
</ul>
</li>
</ul>
<h3 id="表达式评估（Expression-Evaluation）"><a href="#表达式评估（Expression-Evaluation）" class="headerlink" title="表达式评估（Expression Evaluation）"></a>表达式评估（Expression Evaluation）</h3><p>DBMS将WHERE语句转化成一个expression tree<br><img src="/images/db-23.png"><br>每次遇到一个tuple，去匹配这个树，这样的话效率很低。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-cs445:查询执行</title>
    <url>/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="并行处理模型"><a href="#并行处理模型" class="headerlink" title="并行处理模型"></a>并行处理模型</h3><ul>
<li>Process per DBMS Worker<ul>
<li>使用一个进程处理一个请求</li>
<li>使用共享内存对全局数据进行共享，如buffer pool，不用将相同的page加载两次</li>
<li>单进程奔溃不会导致整个系统崩溃</li>
</ul>
</li>
<li>Process Pool<ul>
<li>使用进程池来处理请求</li>
<li>对cpu缓存不友好</li>
<li>减少了创建销毁进程开销</li>
</ul>
</li>
<li>Thread per DBMS Worker<ul>
<li>单进程多线程</li>
<li>线程崩溃导致进程崩溃</li>
<li>上下文切换开销很小</li>
<li>不需要管理共享内存</li>
</ul>
</li>
</ul>
<h3 id="并行查询方式"><a href="#并行查询方式" class="headerlink" title="并行查询方式"></a>并行查询方式</h3><ul>
<li><p>Inter-Query：同时执行多个查询</p>
</li>
<li><p>Intra-Query：同时执行一个查询的多个operator，一般有三种，注意下main这三种不是互斥的，他们可以相互组合。</p>
<ul>
<li>Intra-Operator（Horizontal）：将完整的操作拆分成多个平行的操作，也就是说把我们要处理的数据分成几段，并行处理，在DBMS中有一个特殊的exchange操作符，将数据分段，分别处理数据，然后最后将数据组合起来。exchange有三种类型：<ul>
<li>Gather：组合不同worker的数据合并成一个输出流传给上层操作符。</li>
<li>Repartition：将不同worker的数据分成不同的流，如group by</li>
<li>Distribute：将一个输入流转化成多个输出流<br>  <img src="/images/db-24.png"></li>
</ul>
</li>
<li>Inter-Operator（Vertical）：不同线程同一时间执行不同的operator.<br>  <img src="/images/db-25.png"></li>
<li>Bushy</li>
</ul>
</li>
</ul>
<h3 id="IO并行"><a href="#IO并行" class="headerlink" title="IO并行"></a>IO并行</h3><ul>
<li>multi-disk 并行：使用多个冗余磁盘存储相同的数据</li>
<li>database partitioning：将数据分成不相交的子集，分别存储在物理磁盘上单独管理<ul>
<li>垂直分区：将数据按照列进行分区</li>
<li>水平分区：将数据按照行进行分区</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-cs445:SQL基础</title>
    <url>/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97%EF%BC%9A%E9%AB%98%E7%BA%A7SQL/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="基础SQL"><a href="#基础SQL" class="headerlink" title="基础SQL"></a>基础SQL</h2><ul>
<li>聚合函数AVG，SUM，MIN，MAX等</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>UPPER</li>
<li>LIKE(%代替*，_代替?)</li>
<li>CONCAT</li>
<li>CREAT TABLE</li>
<li>ORDER BY</li>
<li>LIMIT</li>
<li>OFFSET</li>
</ul>
<h2 id="高级SQL"><a href="#高级SQL" class="headerlink" title="高级SQL"></a>高级SQL</h2><ul>
<li>嵌套查询</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘</title>
    <url>/2020/10/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<span id="more"></span>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%A1%B5%E9%9D%A2_1.jpg"><br><img src="/images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%A1%B5%E9%9D%A2_2.jpg"><br><img src="/images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%A1%B5%E9%9D%A2_3.jpg"><br><img src="/images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%A1%B5%E9%9D%A2_4.jpg"><br><img src="/images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%A1%B5%E9%9D%A2_5.jpg"><br><img src="/images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%A1%B5%E9%9D%A2_6.jpg"><br><img src="/images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%A1%B5%E9%9D%A2_7.jpg"><br><img src="/images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%A1%B5%E9%9D%A2_8.jpg"><br><img src="/images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%A1%B5%E9%9D%A2_9.jpg"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>数据挖掘</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：B树，B+树，B*树，红黑树</title>
    <url>/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9AB%E6%A0%91%EF%BC%8CB+%E6%A0%91%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B-tree树即B树，B即Balanced，平衡的意思。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如人们可能会以为B-树是一种树，而B树又是另一种树。而事实上是，B-tree就是指的B树。<br>B树的定义如下：</p>
<ul>
<li>定义任意非叶子结点最多只有M个儿子，且M&gt;2；</li>
<li>根结点的儿子数为[2, M]；</li>
<li>除根结点以外的非叶子结点的儿子数为[M&#x2F;2, M]，向上取整；</li>
<li>非叶子结点的关键字个数&#x3D;儿子数-1；</li>
<li>所有叶子结点位于同一层；</li>
<li>k个关键字把节点拆成k+1段，分别指向k+1个儿子，同时满足查找树的大小关系。</li>
</ul>
<p><img src="/images/btree-1.png"><br>优点：<br>可以看到，b树在查询时的比较次数并不比二叉树少，尤其是节点中的数非常多时，但是内存的比较速度非常快，耗时可以忽略，所以只要树的高度低，IO少，就可以提高查询性能，这是b树的优势之一。</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是B树的一种变体：</p>
<ul>
<li>有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li>
<li>通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</li>
<li>同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。<br><img src="/images/b+tree-1.png"><br>优点：</li>
<li>b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；</li>
<li>b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；</li>
<li>对于<font color = orange>范围查找</font>来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历，如下两图：</li>
</ul>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p>
<ul>
<li>性质1：每个节点要么是黑色，要么是红色。</li>
<li>性质2：根节点是黑色。</li>
<li>性质3：每个叶子节点（NIL）是黑色。</li>
<li>性质4：每个红色结点的两个子结点一定都是黑色。</li>
<li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li>
</ul>
<p>参考<a href="https://www.jianshu.com/p/e136ec79235c">这篇文章</a>,讲的非常好.还有<a href="https://www.cnblogs.com/skywang12345/p/3245399.html">这篇</a></p>
<p>优点：<br>参考<a href="https://www.cnblogs.com/wuchanming/p/4444961.html">这里</a></p>
<ol>
<li><p>红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log(n))的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。</p>
</li>
<li><p>相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。</p>
</li>
<li><p>红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是O(logN)，所以红黑树应用还是高于AVL树的. 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据.如果你的数据分布较好,则比较宜于采用 AVL树(例如随机产生系列数),但是如果你想处理比较杂乱的情况,则红黑树是比较快的</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>无锁队列</title>
    <url>/2021/09/14/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="CAS原子操作"><a href="#CAS原子操作" class="headerlink" title="CAS原子操作"></a>CAS原子操作</h3><p>CAS英文全称Compare &amp; Set(Swap),也就是原子操作，执行过程中不能被中断，在X86中有相应的汇编指令CMPCHG来实现。<br>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。<br>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">10</span>; <span class="comment">// V = 0x423D80</span></span><br></pre></td></tr></table></figure>
<ul>
<li>线程1想要把val的值加一。在当前状态下，1得到的val &#x3D; 10,期望值为11。即A &#x3D; 10， B &#x3D; 11；</li>
<li>此时线程2切换时间片，将val更新为11；</li>
<li>线程1开始提交更新，首先进行比较，A &#x3D; 10 !&#x3D; val &#x3D; 11，提交失败，此时线程1重新获取内存地址V的当前值，A &#x3D; 11， B &#x3D; 12，并且重新开始比较。</li>
<li>如果相等，那么就把地址V的值替换为B &#x3D; 12。</li>
</ul>
<p>从思想上看，CAS属于乐观锁。</p>
<p>在c中的实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compare_and_swap</span> <span class="params">(<span class="type">int</span>* reg, <span class="type">int</span> oldval, <span class="type">int</span> newval)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> old_reg_val = *reg;</span><br><span class="line">  <span class="keyword">if</span> (old_reg_val == oldval) &#123;</span><br><span class="line">     *reg = newval;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在c++也可以实现为返回bool类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_and_swap</span> <span class="params">(<span class="type">int</span> *addr, <span class="type">int</span> oldval, <span class="type">int</span> newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( *addr != oldval ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *addr = newval;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CAS的缺点主要有：</p>
<ol>
<li>CPU开销较大<br>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</li>
<li>不能保证代码块的原子性<br>CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</li>
<li>ABA问题<br>如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。</li>
</ol>
<h3 id="无锁队列"><a href="#无锁队列" class="headerlink" title="无锁队列"></a>无锁队列</h3><ol>
<li>初始化队列<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">InitQueue</span>(Q)</span><br><span class="line">&#123;</span><br><span class="line">    node = <span class="keyword">new</span> <span class="built_in">node</span>()</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;head = Q-&gt;tail = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>入队使用CAS实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EnQueue(Q, data) <span class="comment">//进队列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//准备新加入的结点数据</span></span><br><span class="line">    n = new node();</span><br><span class="line">    n-&gt;value = data;</span><br><span class="line">    n-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        p = Q-&gt;tail; <span class="comment">//取链表尾指针的快照</span></span><br><span class="line">    &#125; <span class="keyword">while</span>( CAS(p-&gt;next, <span class="literal">NULL</span>, n) != TRUE); </span><br><span class="line">    <span class="comment">//while条件注释：如果没有把结点链在尾指针上，再试</span></span><br><span class="line">    CAS(Q-&gt;tail, p, n); <span class="comment">//置尾结点 tail = n;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，程序中的那个 do-while 的 Retry-Loop 中的 CAS 操作：如果 p-&gt;next 是 NULL，那么，把新结点 n 加到队尾。如果不成功，则重新再来一次！</p>
<p>就是说，很有可能我在准备在队列尾加入结点时，别的线程已经加成功了，于是tail指针就变了，于是我的CAS返回了false，于是程序再试，直到试成功为止。这个很像我们的抢电话热线的不停重播的情况。</p>
<p>但是你会看到，为什么我们的“置尾结点”的操作（第13行）不判断是否成功，因为：</p>
<ol>
<li>如果有一个线程T1，它的while中的CAS如果成功的话，那么其它所有的 随后线程的CAS都会失败，然后就会再循环，</li>
<li>此时，如果T1 线程还没有更新tail指针，其它的线程继续失败，因为tail-&gt;next不是NULL了。</li>
<li>直到T1线程更新完 tail 指针，于是其它的线程中的某个线程就可以得到新的 tail 指针，继续往下走了。</li>
<li>所以，只要线程能从 while 循环中退出来，意味着，它已经“独占”了，tail 指针必然可以被更新。<br>这里有一个潜在的问题——如果T1线程在用CAS更新tail指针的之前，线程停掉或是挂掉了，那么其它线程就进入死循环了。下面是改良版的EnQueue()<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">EnQueue</span>(Q, data) <span class="comment">//进队列改良版 v1</span></span><br><span class="line">&#123;</span><br><span class="line">    n = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">    n-&gt;value = data;</span><br><span class="line">    n-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p = Q-&gt;tail;</span><br><span class="line">    oldp = p</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span>( <span class="built_in">CAS</span>(p.next, <span class="literal">NULL</span>, n) != TRUE); <span class="comment">//如果没有把结点链在尾上，再试</span></span><br><span class="line">    <span class="built_in">CAS</span>(Q-&gt;tail, oldp, n); <span class="comment">//置尾结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>我们让每个线程，自己fetch 指针 p 到链表尾。但是这样的fetch会很影响性能。而且，如果一个线程不断的EnQueue，会导致所有的其它线程都去 fetch 他们的 p 指针到队尾，能不能不要所有的线程都干同一个事？这样可以节省整体的时间？</p>
<p>比如：直接 fetch Q-&gt;tail 到队尾？因为，所有的线程都共享着 Q-&gt;tail，所以，一旦有人动了它后，相当于其它的线程也跟着动了，于是，我们的代码可以改进成如下的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">EnQueue</span>(Q, data) <span class="comment">//进队列改良版 v2 </span></span><br><span class="line">&#123;</span><br><span class="line">    n = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">    n-&gt;value = data;</span><br><span class="line">    n-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="comment">//先取一下尾指针和尾指针的next</span></span><br><span class="line">        tail = Q-&gt;tail;</span><br><span class="line">        next = tail-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果尾指针已经被移动了，则重新开始</span></span><br><span class="line">        <span class="keyword">if</span> ( tail != Q-&gt;tail ) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果尾指针的 next 不为NULL，则 fetch 全局尾指针到next</span></span><br><span class="line">        <span class="keyword">if</span> ( next != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            <span class="built_in">CAS</span>(Q-&gt;tail, tail, next);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果加入结点成功，则退出</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">CAS</span>(tail-&gt;next, next, n) == TRUE ) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CAS</span>(Q-&gt;tail, tail, n); <span class="comment">//置尾结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，我们解决了EnQueue，我们再来看看DeQueue的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DeQueue</span>(Q) <span class="comment">//出队列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        p = Q-&gt;head;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ERR_EMPTY_QUEUE;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">CAS</span>(Q-&gt;head, p, p-&gt;next) != TRUE );</span><br><span class="line">    <span class="keyword">return</span> p-&gt;next-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，DeQueue的代码操作的是 head-&gt;next，而不是 head 本身。这样考虑是因为一个边界条件，我们需要一个dummy的头指针来解决链表中如果只有一个元素，head 和 tail 都指向同一个结点的问题，这样 EnQueue 和 DeQueue 要互相排斥了。</p>
<p>但是，如果 head 和 tail 都指向同一个结点，这意味着队列为空，应该返回 ERR_EMPTY_QUEUE，但是，在判断 p-&gt;next &#x3D;&#x3D; NULL 时，另外一个EnQueue操作做了一半，此时的 p-&gt;next 不为 NULL了，但是 tail 指针还差最后一步，没有更新到新加的结点，这个时候就会出现，在 EnQueue 并没有完成的时候， DeQueue 已经把新增加的结点给取走了，此时，队列为空，但是，head 与 tail 并没有指向同一个结点。<br>虽然，EnQueue的函数会把 tail 指针置对，但是，这种情况可能还是会导致一些并发问题，所以，严谨来说，我们需要避免这种情况。于是，我们需要加入更多的判断条件，还确保这个问题。下面是相关的改进代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DeQueue</span>(Q) <span class="comment">//出队列，改进版</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="comment">//取出头指针，尾指针，和第一个元素的指针</span></span><br><span class="line">        head = Q-&gt;head;</span><br><span class="line">        tail = Q-&gt;tail;</span><br><span class="line">        next = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Q-&gt;head 指针已移动，重新取 head指针</span></span><br><span class="line">        <span class="keyword">if</span> ( head != Q-&gt;head ) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是空队列</span></span><br><span class="line">        <span class="keyword">if</span> ( head == tail &amp;&amp; next == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERR_EMPTY_QUEUE;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果 tail 指针落后了</span></span><br><span class="line">        <span class="keyword">if</span> ( head == tail &amp;&amp; next == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            <span class="built_in">CAS</span>(Q-&gt;tail, tail, next);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移动 head 指针成功后，取出数据</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">CAS</span>( Q-&gt;head, head, next) == TRUE)&#123;</span><br><span class="line">            value = next-&gt;value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(head); <span class="comment">//释放老的dummy结点</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>文件描述符</title>
    <url>/2022/01/12/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="https://blog.csdn.net/qq327767852/article/details/50830192"></a><br>主要搞清文件描述符和系统级文件表和inode的对应关系</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式人工智能</title>
    <url>/2021/09/14/%E6%99%BA%E8%83%BD%E8%8A%AF%E7%89%87/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="嵌入式人工智能第六章"><a href="#嵌入式人工智能第六章" class="headerlink" title="嵌入式人工智能第六章"></a>嵌入式人工智能第六章</h3><ol>
<li><p>人工智能的发展</p>
<ol>
<li>机器学习（参考《机器学习》周志华，《统计学习方法》）<ol>
<li>模型评估方法</li>
<li>监督学习（分类，强化学习）</li>
<li>半监督学习，无监督学习（聚类）</li>
<li>集成学习</li>
<li>概率图模型</li>
<li>规则学习</li>
</ol>
</li>
<li>深度学习（参考《深度学习》）<ol>
<li>深度前馈网络</li>
<li>正则化</li>
<li>优化（梯度下降）</li>
<li>卷积网络（CNN）</li>
<li>RNN&#x2F;LSTM</li>
<li>其他前沿理论（配分函数和近似推断，自编码器，生成对抗网络，图神经网络）</li>
</ol>
</li>
</ol>
</li>
<li><p>硬件架构<br> 本小节主要介绍常用的处理器，在嵌入式端广泛运用在深度学习训练、推理过程的加速。</p>
<ol>
<li><p>GPU<br> 图像处理器。<br> GPU采用数量众多的计算单元和超长的流水线，善于处理图像领域的运算加速。但GPU无法单独工作，必须由CPU进行控制调用才能工作。CPU可单独作用，处理复杂的逻辑运算和不同的数据类型，但当需要大量的处理类型统一的数据时，则可调用GPU进行并行计算。深度学习的崛起受到GPU发展的推动。</p>
<ol>
<li>GPU发展历史</li>
<li>GPU功能</li>
<li>GPU物理架构(以Nvidia为例)<ol>
<li>NVidia Tesla架构（<a href="https://images.nvidia.cn/content/pdf/tesla/whitepaper/pascal-architecture-whitepaper.pdf%EF%BC%89">https://images.nvidia.cn/content/pdf/tesla/whitepaper/pascal-architecture-whitepaper.pdf）</a></li>
<li>NVidia Fermi架构</li>
<li>NVidia Maxwell架构</li>
<li>NVidia Kepler架构</li>
<li>NVidia Turing架构（<a href="https://images.nvidia.cn/aem-dam/en-zz/Solutions/design-visualization/technologies/turing-architecture/NVIDIA-Turing-Architecture-Whitepaper.pdf%EF%BC%89">https://images.nvidia.cn/aem-dam/en-zz/Solutions/design-visualization/technologies/turing-architecture/NVIDIA-Turing-Architecture-Whitepaper.pdf）</a></li>
</ol>
</li>
<li>GPU运行机制（[]<a href="http://haifux.org/lectures/267/Introduction-to-GPUs.pdf">http://haifux.org/lectures/267/Introduction-to-GPUs.pdf</a><br> <a href="http://download.nvidia.com/developer/cuda/seminar/TDCI_Arch.pdf%EF%BC%89">http://download.nvidia.com/developer/cuda/seminar/TDCI_Arch.pdf）</a><ol>
<li>渲染总览</li>
<li>逻辑管线</li>
<li>技术要点</li>
<li>GPU资源机制</li>
</ol>
</li>
<li>总结</li>
</ol>
</li>
<li><p>FPGA （Field Programmable Gate Array，现场可编程门阵列）<br> (这部分内容非常新，资料不多，很多是专利和未公开架构。如专利201880061751.0)<br> 半定制化的人工智能专用芯片。FPGA适用于多指令，单数据流的分析，与GPU相反，因此常用于预测阶段，如云端。（下面除5之外，参考《FPGA原理和结构》，在本书7.7章有深度学习结合FPGA，但过于简单）</p>
<ol>
<li>FPGA发展历史</li>
<li>FPGA构成要素和结构</li>
<li>FPGA工作原理</li>
<li>FPGA开发流程</li>
<li>FPGA AI芯片案例：DPU（资源连接：<a href="https://blogs.nvidia.com/blog/2020/05/20/whats-a-dpu-data-processing-unit/%EF%BC%89">https://blogs.nvidia.com/blog/2020/05/20/whats-a-dpu-data-processing-unit/）</a><ol>
<li>基本概念<br> DPU（Deep learning Processing Unit）深度学习处理器</li>
<li>工作原理</li>
<li>和CPU&#x2F;GPU优势</li>
</ol>
</li>
</ol>
</li>
<li><p>ASIC（Application Specific IntegratedCircuit）<br> ASIC是指依产品需求不同而定制化的特殊规格集成电路，由特定使用者要求和特定电子系统的需要而设计、制造。（参考《高级ASIC芯片综合》）</p>
<ol>
<li>基本概念</li>
<li>静态时序分析</li>
<li>设计约束和优化设计</li>
<li>物理综合</li>
<li>ASIC AI芯片案例<br> TPU（Tensor Processing Unit）<br> (参考论文 <a href="https://arxiv.org/ftp/arxiv/papers/1704/1704.04760.pdf">https://arxiv.org/ftp/arxiv/papers/1704/1704.04760.pdf</a>)<br> 张量处理器<br> 谷歌专门为加速深层神经网络运算能力而研发的一款芯片，其实也是一款ASIC。TPU与同期的CPU和GPU相比，可以提供15-30倍的性能提升，以及30-80倍的效率（性能&#x2F;瓦特）提升。<ol>
<li>架构</li>
<li>实现<br> <em>备选：NPU（（Neural network Processing Unit）<br> 神经网络处理器：用电路模拟人类的神经元和突触结构，将神经网络结构直接以硬件形式体现。但是没有找到相关论文。</em></li>
</ol>
</li>
</ol>
</li>
<li><p>总结与比较</p>
<ol>
<li><p>优缺点（能耗，推理速度，通用性，复杂程度，成本）<br> 例：</p>
<ul>
<li>GPU性能好，功耗高，通用性好。管理控制能力（最弱），功耗（最高）。</li>
<li>FPGA可编程，灵活程度介于GPU和ASIC之间。开发难度大、只适合定点运算、价格比较昂贵。</li>
<li>ASIC,作为集成电路技术与特定用户的整机或系统技术紧密结合的产物，与通用集成电路相比具有体积更小、重量更轻、 功耗更低、可靠性提高、性能提高、保密性增强、成本降低等优点。</li>
</ul>
</li>
<li><p>应用场景（大型高性能计算、通用嵌入式、定制化嵌入式）</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>软件框架<br> （主流<strong>开发</strong>框架是tensorflow和pytorch，嵌入式端一般有tensorlite，armnn，tensorrt和一些其他中间协议，但原理书籍几乎没有，下面以tensorflow为例，参考开源书《Tensorflow内核剖析》，下载地址<a href="https://raw.github.com/horance-liu/tensorflow-internals/master/tensorflow-internals.pdf%EF%BC%89">https://raw.github.com/horance-liu/tensorflow-internals/master/tensorflow-internals.pdf）</a></p>
<ol>
<li>依赖环境</li>
<li>系统架构<ol>
<li>Client</li>
<li>Master</li>
<li>Worker</li>
<li>Kernel</li>
</ol>
</li>
<li>图控制</li>
<li>会话管理</li>
<li>编程模型<ol>
<li>计算图</li>
<li>设备</li>
<li>会话</li>
<li>变量</li>
<li>队列</li>
</ol>
</li>
<li>嵌入式部署<br> 本小节主要介绍目前主流的嵌入式AI<strong>部署</strong>框架:<ol>
<li>基于硬件环境<ol>
<li>基于arm架构：armnn（<br> 官网 <a href="https://developer.arm.com/solutions/machine-learning-on-arm/developer-material/white-papers-and-research-papers">https://developer.arm.com/solutions/machine-learning-on-arm/developer-material/white-papers-and-research-papers</a><br> 软件地址：<a href="https://github.com/ARM-software/armnn%EF%BC%89">https://github.com/ARM-software/armnn）</a><ol>
<li>硬件设计（<a href="https://arxiv.org/pdf/1801.06274.pdf%EF%BC%89">https://arxiv.org/pdf/1801.06274.pdf）</a></li>
<li>软件优化（<a href="https://arxiv.org/pdf/1801.04326.pdf%EF%BC%89">https://arxiv.org/pdf/1801.04326.pdf）</a></li>
</ol>
</li>
<li>基于通用GPU&#x2F;CPU：tensorflow Lite(官网：<a href="https://www.tensorflow.org/lite?hl=zh-cn">https://www.tensorflow.org/lite?hl=zh-cn</a>)<br> 特点：</li>
</ol>
<ul>
<li>为不同端上优化的核心operator的解释器（Interpreter）打包成一个轻量的二进制包；</li>
<li>丰富的平台支持。Android和iOS设备、嵌入式Linux、微控制器设备等；</li>
<li>多语言API调用支持。Java, Swift, Objective-C, C++, and Python；</li>
<li>高性能。针对硬件精心优化的底层kernel实现，如预融合策略的激活和bias算子&#x2F;底层kernel；</li>
<li>模型优化工具。量化模型，该策略可在不影响精度的前提下减小模型尺寸；</li>
<li>高效模型格式。使用轻量的FlatBuffer（跨平台，且比protobuf性能好，最初为游戏和性能相关任务而开发）。</li>
</ul>
<ol start="3">
<li>其他框架：tensorRT</li>
</ol>
</li>
<li>基于编译方法：TVM（<a href="https://tvm.apache.org/%EF%BC%89">https://tvm.apache.org/）</a></li>
<li>基于文件格式：ONNX（<a href="https://onnx.ai/%EF%BC%89">https://onnx.ai/）</a></li>
<li>对比<ol>
<li>支持的平台</li>
<li>推理性能对比</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>综合案例</p>
<ol>
<li>评价标准<ol>
<li>模型精度（准确率，召回率，精确率，F值）</li>
<li>能耗</li>
<li>吞吐量和时延</li>
<li>能效比</li>
</ol>
</li>
<li>目标检测<ol>
<li>数据集（COCO）</li>
<li>算法：YOLO mobile&#x2F;YOLO v4</li>
<li>模型训练</li>
<li>模型部署</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>硬件架构</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器瓶颈</title>
    <url>/2022/02/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%93%B6%E9%A2%88%E5%9C%A8%E5%93%AA%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>服务器瓶颈</p>
<span id="more"></span>
<h3 id="瓶颈"><a href="#瓶颈" class="headerlink" title="瓶颈"></a>瓶颈</h3><ol>
<li><p>cpu<br>测试的时候cpu占用率70% 多核情况下占用60%</p>
</li>
<li><p>带宽<br>网络占用率</p>
</li>
<li><p>磁盘</p>
</li>
</ol>
<p>如果存在LOG日志写磁盘或者从磁盘映射文件，可能会存在瓶颈</p>
<ol start="4">
<li>处理流程</li>
</ol>
<p>epoll ET&#x2F;LT模式</p>
<ol start="5">
<li>进程能打开最大文件描述符数</li>
</ol>
<p>同时能打开65535个文件，但是一般情况下不可能并行打开这么多</p>
<ol start="6">
<li>数据库连接等等软件层面的限制</li>
</ol>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol>
<li><p>cpu<br>尽量利用多核优势，或者利用分布式进行负载均衡</p>
</li>
<li><p>带宽<br>增加网络带宽</p>
</li>
<li><p>磁盘<br>使用SSD，尽量减少磁盘IO次数</p>
</li>
<li><p>处理流程<br>各有优势，使用LT不容易犯错，使用ET模式更高效</p>
</li>
<li><p>进程能打开最大文件描述符</p>
</li>
</ol>
<p>这个一般不是瓶颈，在长链接情况下可能会成为瓶颈。</p>
]]></content>
      <categories>
        <category>场景设计</category>
      </categories>
      <tags>
        <tag>场景设计</tag>
      </tags>
  </entry>
  <entry>
    <title>海量数据问题</title>
    <url>/2022/02/03/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>海量数据问题</p>
<span id="more"></span>
<h2 id="海量日志找出现次数最多的记录"><a href="#海量日志找出现次数最多的记录" class="headerlink" title="海量日志找出现次数最多的记录"></a>海量日志找出现次数最多的记录</h2><ul>
<li>问题主要是记录不能全部载入到内存</li>
</ul>
<ol>
<li>先把整个文件分割成若干个小文件，比如1000个小文件</li>
<li>找出每个文件中出现次数最多的记录（输出1000个记录+频次）</li>
<li>从每个文件出现最多的记录找出全局出现次数最多的记录（合并记录，找出最多的频次）</li>
</ol>
<h2 id="统计topk个热门记录"><a href="#统计topk个热门记录" class="headerlink" title="统计topk个热门记录"></a>统计topk个热门记录</h2><ol>
<li>依次遍历这些文件，通过hash映射，将每个文件的每条数据映射到新构造的多个小文件中（设生成了nn个小文件）；</li>
<li>依次统计每个小文件中出现次数最多的kk条数据，构成hash表，hash表中每个键值对的形式为 dataItem: count；</li>
<li>利用堆排序，依次遍历这些hash表，在n∗kn∗k条数据中，找出count值最大的kk个；</li>
</ol>
<h2 id="海量数据查重"><a href="#海量数据查重" class="headerlink" title="海量数据查重"></a>海量数据查重</h2><ol>
<li>遍历A中的所有数据，通过hash映射将他们分布存储在n个小文件中，记为{a1,a2,…,an}；</li>
<li>遍历B中的所有数据，通过hash映射将他们分布存储在n个小文件中，记为{b1,b2,…,bn}；</li>
<li>根据hash函数性质可知，A和B中的相同数据一定被映射到序号相同的小文件，所以我们依次比较{ai,bi}即可；</li>
<li>如果问题更进一步，要求返回重复次数最多的k条数据，则可以将对比小文件找到的数据存入hash表，键为数据，值为该数据出现的次数。再用大小为k的堆，排序找出即可。</li>
</ol>
<h2 id="海量数据频率排序"><a href="#海量数据频率排序" class="headerlink" title="海量数据频率排序"></a>海量数据频率排序</h2><ol>
<li>顺序读文件，利用hash将相同的记录输出到相同的文件里。</li>
<li>每个小文件统计频率， 排序</li>
<li>归并排序(外部排序)<br><a href="https://www.cnblogs.com/codeMedita/p/7425291.html">外部排序参考</a></li>
</ol>
<h2 id="int数字重复数据查找（BitMap）"><a href="#int数字重复数据查找（BitMap）" class="headerlink" title="int数字重复数据查找（BitMap）"></a>int数字重复数据查找（BitMap）</h2><ul>
<li>例如：在2.5亿个整数里找不重复的整数</li>
</ul>
<ol>
<li>使用2bitmap算法， 00 代表没有出现，01表示出现一次，10表示出现多次。</li>
<li>计算下：整数4B，最多表示2^32个数，每个数用2个bit表示，就是2^32 * 2 &#x2F; 2^30 &#x2F; 8 &#x3D; 1G，注意那个8是B转bit。</li>
<li>然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</li>
</ol>
<ul>
<li>再例如：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？<br>原理和上面一样，使用1bitmap就可以了</li>
</ul>
<h2 id="超大文件求交集"><a href="#超大文件求交集" class="headerlink" title="超大文件求交集"></a>超大文件求交集</h2><ul>
<li>现有两个各有20亿行的文件，每一行都只有一个数字，求这两个文件的交集。</li>
</ul>
<ol>
<li>开辟128M的int数组。<ul>
<li>int最大表示4G，也就是需要2^32bit位， 一个int是4B，也就是32bit，因此需要2^32&#x2F;2^5&#x3D;2^27bit。</li>
</ul>
</li>
<li>对于每个数，先 &#x2F;32，确定在数组哪个位置，然后%32，确定在该int的哪一位，然后对这个数组取并集即可统计</li>
<li>如果存在正负数的话，设置正负两个bitmap然后分别求交集即可</li>
</ol>
<h2 id="超大文件字符串重复"><a href="#超大文件字符串重复" class="headerlink" title="超大文件字符串重复"></a>超大文件字符串重复</h2><ul>
<li>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url</li>
</ul>
<ol>
<li><p>分文件： </p>
<ul>
<li><p>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。 </p>
</li>
<li><p>遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</p>
</li>
</ul>
</li>
<li><p>逐个找重复：</p>
</li>
</ol>
<ul>
<li>求每对小文件中相同的url： 把其中一个小文件的url存储到hash_set中，然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</li>
</ul>
<h2 id="海量数据中位数（计数排序）"><a href="#海量数据中位数（计数排序）" class="headerlink" title="海量数据中位数（计数排序）"></a>海量数据中位数（计数排序）</h2><ul>
<li><p>只有2G内存的pc机，在一个存有10G个整数的文件，从中找到中位数，写一个算法。</p>
</li>
<li><p>分析：<br>  明显是一道工程性很强的题目，和一般的查找中位数的题目有几点不同。</p>
</li>
</ul>
<ol>
<li><p>原数据不能读进内存，不然可以用快速选择，如果数的范围合适的话还可以考虑桶排序或者计数排序，但这里假设是32位整数，仍有4G种取值，需要一个16G大小的数组来计数。</p>
</li>
<li><p>若看成从N个数中找出第K大的数，如果K个数可以读进内存，可以利用最小或最大堆，但这里K&#x3D;N&#x2F;2,有5G个数，仍然不能读进内存。</p>
</li>
</ol>
<ul>
<li>解法一：桶排序</li>
</ul>
<ol>
<li><p>读一遍10G个整数，把整数映射到256M个区段中，用一个64位无符号整数给每个相应区段记数。</p>
</li>
<li><p>从前到后对每一段的计数累加，当累加的和超过5G时停止，找出这个区段（即累加停止时达到的区段，也是中位数所在的区段）的数值范围，设为[a，a+15]，同时记录累加到前一个区段的总数，设为m。然后，释放除这个区段占用的内存。</p>
</li>
<li><p>再读一遍10G个整数，把在[a，a+15]内的每个值计数，即有16个计数。</p>
</li>
<li><p>对新的计数依次累加，每次的和设为n，当m+n的值超过5G时停止，此时的这个计数所对应的数就是中位数。</p>
</li>
</ol>
<ul>
<li><p>解法二：二进制分文件</p>
<p>  假设10亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制：1GB)，将每个数字用二进制表示，比较二进制的最高位(第32位)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。【这里的最高位类似于快速排序中的枢轴元素】</p>
<p>  从而将10亿个数字分成了两个文件（几乎是二分的），假设 file_0文件中有 6亿 个数字，file_1文件中有 4亿 个数字。那么中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 1亿 个数字。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>场景设计</category>
      </categories>
      <tags>
        <tag>场景设计</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode远程登录不上（command &#39;_workbench.downloadResource&#39; failed&quot; when connecting to a remote host via ssh）</title>
    <url>/2020/10/02/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%9Avscode%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>vscode Remote SSH 抽风系列：报错command ‘_workbench.downloadResource’ failed” when connecting to a remote host via ssh.   </p>
<ol>
<li>主要问题是我的远程Linux环境是连不上网的，我用本机Windows系统搭建了一个Apache服务器，Linux代理到本机端口实现访问外网。  </li>
<li>vscode Remote SSH连接的时候需要下载一个.vscode-server文件，vscode中一直显示下载失败。一直提示重新输入密码？？就不能提示下下载失败吗？？什么伞兵设置？</li>
</ol>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li><p>在你远程登录的那个文件夹下面找到<br>&#x2F;home&#x2F;.vscode-server&#x2F;bin&#x2F;ccbaa2d27e38e5afa3e5c21c1c7bef4657064247<br>这个文件，commitid就是后面那一串ccbaa2d27e38e5afa3e5c21c1c7bef4657064247 </p>
</li>
<li><p>手动下载  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://vscode.cdn.azure.cn/stable/$&#123;commit&#125;/vscode-server-linux-x64.tar.gz  </span><br></pre></td></tr></table></figure>
<p>或者在windows上下好scp上去</p>
</li>
<li><p>解压并且改名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf vscode-server.tar.gz</span><br><span class="line">mv vscode-server</span><br></pre></td></tr></table></figure></li>
<li><p><font color=red>设置下载结束标志</font></p>
</li>
</ol>
<p>注意这步很坑，如果没设置就会让你一直下，在这里卡了好久。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch vscode-scp-done.flag</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>重新连接就好了</li>
</ol>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>网络复习：HTTPS/TLS/SSL</title>
    <url>/2021/09/14/%E7%BD%91%E7%BB%9C%EF%BC%9AHTTPS&amp;TLS&amp;SSL/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="SSL-x2F-TLS"><a href="#SSL-x2F-TLS" class="headerlink" title="SSL&#x2F;TLS"></a>SSL&#x2F;TLS</h3><ol>
<li>基本流程</li>
</ol>
<ul>
<li>客户端想服务端索要并验证公钥。</li>
<li>双方协商生成对话密钥。</li>
<li>双方采用对话密钥进行加密通信。</li>
</ul>
<ol start="2">
<li>详细解释<br>上面流程的第一二两步叫做握手。如下图所示：<br><img src="/images/tls-1.png"><br>一共有四次通信，在握手阶段都是明文。</li>
</ol>
<ul>
<li>客户端发出请求（ClientHello）<br>  客户端主要向服务器提供以下信息<ul>
<li>支持的协议版本，比如TLS 1.0版。</li>
<li>一个客户端生成的随机数，稍后用于生成”对话密钥”。</li>
<li>支持的加密方法，比如RSA公钥加密。</li>
<li>支持的压缩方法。</li>
</ul>
</li>
<li>服务器回应（SeverHello）<br>  服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。<ul>
<li>确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</li>
<li>一个服务器生成的随机数，稍后用于生成”对话密钥”。</li>
<li>确认使用的加密方法，比如RSA公钥加密。</li>
<li>服务器证书。</li>
</ul>
</li>
<li>客户端回应<br> 客户端收到回应之后，首先验证证书，若没有问题，就从证书中取出公钥，然后发送下面三个信息：<ul>
<li>一个随机数。该随机数用服务器公钥加密，防止被窃听。</li>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</li>
</ul>
</li>
<li>服务器的最后回应<br>  服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。<ul>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/qq_38265137/article/details/90112705">关于TLS这篇文章讲的很详细</a></p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>https的流程大概是：</p>
<ol>
<li>与目标机器443端口tcp连接。</li>
<li>利用TLS协议获取服务器证书，与服务器通信商议对称密钥，此后报文通过对称加密保护。</li>
<li>使用普通http传输报文。</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络复习：PING &amp; traceroute命令原理</title>
    <url>/2021/09/14/%E7%BD%91%E7%BB%9C%EF%BC%9APING%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>ping 基于ICMP协议，ICMP 主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。<br>ICMP报文格式如下，封装在IP包里面，工作在网络层：<br><img src="/images/icmp-1.png"></p>
<p>ICMP从类别上大概分为查询报文和差错报文。<br><img src="/images/icmp-2.png"></p>
<h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h3><p>ping命令基于ICMP查询报文设计，原理是用类型码为8的ICMP发请 求，受到请求的主机则用类型码为0的ICMP回应。<br>ping首先通过arp协议广播请求目的主机的MAC地址，得到MAC地址之后发送请求报文。<br>回送应答报文格式如下：<br><img src="/images/ping-1.png"><br>和原始ICMP报文不同之处就是新增加了标识符和序号，标识符通常包含PID，序号从0开始，每次发送加1，可以确认网络包是否丢失。<br>PING命令的总体流程如下图所示<br><img src="/images/ping-2.png"></p>
<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>Traceroute的原理是非常非常的有意思，它受到目的主机的IP后，首先给目的主机发送一个TTL&#x3D;1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL&#x3D;2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器ip。从而避开了ip头只能记录有限路由IP的问题。</p>
<p>有人要问，我怎么知道UDP到没到达目的主机呢？这就涉及一个技巧的问题，TCP和UDP协议有一个端口号定义，而普通的网络程序只监控少数的几个号码较 小的端口，比如说80,比如说23,等等。而traceroute发送的是端口号&gt;30000(真变态)的UDP报，所以到达目的主机的时候，目的 主机只能发送一个端口不可达的ICMP数据报给主机。主机接到这个报告以后就知道，主机到了。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络复习：TCP &amp; UDP</title>
    <url>/2021/09/14/%E7%BD%91%E7%BB%9C%EF%BC%9ATCP%20&amp;%20UDP/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>TCP&#x2F;IP五层模型<br><img src="/images/tcp-1.png"></p>
<ul>
<li>物理层：负责光&#x2F;电信号的传递方式。 比如现在以太网通用的网线(双绞线)、早期以太网采用的的同轴电缆 (现在主要用于有线电视)、光纤，现在的wiﬁ无线网使用电磁波等都属于物理层的概念。物理层的能力决定了最大传输速率、传输距离、抗干扰性等。集线器(Hub)工作在物理层，集线器的主要作用是放大信号。</li>
<li>数据链路层：负责设备之间的数据帧的传送和识别。例如网卡设备的驱动、帧同步(就是说从网线上检测到什么信号算作新帧的开始)、冲突检测(如果检测到冲突就自动重发)、数据差错校验等工作。 有以太网、令牌环网、 无线LAN等标准。 交换机(Switch)工作在数据链路层。</li>
<li>网络层：负责地址管理和路由选择。例如在IP协议中，通过IP地址来标识一台主机，并通过路由表的方式规划出两台主机之间的数据传输的线路(路由)。 路由器(Router)工作在网路层。</li>
<li>应用层: 负责应用程序间沟通。如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问 协议（Telnet）等。 网络编程主要就是针对应用层。</li>
</ul>
<p>对于一台计算机，它的操作系统实现了从传输层到物理层<br>对于一个路由器，实现了从网络层到物理层<br>对于交换机，实现了从数据链路层到物理层<br>对于集线器，只实现了物理层  </p>
<p><img src="/images/tcp-2.png"></p>
<h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><p>TCP数据被封装在ip数据包中。<br><img src="/images/tcp-3.png"></p>
<p>TCP头部为20字节源端口号（16位）和目的端口号（16位），再加上Ip首部的源IP地址和目的IP地址可以唯一确定一个TCP连接  </p>
<ul>
<li>数据序号（16位）：表示在这个报文段中的第一个数据字节序号；</li>
<li>确认序号：仅当ACK标志为1时有效，确认号表示期望收到的下一个字节的序号偏移：就是头部长度，有4位，跟IP头部一样，以4字节为单位。最大是60个字节；</li>
<li>保留位：6位，必须为0；</li>
<li>6个标志位：URG-紧急指针有效；ACK-确认序号有效；PSH-接收方应尽快将这个报文交给应用层；RST-连接重置；SYN-同步序号用来发起一个连接；FIN-终止一个连接；</li>
<li>窗口字段：16位，代表的是窗口的字节容量，也就是TCP的标准窗口最大为2^16 - 1 &#x3D; 65535个字节</li>
<li>校验和：源机器基于数据内容计算一个数值，收信息机要与源机器数值结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="/images/tcp-4.png"></p>
<ul>
<li>第一次握手：客户端发送位码为 SYN &#x3D; 1（SYN 标志位置位），随机产生初始序列号 Seq &#x3D; J 的数据包到服务器。服务器由 SYN &#x3D; 1（置位）知道，客户端要求建立联机。</li>
<li>第二次握手：服务器收到请求后要确认联机信息，向客户端发送确认号Ack &#x3D; （客户端的Seq +1，J+1），SYN &#x3D; 1，ACK &#x3D; 1（SYN，ACK 标志位置位），随机产生的序列号 Seq &#x3D; K 的数据包。</li>
<li>第三次握手：客户端收到后检查 Ack 是否正确，即第一次发送的 Seq +1（J+1），以及位码ACK是否为1。若正确，客户端会再发送 Ack &#x3D; （服务器端的Seq+1，K+1），ACK &#x3D; 1，以及序号Seq为服务器确认号J 的确认包。服务器收到后确认之前发送的 Seq（K+1） 值与 ACK&#x3D; 1 （ACK置位）则连接建立成功。</li>
</ul>
<p>Q：为什么是三次握手？<br>A：三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。<br>第一次握手，发送端：什么都确认不了；接收端：对方发送正常，自己接受正常；<br>第二次握手，发送端：对方发送，接受正常，自己发送，接受正常 ；接收端：对方发送正常，自己接受正常；<br>第三次握手，发送端：对方发送，接受正常，自己发送，接受正常；接收端：对方发送，接受正常，自己发送，接受正常。 </p>
<p>Q：两次握手不行吗？为什么TCP客户端最后还要发送一次确认呢？<br>A：主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。<br>经典场景：客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<p>Q：TCP三次握手中，最后一次回复丢失，会发生什么？<br>A：如果最后一次ACK在网络中丢失，那么Server端（服务端）该TCP连接的状态仍为SYN_RECV，并且根据 TCP的超时重传机制依次等待3秒、6秒、12秒后重新发送 SYN+ACK 包，以便 Client（客户端）重新发送ACK包；<br>如果重发指定次数后，仍然未收到ACK应答，那么一段时间后，Server（服务端）自动关闭这个连接；<br>但是Client（客户端）认为这个连接已经建立，如果Client（客户端）端向Server（服务端）发送数据，Server端（服务端）将以RST包（Reset，标示复位，用于异常的关闭连接）响应，此时，客户端知道第三次握手失败。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="/images/tcp-5.png"></p>
<p>这里我们假定客户端主动关闭（实际上谁先执行主动关闭没本质区别，通话结束了，谁先挂断没啥区别）：</p>
<ul>
<li>客户端发送一个FIN Seq &#x3D; M（FIN置位，序号为M）包，用来关闭客户端到服务器端的数据传送。</li>
<li>服务器端收到这个FIN，它发回一个ACK，确认序号Ack 为收到的序号M+1。</li>
<li>服务器端关闭与客户端的连接，发送一个FIN Seq &#x3D; N 给客户端。</li>
<li>客户端发回ACK 报文确认，确认序号Ack 为收到的序号N+1。</li>
</ul>
<p>Q：为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>A：建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了,所以服务器可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接。因此，服务器ACK和FIN一般都会分开发送，从而导致多了一次。 </p>
<p>Q：为什么TCP挥手每两次中间有一个 FIN-WAIT2等待时间？<br>A：主动关闭的一端调用完close以后（即发FIN给被动关闭的一端， 并且收到其对FIN的确认ACK则进入FIN_WAIT_2状态。如果这个时候因为网络突然断掉、被动关闭的一段宕机等原因，导致主动关闭的一端不能收到被动关闭的一端发来的FIN（防止对端不发送关闭连接的FIN包给本端），这个时候就需要FIN_WAIT_2定时器， 如果在该定时器超时的时候，还是没收到被动关闭一端发来的FIN，那么直接释放这个链接，进入CLOSE状态。 </p>
<p>Q：为什么客户端最后还要等待2MSL？ 为什么还有个TIME-WAIT的时间等待？<br>A：保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，服务器已经发送了FIN+ACK报文，请求断开，客户端却没有回应，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，这样新的连接中不会出现旧连接的请求报文。2MSL，最大报文生存时间，一个MSL 30 秒，2MSL &#x3D; 60s。 </p>
<p>Q：客户端 TIME-WAIT 状态过多会产生什么后果？怎样处理？<br>A：作为服务器，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，占据大量的tuple &#x2F;tApl&#x2F; ，严重消耗着服务器的资源，此时部分客户端就会显示连接不上，作为客户端，短时间内大量的短连接，会大量消耗的Client机器的端口，毕竟端口只有65535个，端口被耗尽了，后续就无法在发起新的连接了在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上高并发可以让服务器在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。<br>解决方法：用负载均衡来抗这些高并发的短请求；服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，TIME_WAIT 状态可以通过优化服务器参数得到解决，因为发生TIME_WAIT的情况是服务器自己可控的，要么就是对方连接的异常，要么就是自己没有迅速回收资源，总之不是由于自己程序错误导致的强制关闭，发送 RST 包越过TIMEWAIT状态，直接进入CLOSED状态。  </p>
<p>Q：服务器出现了大量 CLOSE_WAIT 状态如何解决？<br>A：大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。  </p>
<p>Q：服务端会有一个TIME_WAIT状态吗？如果是服务端主动断开连接呢？<br>A：发起链接的主动方基本都是客户端，但是断开连接的主动方服务器和客户端都可以充当，也就是说，只要是主动断开连接的，就会有 TIME_WAIT状态四次挥手是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发由于TCP连接时全双工的，因此，每个方向的数据传输通道都必须要单独进行关闭。</p>
<h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>下图展示了三次握手、数据传输、四次挥手过程的状态图。<br><img src="/images/tcp-6.png"><br>下图是经典的TCP状态转移图：<br><img src="/images/tcp-7.png"></p>
<p>上半部分是三次握手的状态转移，下半部分是四次挥手的状态转移。</p>
<ol>
<li>CLOSED：起始点，在超时或者连接关闭时候进入此状态，这并不是一个真正的状态，而是这个状态图的假想起点和终点。</li>
<li>LISTEN：服务器端等待连接的状态。服务器经过 socket，bind，listen 函数之后进入此状态，开始监听客户端发过来的连接请求。此称为应用程序被动打开（等到客户端连接请求）。</li>
<li>SYN_SENT：第一次握手发生阶段，客户端发起连接。客户端调用 connect，发送 SYN 给服务器端，然后进入 SYN_SENT 状态，等待服务器端确认（三次握手中的第二个报文）。如果服务器端不能连接，则直接进入CLOSED状态。</li>
<li>SYN_RCVD：第二次握手发生阶段，跟 3 对应，这里是服务器端接收到了客户端的 SYN，此时服务器由 LISTEN 进入 SYN_RCVD状态，同时服务器端回应一个 ACK，然后再发送一个 SYN 即 SYN+ACK 给客户端。状态图中还描绘了这样一种情况，当客户端在发送 SYN 的同时也收到服务器端的 SYN请求，即两个同时发起连接请求，那么客户端就会从 SYN_SENT 转换到 SYN_REVD 状态。</li>
<li>ESTABLISHED：第三次握手发生阶段，客户端接收到服务器端的 ACK 包（ACK，SYN）之后，也会发送一个 ACK 确认包，客户端进入 ESTABLISHED 状态，表明客户端这边已经准备好，但TCP 需要两端都准备好才可以进行数据传输。服务器端收到客户端的 ACK 之后会从 SYN_RCVD 状态转移到 ESTABLISHED 状态，表明服务器端也准备好进行数据传输了。这样客户端和服务器端都是 ESTABLISHED 状态，就可以进行后面的数据传输了。所以 ESTABLISHED 也可以说是一个数据传送状态。</li>
</ol>
<p>结合第一张三次握手过程图，从报文的角度看状态变迁：SYN_SENT 状态表示已经客户端已经发送了 SYN 报文，SYN_RCVD 状态表示服务器端已经接收到了 SYN 报文。<br>下面看看TCP四次挥手过程的状态变迁。</p>
<ol>
<li>FIN_WAIT_1：第一次挥手。主动关闭的一方（执行主动关闭的一方既可以是客户端，也可以是服务器端，这里以客户端执行主动关闭为例），终止连接时，发送 FIN 给对方，然后等待对方返回 ACK 。调用 close() 第一次挥手就进入此状态。</li>
<li>CLOSE_WAIT：接收到FIN 之后，被动关闭的一方进入此状态。具体动作是接收到 FIN，同时发送 ACK。之所以叫 CLOSE_WAIT 可以理解为被动关闭的一方此时正在等待上层应用程序发出关闭连接指令。前面已经说过，TCP关闭是全双工过程，这里客户端执行了主动关闭，被动方服务器端接收到FIN 后也需要调用 close 关闭，这个 CLOSE_WAIT 就是处于这个状态，等待发送 FIN，发送了FIN 则进入 LAST_ACK 状态。</li>
<li>FIN_WAIT_2：主动端（这里是客户端）先执行主动关闭发送FIN，然后接收到被动方返回的 ACK 后进入此状态。</li>
<li>LAST_ACK：被动方（服务器端）发起关闭请求，由状态2 进入此状态，具体动作是发送 FIN给对方，同时在接收到ACK 时进入CLOSED状态。</li>
<li>CLOSING：两边同时发起关闭请求时（即主动方发送FIN，等待被动方返回ACK，同时被动方也发送了FIN，主动方接收到了FIN之后，发送ACK给被动方），主动方会由FIN_WAIT_1 进入此状态，等待被动方返回ACK。</li>
<li>TIME_WAIT：从状态变迁图会看到，四次挥手操作最后都会经过这样一个状态然后进入CLOSED状态。共有三个状态会进入该状态<ul>
<li>由CLOSING进入：同时发起关闭情况下，当主动端接收到ACK后，进入此状态，实际上这里的同时是这样的情况：客户端发起关闭请求，发送FIN之后等待服务器端回应ACK，但此时服务器端同时也发起关闭请求，也发送了FIN，并且被客户端先于ACK接收到。</li>
<li>由FIN_WAIT_1进入：发起关闭后，发送了FIN，等待ACK的时候，正好被动方（服务器端）也发起关闭请求，发送了FIN，这时客户端接收到了先前ACK，也收到了对方的FIN，然后发送ACK（对对方FIN的回应），与CLOSING进入的状态不同的是接收到FIN和ACK的先后顺序。</li>
<li>由FIN_WAIT_2进入：这是不同时的情况，主动方在完成自身发起的主动关闭请求后，接收到了对方发送过来的FIN，然后回应 ACK。</li>
</ul>
</li>
</ol>
<h4 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h4><ol>
<li>提供校验和：校验和计算三个部分，TCP首部，TCP数据，TCP伪首部（12字节）。</li>
<li>序列号应答机制：发送端如果没有收到确认回复，都会重发。</li>
<li>超时重传：发出数据包后如果在规定时间没有收到确认就会重发。</li>
<li>最大消息长度：在建立TCP连接时，会约定消息发送的最大长度，一般是IP层和数据链路层的最小值。</li>
<li>滑动窗口：使用缓冲区技术在没有收到确认的情况下也能继续发数据包，但是如果收到三次相同的确认数据包，则会重传。</li>
<li>拥塞控制：慢启动+拥塞控制<a href="https://haoqinx.github.io/2021/09/14/%E7%BD%91%E7%BB%9C%EF%BC%9ATCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">见下篇文章</a>.</li>
</ol>
<h4 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h4><p>糊涂窗口综合症是指当发送端应用进程产生数据很慢、或接收端应用进程处理接收缓冲区数据很慢，或二者兼而有之；就会使应用进程间传送的报文段很小，特别是有效载荷很小； 极端情况下，有效载荷可能只有1个字节；传输开销有40字节(20字节的IP头+20字节的TCP头) 这种现象。</p>
<ol>
<li>发送端引起<br>发送报文字节数很少。<br>针对发送方来说，发送方不要发送太小的报文，而是把数据积累成一个足够大的报文段（达到 MSS），或者是积累到接收方通告窗口大小一半的报文段。</li>
<li>接受端引起<br>接收端消耗数据速度太慢。</li>
</ol>
<ul>
<li>Clark解决方法：Clark解决方法是只要有数据到达就发送确认，但宣布的窗口大小为零，直到或者缓存空间已能放入具有最大长度的报文段，或者缓存空间的一半已经空了。</li>
<li>延迟的确认：第二个解决方法是延迟一段时间后再发送确认。这表示当一个报文段到达时并不立即发送确认。接收端在确认收到的报文段之前一直等待，直到入缓存有足够的空间为止。延迟的确认防止了发送端的TCP滑动其窗口。</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>UDP是传输层的协议，功能即为在IP的数据报服务之上增加了最基本的服务：复用和分用以及差错检测。<br>UDP提供不可靠服务，具有TCP所没有的优势</p>
<ul>
<li>无连接，时间上不存在建立链接需要的时延。</li>
<li>分组首部开销小，8字节。</li>
<li>没有拥塞控制。</li>
<li>尽最大努力交付，不保证可靠交付。</li>
<li>面向报文。对应用层交下来的报文，添加首部后直接乡下交付为IP层，既不合并，也不拆分，保留这些报文的边界。对IP层交上来UDP用户数据报，在去除首部后就原封不动地交付给上层应用进程，报文不可分割，是UDP数据报处理的最小单位。</li>
<li>UDP常用一次性传输比较少量数据的网络应用。如DNS，SNMP等等。</li>
</ul>
<h4 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h4><p><img src="/images/udp-1.png"></p>
<ul>
<li>UDP数据报长度：包括首部和数据总长度。</li>
</ul>
<h4 id="udp保证可靠性"><a href="#udp保证可靠性" class="headerlink" title="udp保证可靠性"></a>udp保证可靠性</h4><ul>
<li>接收方收到包之后回复确认包。</li>
<li>发送方收不到确认包就重新发送。</li>
<li>防止网络差丢包越重传的恶性循环，增加发送窗口限制。<br><a href="https://zhuanlan.zhihu.com/p/129218784">可以参考这个</a></li>
</ul>
<h4 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h4><p>QUIC 具有下面的优点：</p>
<ul>
<li>减少了 TCP 三次握手及 TLS 握手时间。</li>
<li>改进的拥塞控制。</li>
<li>避免队头阻塞的多路复用。</li>
<li>连接迁移。</li>
<li>前向冗余纠错。<br><a href="https://zhuanlan.zhihu.com/p/32553477">可以参考这个文章</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络复习：TCP滑动窗口、拥塞控制</title>
    <url>/2021/09/14/%E7%BD%91%E7%BB%9C%EF%BC%9ATCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="固定窗口的问题"><a href="#固定窗口的问题" class="headerlink" title="固定窗口的问题"></a>固定窗口的问题</h4><p><img src="/images/tcp-2-1.png"><br>我们假设这个固定窗口的大小为1，也就是每次只能发送一个数据，只有接收方对这个数据进行了确认后才能发送第二个数据。在图中我们可以看到，发送方每发送一个数据接收方就要给发送方一个ACK对这个数据进行确认。只有接收了这个确认数据以后发送方才能传输下个数据。<br>这样大大降低了网络吞吐量。</p>
<h4 id="滑动窗口-1"><a href="#滑动窗口-1" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>为了解决上面这个问题，使用滑动窗口算法：<br><img src="/images/tcp-1-2.png"><br>发送主机在发送了一个段之后不必要一直等，而是继续发送。窗口大小为无需等待可以继续发送数据的最大值。<br>发送窗口的大小是怎么确定的？</p>
<h4 id="窗口控制和重发控制"><a href="#窗口控制和重发控制" class="headerlink" title="窗口控制和重发控制"></a>窗口控制和重发控制</h4><ol>
<li>应答丢失<br><img src="/images/tcp-2-2.png"></li>
</ol>
<p>某些确认应答丢失也无需重发。<br>2. 报文丢失<br><img src="/images/tcp-2-3.png"><br>发送端收到三个相同的确认应答就对数据进行重发。</p>
<ol start="3">
<li>流控制<br>上述模型存在的问题：</li>
</ol>
<ul>
<li><p>如果窗口过小，当传输比较大的数据的时候需要不停的对数据进行确认，这个时候就会造成很大的延迟。</p>
</li>
<li><p>如果窗口过大，我们假设发送方一次发送100个数据，但接收方只能处理50个数据，这样每次都只对这50个数据进行确认。发送方下一次还是发送100个数据，但接受方还是只能处理50个数据。这样就避免了不必要的数据来拥塞我们的链路。<br>于是提出流控制方法：<br><img src="/images/tcp-2-4.png"></p>
</li>
<li><p>第一部分<br>发送端根据当前链路带宽大小决定发送数据包的窗口大小。这里，窗口大小为 3，表示可以发送 3 个数据包。因此发送端发送了 3 个数据包，分别为 1-1000、1001-2000 和 2001-3000。<br>接收端接收这些数据包，但是只能处理 2 个数据包，第 3 个数据包 2001-3000 没有被处理。因此返回确认应答包，设置窗口大小为 2，告诉发送端自己现在只能处理 2 个数据包，下一次请发送 2 个数据包。</p>
</li>
<li><p>第二部分<br>发送端接收到确认应答包，查看到接收端返回窗口大小为 2，知道接收端只处理了 2 个数据包。发过去的第 3 个数据包 2001-3000 没有被处理。这说明此时接收端只能处理 2 个数据包，第 3 个数据包还需要重新发送。因此发送端发送 2 个数据包 2001-3000 和 3001-4000。接收端收到这两个数据包并进行了处理。此时，还是只能处理 2 个窗口，继续向发送端发送确认应答包，设置窗口为 2，告诉发送端，下一个应该接收 4001 的数据包。</p>
</li>
<li><p>第三部分<br>发送端接收到确认应答包，查看到接收端返回窗口大小为 2。说明接收端接收了上次发送的 2 个数据包。此时仍然可以处理 2 个数据包，继续发送数据包 4001-5000 和 5001-6000。如果在接收端返回的确认应答包中，窗口设置为 0，则表示现在不能接收任何数据。这时，发送端将不会再发送数据包，只有等待接收端发送窗口更新通知才可以继续发送数据包。如果这个更新通知在传输中丢失了，那么就可能导致无法继续通信。为了避免这样的情况发生，发送端会时不时地发送窗口探测包，该包仅有1个字节，用来获取最新的窗口大小的信息。</p>
</li>
</ul>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>有了TCP窗口控制，通信双方不再使用数据段为单位发送确认应答，但是如果在通信刚开始就发送大量数据，会引发网络拥堵等其他问题。<br>为了防止上述问题，TCP通过慢启动算法进行拥塞控制。</p>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p><img src="/images/tcp-2-5.png"><br>发送个过程中比较接收端窗口和拥塞窗口，选最小值作为窗口大小。<br>下图展示了TCP窗口变化：<br><img src="/images/tcp-2-6.png"></p>
<ul>
<li>开始不设置阈值，当超时重发设置为拥塞窗口的一半；</li>
<li>每经过一个轮次，拥塞窗口 *&#x3D; 2。</li>
</ul>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：</p>
<ul>
<li><p>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</p>
</li>
<li><p>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>
</li>
<li><p>当 cwnd &#x3D; ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。<br><img src="/images/tcp-2-7.png"></p>
</li>
<li><p>当TCP连接进行初始化时，把拥塞窗口cwnd置为1。慢启动门限的初始值设置为16个报文段，即 cwnd &#x3D; 16 。</p>
</li>
<li><p>在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。拥塞窗口cwnd 随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd&#x3D;16时），就改为执行拥塞控制算法，拥塞窗口按线 性规律增长。</p>
</li>
<li><p>假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值 24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd&#x3D;ssthresh&#x3D;12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过 一个往返时间增加一个MSS的大小。</p>
</li>
</ul>
<h4 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h4><p><img src="/images/tcp-2-8.png"></p>
<ul>
<li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</li>
<li>由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络复习：HTTP1.0/1.1/2.0</title>
    <url>/2021/09/14/%E7%BD%91%E7%BB%9C%EF%BC%9Ahttp/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><p>每一个请求建立一个TCP连接，请求完成后立马断开连接。这将会导致2个问题：连接无法复用，head of line blocking<br>连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。head of line blocking会导致带宽无法被充分利用，以及后续健康请求被阻塞.</p>
<h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><p>HTTP1.0每次请求都需要建立TCP连接，请求结束之后需要断开连接。为了克服这个缺陷，1.1升级了下面这些功能：</p>
<ul>
<li>支持长连接：在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</li>
<li>支持虚拟主机（host字段），一个服务器可以放置多个网站，充分利用服务器资源。</li>
<li>流水线：包含多个请求和应答可以在一个tcp连接中传输。但是线头阻塞可能会影响性能。</li>
<li>带宽优化：支持断点续传。</li>
<li>缓存策略：强缓存（ Cache-Control 浏览器命中的缓存），协商缓存（当浏览器没有命中强缓存后，便会命中协商缓存）。</li>
</ul>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><p>HTTP2.0的新特性主要有下面几点：</p>
<ul>
<li>多路复用：做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</li>
<li>数据压缩：使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</li>
<li>服务器推送：对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。</li>
<li>二进制分帧：应用层(HTTP&#x2F;2)和传输层(TCP or UDP)之间增加一个二进制分帧层。（HTTP 1.X 是基于文本的，因为是文本，就导致了它必须是个整体，在传输是不可切割的，只能整体去传。但 HTTP 2.0 是基于二进制流的。）</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>聚集索引和非聚集索引</title>
    <url>/2021/12/02/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="https://blog.csdn.net/riemann_/article/details/90324846">看这一篇应该就够了</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker底层原理：CGroup &amp; Namespace</title>
    <url>/2021/09/14/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%9Adocker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p><a href="https://blog.csdn.net/zhonglinzhang/article/details/64905759">参考这篇文章</a></p>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>设计一个rpc框架需要考虑什么？</title>
    <url>/2020/10/02/%E8%AE%BE%E8%AE%A1rpc%E6%A1%86%E6%9E%B6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h3><p>分布式系统常见通信方式，RPC就是一台机器上通过参数传递的方式调用另一台机器的一个函数或方法并返回结果。</p>
<h3 id="Call-ID映射"><a href="#Call-ID映射" class="headerlink" title="Call ID映射"></a>Call ID映射</h3><p>在本地调用中，我们可以通过函数指针指定函数体，调用具体函数，然后编译器就会帮我们调用相应的函数指针；但是在远程调用中，因为两个进程的地址空间不一样，所以无法通过调用函数指针调用函数。所以，在RPC中，所有函数必须有一个唯一的ID，在客户端和服务端分别维护一个 {函数 &lt;–&gt; Call ID} 的对应表。当客户端需要进行远程调用时，基于调用的函数查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</p>
<h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><p>有时候客户端和服务端使用的都不是同一种语言。<br>这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</p>
<h3 id="多传输协议支持"><a href="#多传输协议支持" class="headerlink" title="多传输协议支持"></a>多传输协议支持</h3><p>Http、dubbo传输协议优缺点</p>
<h3 id="注册中心支持"><a href="#注册中心支持" class="headerlink" title="注册中心支持"></a>注册中心支持</h3><p>解决分布式架构中，一个服务势必会有多个实例，如何获取实例的问题。<br>可以使用Zookeeper作为注册中心，在调用时，从Zookeeper获取服务的实例列表，再从中选择一个进行调用。</p>
<h3 id="异步调用AIO"><a href="#异步调用AIO" class="headerlink" title="异步调用AIO"></a>异步调用AIO</h3><h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3>]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title>大总结</title>
    <url>/2021/09/14/%E8%87%AA%E9%97%AE%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="https://leetcode-cn.com/circle/discuss/XXGdoF/">终极总结</a></p>
<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><ol>
<li>对const的理解？const指针和引用的区别？</li>
<li>#define和const的区别？</li>
<li>说说static关键字的用法？<br><a href="https://blog.csdn.net/ypshowm/article/details/89030194">https://blog.csdn.net/ypshowm/article/details/89030194</a></li>
<li>inline函数的使用？</li>
<li>知道#pragma pack(n)吗？怎么实现内存对齐的？</li>
<li>解释下”extern C”，在什么时候会用到？</li>
<li>用struct实现下继承？</li>
<li>解释下friend关键字？</li>
<li>多态的实现方式？</li>
<li>虚析构函数？虚构造函数？</li>
<li>说说虚表的内存布局？</li>
<li>纯虚函数？虚继承？</li>
<li>模板继承？模板特化&#x2F;偏特化？</li>
<li>虚函数可以是内联函数吗？</li>
<li>构造函数能是虚函数吗，析构函数呢？</li>
<li>c++四大强制类型转换？</li>
<li>四大类型转换发生的时间？编译&#x2F;执行</li>
<li>构造函数初始化列表和函数内部赋值的区别？</li>
</ol>
<h1 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h1><ol>
<li>decltype用过吗?</li>
<li>左值引用和右值引用是什么？</li>
<li>移动语义和完美转发说说？</li>
<li>智能指针有哪些？</li>
<li>说说每个的实现原理和应用场景？</li>
<li></li>
</ol>
<h1 id="C-内存"><a href="#C-内存" class="headerlink" title="C++内存"></a>C++内存</h1><ol>
<li>new&#x2F;delete 和malloc&#x2F;free区别？</li>
<li>ralloc&#x2F;alloca</li>
<li>双重free会发生什么？</li>
<li>如何定义一个只能在栈&#x2F;堆上生成的对象？</li>
<li>讲下ptmalloc？</li>
<li>讲下tcmalloc？</li>
<li>讲下jemalloc？</li>
<li>知道哪些强制类型转换？（static_cast等)</li>
</ol>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><ol>
<li>五大组成部分？</li>
<li>有哪些容器？</li>
<li>vector&#x2F;map&#x2F;哈希&#x2F;deque底层实现？</li>
<li>sort算法实现是什么？全都是快排吗？</li>
</ol>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><ol>
<li>TCP三次握手，四次挥手详细流程？</li>
<li>三次握手两次行不行？</li>
<li>sock函数和三次握手的对应？</li>
<li>服务器大量TIME_WAIT怎么办？</li>
<li>TCP粘包？</li>
<li>TCP拥塞控制？</li>
<li>http1.0&#x2F;1.1&#x2F;2.0区别？</li>
<li>TLS&#x2F;HTTPS握手过程？</li>
<li>ARP协议？</li>
<li>PING命令实现原理？</li>
<li>Traceroute命令实现原理？</li>
</ol>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ol>
<li>进程和线程？</li>
<li>内核态和用户态？</li>
<li>进程间通信方式每个详细说？优缺点？</li>
<li>线程间通信方式详细说？</li>
<li>进程线程拥有的资源集合？</li>
<li>讲讲死锁？</li>
<li>线程池实现一下？</li>
<li>主机字节序和网络字节序？如何判断大端小端？写个程序。</li>
<li>虚拟内存？</li>
<li>页表工作原理，MMU底层原理？</li>
<li>进程虚拟空间地址text段下面保留的128M空间是干嘛的，为什么不能是256M？<ul>
<li>128M空间是保留的C语言库，至于为啥不是256M，目前未知（节省空间？）.</li>
</ul>
</li>
</ol>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ol>
<li>B树&#x2F;B+树&#x2F;红黑树有什么区别？</li>
<li>红黑树旋转？</li>
<li>排序算法复杂度？</li>
</ol>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ol>
<li>MYSQL索引作用？索引失效？</li>
<li>MYSQL引擎？</li>
<li>MYSQL锁？</li>
<li>MYSQL事务？</li>
<li>实现一个堆？</li>
</ol>
<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><ol>
<li>redis基本数据结构？</li>
<li>redis跳表？具体操作插入删除？</li>
<li>redis的zset？</li>
<li>redis缓存策略？</li>
<li>redis淘汰策略？</li>
<li>redis哨兵模式、集群模式？</li>
<li>redis哨兵模式和集群模式优缺点？</li>
<li>redis持久化？</li>
<li>redis缓存和主库不一致？</li>
</ol>
<h1 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h1><h1 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h1><ol>
<li>有十个机器，九个生产的金币是5g，只有一个生产是4g，给你一个称，怎么一次找出那个生产4g的机器。</li>
</ol>
<p>将机器从1开始编号到10，每个机器取对应编号个硬币，共计55个硬币。<br>假设每个机器生产的硬币都是5g，则这55个硬币总总量为275g；<br>与实际的重量做差值，即为生产4g硬币对应机器的编号。<br>（如果是1号机器，因为只取了1个硬币，重量比2</p>
<ol start="2">
<li>给一个硬币，要求生成1&#x2F;5的概率。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">g1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / <span class="built_in">random</span>() &gt; <span class="number">0.5</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ing <span class="title">getAns</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        res = (<span class="built_in">g1</span>() &lt;&lt; <span class="number">2</span>) + (<span class="built_in">g1</span>() &lt;&lt; <span class="number">1</span>) + <span class="built_in">g1</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (res == <span class="number">7</span> || res == <span class="number">6</span> || res == <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期实习面经</title>
    <url>/2020/10/02/%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<span id="more"></span>
<p>阿里云开放平台<br>一面2.28：</p>
<ol>
<li>实习、项目介绍</li>
<li>最有挑战的项目？难点、怎么解决的？</li>
<li>内存泄漏（检测工具valgrind&#x2F;钩子函数、相关命令）</li>
<li>编程层面如何预防内存泄漏，除了智能指针？</li>
<li>linux网络编程和tcp连接对应关系</li>
<li>三次握手四次挥手，timewait、closewait</li>
<li>leveldb原理（memtable&#x2F;immemtable&#x2F;sstable&#x2F;log&#x2F;manifast&#x2F;footer）</li>
<li>vector底层实现、动态扩容</li>
<li>竞态、临界区、举例</li>
<li>ptmalloc底层实现</li>
<li>tcmalloc、jemalloc底层实现，和ptmalloc对比</li>
<li>伙伴系统、slab分配器、STL二级配置器（内存池）</li>
<li>最有成就感的项目&#x2F;经历<br>算法题：之字形打印二叉树</li>
</ol>
<p>笔试3.14</p>
<p>二面3.16：</p>
<ol>
<li>实习、项目挖10分钟</li>
<li>NUMA&#x2F;UMA</li>
<li>内核自旋锁底层实现？while和自旋锁的区别？</li>
<li>内存屏障</li>
<li>多文件全局变量的初始化顺序？例如a.cc有int a &#x3D; 10, b.cc有int b &#x3D; a, c.cc有int c &#x3D; b;问main函数中a,b,c的值是什么(随机值还是10还是0？)</li>
<li>x86架构模型</li>
<li>x86和arm在内存架构上的不同<br>算法：利用malloc和free实现自己的my_malloc和my_free，使之可以基于N字节对齐。</li>
</ol>
<p>hr面3.18：<br>聊天+谈职业规划<br>3.21意向</p>
<p>阿里云块存储<br>一面2.26：<br>算法题：字符串转整数、公共子树</p>
<ol>
<li>介绍项目、实习</li>
<li>leveldb原理</li>
<li>死锁及解决</li>
<li>如何检测系统瓶颈（cpu、磁盘、网络、内存）</li>
<li>unordered_map底层原理，扩容机制</li>
<li>struct和class的区别</li>
<li>多线程和多进程各自的优缺点</li>
<li>最近在关注的技术（HTTP3.0）</li>
<li>http3.0 为什么用udp</li>
<li>3.0实现细节、TLS3.0</li>
<li>反问</li>
</ol>
<p>二面3.1</p>
<ol>
<li>介绍</li>
<li>linux文件系统</li>
<li>零拷贝</li>
<li>c++文件编码执行整个过程20min（涉及 键盘io、中断、显示器、elf文件、编译、链接、加载、执行、物理内存、虚拟内存、进程管理等等细节）</li>
<li>linux cfs进程调度底层原理</li>
<li>磁盘缓存、布局</li>
<li>linux io细节<br>算法题：组合总和</li>
</ol>
<p>3.2通知二面过 但已选择其他部门 放弃后续面试</p>
<p>腾讯wxg3.17</p>
<ol>
<li>代码：回文串、c++单例模式：懒汉、线程安全模式、最大字符串</li>
<li>函数返回临时对象的问题</li>
<li>sizeof为0</li>
<li>移动构造使用场景</li>
<li>new时内存不够，修改abort()报错要怎么做，(operator new修改回调函数)</li>
<li>协程项目深挖（15min）</li>
<li>协程堆上内存不够了会发生什么</li>
<li>协程堆内存不够，申请两倍空间，拷贝过去会有什么问题</li>
<li>第三方库调你的协程库需要怎么做？</li>
<li>协程池必要吗？和面试官产生分歧。</li>
<li>内核函数read、write在哪个链接器里？？不知道想要问啥。</li>
<li>内核自旋锁实现</li>
<li>反问<br>3.19 挂</li>
</ol>
<p>字节基架<br>一面：</p>
<ol>
<li>介绍</li>
<li>leveldb深挖（原理，读写，存储，多key查询，压缩，合并，数据结构）</li>
<li>mysql深挖（acid，事务，隔离级别，redo，undo，mvcc，readview，多线程缓存）</li>
<li>B树、B+树，节点分裂</li>
<li>osi七层</li>
<li>虚拟内存</li>
<li>进程和线程</li>
<li>进程间通信</li>
<li>页表</li>
<li>k8s（apiserver，etcd，node，kubelet） </li>
<li>docker原理<br>算法题：二叉查找树第k小元素非递归实现（没写出来）</li>
</ol>
<p>总结：问的都是不擅长的数据库，擅长的操作系统和网络问的都是八股，算法题拉了，思路对的但是做了40分钟没写出来，应该是凉透了。<br>更新：二十分钟后询问hr 一面过<br>os:算法题没做出来过了？</p>
<p>二面：</p>
<ol>
<li>介绍</li>
<li>操作系统深挖</li>
<li>内存管理、虚拟内存</li>
<li>内核自旋锁原理，读写锁</li>
<li>NUMA、MESI</li>
<li>对计算机网络的理解</li>
<li>反问<br>算法：<br>面试官：一面算法下来写过了吗？答写了。<br>面试官：不能用辅助数据结构、空间复杂度O(1)。楼主心态爆炸，这里写了20min没写出来。<br>面试官放水：写下memcpy和strcpy？楼主已经懵逼，忘记怎么写的了，卒。<br>面试后了解到面试官应该想要实现Morris遍历。</li>
</ol>
<p>总结：算法未准备充分，字节面试还得好好刷算法。秋招再战！</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>项目要点</title>
    <url>/2021/02/17/%E9%A1%B9%E7%9B%AE%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="redis选择什么存储方式存储时间序列？"><a href="#redis选择什么存储方式存储时间序列？" class="headerlink" title="redis选择什么存储方式存储时间序列？"></a>redis选择什么存储方式存储时间序列？</h2><ul>
<li>使用场景：高并发写，低频率读。因此需要插入数据快，不能阻塞。</li>
<li>Redis适用的结构：Hash、Sorted Set以及基于RedisTimesSeries的模块实现。</li>
</ul>
<ol>
<li>Hash</li>
</ol>
<p>哈希的插入效率比较高，但是对于数据的范围查询支持度不够良好。</p>
<ol start="2">
<li>Sorted Set</li>
</ol>
<p>使用时间戳作为集合的元素分数，时间点上的流信息作为元素的值。</p>
<ol start="3">
<li>RedisTimeSeries</li>
</ol>
<h2 id="如何保证插入的原子性？"><a href="#如何保证插入的原子性？" class="headerlink" title="如何保证插入的原子性？"></a>如何保证插入的原子性？</h2><ol>
<li>MULTI命令：将接下来的命令放到内部队列中，后续一起执行，保证原子性。</li>
<li>EXEC命令：表示一系列原子操作的结束。</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
</search>
